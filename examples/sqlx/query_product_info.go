// Code generated by sqlboy. DO NOT EDIT.
package sqlx

import "context"

type ProductInfoDao interface {
	CreateProductInfo(ctx context.Context, productInfo *ProductInfo) error
	BatchCreateProductInfo(ctx context.Context, list []*ProductInfo, batchSize int) error
	FindProductInfo(ctx context.Context, id uint32) (*ProductInfo, error)
	UpdateProductInfo(ctx context.Context, productInfo *ProductInfo) error
	DeleteProductInfo(ctx context.Context, id uint32) error
	FindByProductIdSkuId(ctx context.Context, productId string, skuId string) (*ProductInfo, error)
	UpdateByProductIdSkuId(ctx context.Context, productInfo *ProductInfo) error
	DeleteByProductIdSkuId(ctx context.Context, productId string, skuId string) error
}

type ProductInfoImpl struct {
	dao *Dao
}

func NewProductInfoDao(dao *Dao) ProductInfoDao {
	return &ProductInfoImpl{
		dao: dao,
	}
}

func (d *ProductInfoImpl) CreateProductInfo(ctx context.Context, productInfo *ProductInfo) error {
	_, err := d.dao.DB(ctx).NamedExecContext(ctx, "INSERT INTO `product_info` (`id`,`product_id`,`sku_id`,`status`,`created_at`,`updated_at`) VALUES (:id,:product_id,:sku_id,:status,:created_at,:updated_at)", productInfo)
	return err
}

func (d *ProductInfoImpl) BatchCreateProductInfo(ctx context.Context, list []*ProductInfo, batchSize int) error {
	return d.dao.InTx(ctx, func(ctx context.Context) error {
		for i := 0; i < len(list); i += batchSize {
			ends := i + batchSize
			if ends > len(list) {
				ends = len(list)
			}
			_, err := d.dao.DB(ctx).NamedExecContext(ctx, "INSERT INTO `product_info` (`id`,`product_id`,`sku_id`,`status`,`created_at`,`updated_at`) VALUES (:id,:product_id,:sku_id,:status,:created_at,:updated_at)", list[i:ends])
			if err != nil {
				return err
			}
		}
		return nil
	})
}

func (d *ProductInfoImpl) FindProductInfo(ctx context.Context, id uint32) (*ProductInfo, error) {
	var productInfo ProductInfo
	if err := d.dao.DB(ctx).QueryRowxContext(ctx, "SELECT `id`,`product_id`,`sku_id`,`status`,`created_at`,`updated_at` FROM `product_info` WHERE `id` = ?", id).StructScan(&productInfo); err != nil {
		return nil, err
	}
	return &productInfo, nil
}

func (d *ProductInfoImpl) UpdateProductInfo(ctx context.Context, productInfo *ProductInfo) error {
	_, err := d.dao.DB(ctx).NamedExecContext(ctx, "UPDATE `product_info` SET `id` = :id AND `product_id` = :product_id AND `sku_id` = :sku_id AND `status` = :status AND `created_at` = :created_at AND `updated_at` = :updated_at WHERE `id` = :id", productInfo)
	return err
}

func (d *ProductInfoImpl) DeleteProductInfo(ctx context.Context, id uint32) error {
	_, err := d.dao.DB(ctx).ExecContext(ctx, "DELETE FROM `product_info` WHERE `id` = ?", id)
	return err
}

func (d *ProductInfoImpl) FindByProductIdSkuId(ctx context.Context, productId string, skuId string) (*ProductInfo, error) {
	var productInfo ProductInfo
	if err := d.dao.DB(ctx).QueryRowxContext(ctx, "SELECT `id`,`product_id`,`sku_id`,`status`,`created_at`,`updated_at` FROM `product_info` WHERE `product_id` = ? AND `sku_id` = ?", productId, skuId).StructScan(&productInfo); err != nil {
		return nil, err
	}
	return &productInfo, nil
}

func (d *ProductInfoImpl) UpdateByProductIdSkuId(ctx context.Context, productInfo *ProductInfo) error {
	_, err := d.dao.DB(ctx).NamedExecContext(ctx, "UPDATE `product_info` SET `id` = :id AND `product_id` = :product_id AND `sku_id` = :sku_id AND `status` = :status AND `created_at` = :created_at AND `updated_at` = :updated_at WHERE `product_id` = :product_id AND `sku_id` = :sku_id", productInfo)
	return err
}

func (d *ProductInfoImpl) DeleteByProductIdSkuId(ctx context.Context, productId string, skuId string) error {
	_, err := d.dao.DB(ctx).ExecContext(ctx, "DELETE FROM `product_info` WHERE `product_id` = ? AND `sku_id` = ?", productId, skuId)
	return err
}
