package ast

import (
	"bytes"
	"go/format"
	"go/token"
	parser "sqlboy/antrl"
	"testing"
)

func Test_buildModel(t *testing.T) {
	tests := []struct {
		packageName string
		tables      map[string][]parser.ColumnDecl
		tags        []Tag
	}{
		{
			packageName: "test",
			tables: map[string][]parser.ColumnDecl{
				"order_info": {
					{
						Name:    "id",
						Comment: "主键",
						GoType:  parser.Uint64,
					},
					{
						Name:    "product_name",
						Comment: "商品名称",
						GoType:  parser.String,
					},
					{
						Name:    "created_at",
						Comment: "创建时间",
						GoType:  parser.Time,
					},
				},
				"test_info123---": {
					{
						Name:    "id!@#$$",
						Comment: "主键",
						GoType:  parser.Uint64,
					},
					{
						Name:    "product_name",
						Comment: "商品名称",
						GoType:  parser.String,
					},
					{
						Name:    "created_at",
						Comment: "创建时间",
						GoType:  parser.Time,
					},
				},
			},
			tags: []Tag{Gorm, JSON},
		},
	}
	for _, tt := range tests {
		file := buildModel(tt.packageName, tt.tables, tt.tags)
		var buf bytes.Buffer
		buf.WriteString("// Code generated by sqlBoy. DO NOT EDIT.\n")
		if err := format.Node(&buf, token.NewFileSet(), file); err != nil {
			t.Error(err)
		}
		t.Log(buf.String())
	}
}

func Test_camelCase(t *testing.T) {
	tests := []struct {
		in   string
		want string
	}{
		{
			in:   "order_info",
			want: "OrderInfo",
		},
		{
			in:   "order_info_product_info",
			want: "OrderInfoProductInfo",
		},
		{
			in:   "order_info123",
			want: "OrderInfo123",
		},
		{
			in:   "order_info123@!#$^$^_test",
			want: "OrderInfo123Test",
		},
	}
	for _, tt := range tests {
		got := camelCase(tt.in)
		if got != tt.want {
			t.Errorf("in(%s) got(%s) want(%s)", tt.in, got, tt.want)
		}
	}
}
