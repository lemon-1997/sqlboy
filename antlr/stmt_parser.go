// Code generated from ./antlr/StmtParser.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // StmtParser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type StmtParser struct {
	*antlr.BaseParser
}

var StmtParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func stmtparserParserInit() {
	staticData := &StmtParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "'ADD'", "'ALL'", "'ALTER'", "'ALWAYS'", "'ANALYZE'",
		"'AND'", "'ARRAY'", "'AS'", "'ASC'", "'BEFORE'", "'BETWEEN'", "'BOTH'",
		"'BUCKETS'", "'BY'", "'CALL'", "'CASCADE'", "'CASE'", "'CAST'", "'CHANGE'",
		"'CHARACTER'", "'CHECK'", "'COLLATE'", "'COLUMN'", "'CONDITION'", "'CONSTRAINT'",
		"'CONTINUE'", "'CONVERT'", "'CREATE'", "'CROSS'", "'CURRENT'", "'CURRENT_USER'",
		"'CURSOR'", "'DATABASE'", "'DATABASES'", "'DECLARE'", "'DEFAULT'", "'DELAYED'",
		"'DELETE'", "'DESC'", "'DESCRIBE'", "'DETERMINISTIC'", "'DIAGNOSTICS'",
		"'DISTINCT'", "'DISTINCTROW'", "'DROP'", "'EACH'", "'ELSE'", "'ELSEIF'",
		"'EMPTY'", "'ENCLOSED'", "'ESCAPED'", "'EXCEPT'", "'EXISTS'", "'EXIT'",
		"'EXPLAIN'", "'FALSE'", "'FETCH'", "'FOR'", "'FORCE'", "'FOREIGN'",
		"'FROM'", "'FULLTEXT'", "'GENERATED'", "'GET'", "'GRANT'", "'GROUP'",
		"'HAVING'", "'HIGH_PRIORITY'", "'HISTOGRAM'", "'IF'", "'IGNORE'", "'IGNORED'",
		"'IN'", "'INDEX'", "'INFILE'", "'INNER'", "'INOUT'", "'INSERT'", "'INTERVAL'",
		"'INTO'", "'IS'", "'ITERATE'", "'JOIN'", "'KEY'", "'KEYS'", "'KILL'",
		"'LEADING'", "'LEAVE'", "'LEFT'", "'LIKE'", "'LIMIT'", "'LINEAR'", "'LINES'",
		"'LOAD'", "'LOCK'", "'LOCKED'", "'LOOP'", "'LOW_PRIORITY'", "'MASTER_BIND'",
		"'MASTER_SSL_VERIFY_SERVER_CERT'", "'MATCH'", "'MAXVALUE'", "'MINVALUE'",
		"'MODIFIES'", "'NATURAL'", "'NOT'", "'NO_WRITE_TO_BINLOG'", "'NULL'",
		"'NUMBER'", "'ON'", "'OPTIMIZE'", "'OPTION'", "'OPTIONAL'", "'OPTIONALLY'",
		"'OR'", "'ORDER'", "'OUT'", "'OVER'", "'OUTER'", "'OUTFILE'", "'PARTITION'",
		"'PRIMARY'", "'PROCEDURE'", "'PURGE'", "'RANGE'", "'READ'", "'READS'",
		"'REFERENCES'", "'REGEXP'", "'RELEASE'", "'RENAME'", "'REPEAT'", "'REPLACE'",
		"'REQUIRE'", "'RESIGNAL'", "'RESTRICT'", "'RETAIN'", "'RETURN'", "'REVOKE'",
		"'RIGHT'", "'RLIKE'", "'SCHEMA'", "'SCHEMAS'", "'SELECT'", "'SET'",
		"'SEPARATOR'", "'SHOW'", "'SIGNAL'", "'SKIP'", "'SPATIAL'", "'SQL'",
		"'SQLEXCEPTION'", "'SQLSTATE'", "'SQLWARNING'", "'SQL_BIG_RESULT'",
		"'SQL_CALC_FOUND_ROWS'", "'SQL_SMALL_RESULT'", "'SSL'", "'STACKED'",
		"'STARTING'", "'STRAIGHT_JOIN'", "'TABLE'", "'TERMINATED'", "'THEN'",
		"'TO'", "'TRAILING'", "'TRIGGER'", "'TRUE'", "'UNDO'", "'UNION'", "'UNIQUE'",
		"'UNLOCK'", "'UNSIGNED'", "'UPDATE'", "'USAGE'", "'USE'", "'USING'",
		"'VALUES'", "'WHEN'", "'WHERE'", "'WHILE'", "'WITH'", "'WRITE'", "'XOR'",
		"'ZEROFILL'", "'TINYINT'", "'SMALLINT'", "'MEDIUMINT'", "'MIDDLEINT'",
		"'INT'", "'INT1'", "'INT2'", "'INT3'", "'INT4'", "'INT8'", "'INTEGER'",
		"'BIGINT'", "'REAL'", "'DOUBLE'", "'PRECISION'", "'FLOAT'", "'FLOAT4'",
		"'FLOAT8'", "'DECIMAL'", "'DEC'", "'NUMERIC'", "'DATE'", "'TIME'", "'TIMESTAMP'",
		"'DATETIME'", "'YEAR'", "'CHAR'", "'VARCHAR'", "'NVARCHAR'", "'NATIONAL'",
		"'BINARY'", "'VARBINARY'", "'TINYBLOB'", "'BLOB'", "'MEDIUMBLOB'", "'LONG'",
		"'LONGBLOB'", "'TINYTEXT'", "'TEXT'", "'MEDIUMTEXT'", "'LONGTEXT'",
		"'ENUM'", "'VARYING'", "'SERIAL'", "'YEAR_MONTH'", "'DAY_HOUR'", "'DAY_MINUTE'",
		"'DAY_SECOND'", "'HOUR_MINUTE'", "'HOUR_SECOND'", "'MINUTE_SECOND'",
		"'SECOND_MICROSECOND'", "'MINUTE_MICROSECOND'", "'HOUR_MICROSECOND'",
		"'DAY_MICROSECOND'", "'JSON_ARRAY'", "'JSON_OBJECT'", "'JSON_QUOTE'",
		"'JSON_CONTAINS'", "'JSON_CONTAINS_PATH'", "'JSON_EXTRACT'", "'JSON_KEYS'",
		"'JSON_OVERLAPS'", "'JSON_SEARCH'", "'JSON_VALUE'", "'JSON_ARRAY_APPEND'",
		"'JSON_ARRAY_INSERT'", "'JSON_INSERT'", "'JSON_MERGE'", "'JSON_MERGE_PATCH'",
		"'JSON_MERGE_PRESERVE'", "'JSON_REMOVE'", "'JSON_REPLACE'", "'JSON_SET'",
		"'JSON_UNQUOTE'", "'JSON_DEPTH'", "'JSON_LENGTH'", "'JSON_TYPE'", "'JSON_VALID'",
		"'JSON_TABLE'", "'JSON_SCHEMA_VALID'", "'JSON_SCHEMA_VALIDATION_REPORT'",
		"'JSON_PRETTY'", "'JSON_STORAGE_FREE'", "'JSON_STORAGE_SIZE'", "'JSON_ARRAYAGG'",
		"'JSON_OBJECTAGG'", "'AVG'", "'BIT_AND'", "'BIT_OR'", "'BIT_XOR'", "'COUNT'",
		"'CUME_DIST'", "'DENSE_RANK'", "'FIRST_VALUE'", "'GROUP_CONCAT'", "'LAG'",
		"'LAST_VALUE'", "'LEAD'", "'MAX'", "'MIN'", "'NTILE'", "'NTH_VALUE'",
		"'PERCENT_RANK'", "'RANK'", "'ROW_NUMBER'", "'STD'", "'STDDEV'", "'STDDEV_POP'",
		"'STDDEV_SAMP'", "'SUM'", "'VAR_POP'", "'VAR_SAMP'", "'VARIANCE'", "'CURRENT_DATE'",
		"'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'LOCALTIME'", "'CURDATE'",
		"'CURTIME'", "'DATE_ADD'", "'DATE_SUB'", "'EXTRACT'", "'LOCALTIMESTAMP'",
		"'NOW'", "'POSITION'", "'SUBSTR'", "'SUBSTRING'", "'SYSDATE'", "'TRIM'",
		"'UTC_DATE'", "'UTC_TIME'", "'UTC_TIMESTAMP'", "'ACCOUNT'", "'ACTION'",
		"'AFTER'", "'AGGREGATE'", "'ALGORITHM'", "'ANY'", "'AT'", "'AUTHORS'",
		"'AUTOCOMMIT'", "'AUTOEXTEND_SIZE'", "'AUTO_INCREMENT'", "'AVG_ROW_LENGTH'",
		"'BEGIN'", "'BINLOG'", "'BIT'", "'BLOCK'", "'BOOL'", "'BOOLEAN'", "'BTREE'",
		"'CACHE'", "'CASCADED'", "'CHAIN'", "'CHANGED'", "'CHANNEL'", "'CHECKSUM'",
		"'PAGE_CHECKSUM'", "'CIPHER'", "'CLASS_ORIGIN'", "'CLIENT'", "'CLOSE'",
		"'CLUSTERING'", "'COALESCE'", "'CODE'", "'COLUMNS'", "'COLUMN_FORMAT'",
		"'COLUMN_NAME'", "'COMMENT'", "'COMMIT'", "'COMPACT'", "'COMPLETION'",
		"'COMPRESSED'", "'COMPRESSION'", "'CONCURRENT'", "'CONNECT'", "'CONNECTION'",
		"'CONSISTENT'", "'CONSTRAINT_CATALOG'", "'CONSTRAINT_SCHEMA'", "'CONSTRAINT_NAME'",
		"'CONTAINS'", "'CONTEXT'", "'CONTRIBUTORS'", "'COPY'", "'CPU'", "'CYCLE'",
		"'CURSOR_NAME'", "'DATA'", "'DATAFILE'", "'DEALLOCATE'", "'DEFAULT_AUTH'",
		"'DEFINER'", "'DELAY_KEY_WRITE'", "'DES_KEY_FILE'", "'DIRECTORY'", "'DISABLE'",
		"'DISCARD'", "'DISK'", "'DO'", "'DUMPFILE'", "'DUPLICATE'", "'DYNAMIC'",
		"'ENABLE'", "'ENCRYPTION'", "'END'", "'ENDS'", "'ENGINE'", "'ENGINES'",
		"'ERROR'", "'ERRORS'", "'ESCAPE'", "'EVEN'", "'EVENT'", "'EVENTS'",
		"'EVERY'", "'EXCHANGE'", "'EXCLUSIVE'", "'EXPIRE'", "'EXPORT'", "'EXTENDED'",
		"'EXTENT_SIZE'", "'FAST'", "'FAULTS'", "'FIELDS'", "'FILE_BLOCK_SIZE'",
		"'FILTER'", "'FIRST'", "'FIXED'", "'FLUSH'", "'FOLLOWING'", "'FOLLOWS'",
		"'FOUND'", "'FULL'", "'FUNCTION'", "'GENERAL'", "'GLOBAL'", "'GRANTS'",
		"'GROUP_REPLICATION'", "'HANDLER'", "'HASH'", "'HELP'", "'HOST'", "'HOSTS'",
		"'IDENTIFIED'", "'IGNORE_SERVER_IDS'", "'IMPORT'", "'INCREMENT'", "'INDEXES'",
		"'INITIAL_SIZE'", "'INPLACE'", "'INSERT_METHOD'", "'INSTALL'", "'INSTANCE'",
		"'INSTANT'", "'INVISIBLE'", "'INVOKER'", "'IO'", "'IO_THREAD'", "'IPC'",
		"'ISOLATION'", "'ISSUER'", "'JSON'", "'KEY_BLOCK_SIZE'", "'LANGUAGE'",
		"'LAST'", "'LEAVES'", "'LESS'", "'LEVEL'", "'LIST'", "'LOCAL'", "'LOGFILE'",
		"'LOGS'", "'MASTER'", "'MASTER_AUTO_POSITION'", "'MASTER_CONNECT_RETRY'",
		"'MASTER_DELAY'", "'MASTER_HEARTBEAT_PERIOD'", "'MASTER_HOST'", "'MASTER_LOG_FILE'",
		"'MASTER_LOG_POS'", "'MASTER_PASSWORD'", "'MASTER_PORT'", "'MASTER_RETRY_COUNT'",
		"'MASTER_SSL'", "'MASTER_SSL_CA'", "'MASTER_SSL_CAPATH'", "'MASTER_SSL_CERT'",
		"'MASTER_SSL_CIPHER'", "'MASTER_SSL_CRL'", "'MASTER_SSL_CRLPATH'", "'MASTER_SSL_KEY'",
		"'MASTER_TLS_VERSION'", "'MASTER_USER'", "'MAX_CONNECTIONS_PER_HOUR'",
		"'MAX_QUERIES_PER_HOUR'", "'MAX_ROWS'", "'MAX_SIZE'", "'MAX_UPDATES_PER_HOUR'",
		"'MAX_USER_CONNECTIONS'", "'MEDIUM'", "'MEMBER'", "'MERGE'", "'MESSAGE_TEXT'",
		"'MID'", "'MIGRATE'", "'MIN_ROWS'", "'MODE'", "'MODIFY'", "'MUTEX'",
		"'MYSQL'", "'MYSQL_ERRNO'", "'NAME'", "'NAMES'", "'NCHAR'", "'NEVER'",
		"'NEXT'", "'NO'", "'NOCACHE'", "'NOCOPY'", "'NOCYCLE'", "'NOMAXVALUE'",
		"'NOMINVALUE'", "'NOWAIT'", "'NODEGROUP'", "'NONE'", "'ODBC'", "'OFFLINE'",
		"'OFFSET'", "'OF'", "'OJ'", "'OLD_PASSWORD'", "'ONE'", "'ONLINE'", "'ONLY'",
		"'OPEN'", "'OPTIMIZER_COSTS'", "'OPTIONS'", "'OWNER'", "'PACK_KEYS'",
		"'PAGE'", "'PARSER'", "'PARTIAL'", "'PARTITIONING'", "'PARTITIONS'",
		"'PASSWORD'", "'PHASE'", "'PLUGIN'", "'PLUGIN_DIR'", "'PLUGINS'", "'PORT'",
		"'PRECEDES'", "'PRECEDING'", "'PREPARE'", "'PRESERVE'", "'PREV'", "'PROCESSLIST'",
		"'PROFILE'", "'PROFILES'", "'PROXY'", "'QUERY'", "'QUICK'", "'REBUILD'",
		"'RECOVER'", "'RECURSIVE'", "'REDO_BUFFER_SIZE'", "'REDUNDANT'", "'RELAY'",
		"'RELAY_LOG_FILE'", "'RELAY_LOG_POS'", "'RELAYLOG'", "'REMOVE'", "'REORGANIZE'",
		"'REPAIR'", "'REPLICATE_DO_DB'", "'REPLICATE_DO_TABLE'", "'REPLICATE_IGNORE_DB'",
		"'REPLICATE_IGNORE_TABLE'", "'REPLICATE_REWRITE_DB'", "'REPLICATE_WILD_DO_TABLE'",
		"'REPLICATE_WILD_IGNORE_TABLE'", "'REPLICATION'", "'RESET'", "'RESTART'",
		"'RESUME'", "'RETURNED_SQLSTATE'", "'RETURNING'", "'RETURNS'", "'ROLE'",
		"'ROLLBACK'", "'ROLLUP'", "'ROTATE'", "'ROW'", "'ROWS'", "'ROW_FORMAT'",
		"'RTREE'", "'SAVEPOINT'", "'SCHEDULE'", "'SECURITY'", "'SEQUENCE'",
		"'SERVER'", "'SESSION'", "'SHARE'", "'SHARED'", "'SIGNED'", "'SIMPLE'",
		"'SLAVE'", "'SLOW'", "'SNAPSHOT'", "'SOCKET'", "'SOME'", "'SONAME'",
		"'SOUNDS'", "'SOURCE'", "'SQL_AFTER_GTIDS'", "'SQL_AFTER_MTS_GAPS'",
		"'SQL_BEFORE_GTIDS'", "'SQL_BUFFER_RESULT'", "'SQL_CACHE'", "'SQL_NO_CACHE'",
		"'SQL_THREAD'", "'START'", "'STARTS'", "'STATS_AUTO_RECALC'", "'STATS_PERSISTENT'",
		"'STATS_SAMPLE_PAGES'", "'STATUS'", "'STOP'", "'STORAGE'", "'STORED'",
		"'STRING'", "'SUBCLASS_ORIGIN'", "'SUBJECT'", "'SUBPARTITION'", "'SUBPARTITIONS'",
		"'SUSPEND'", "'SWAPS'", "'SWITCHES'", "'TABLE_NAME'", "'TABLESPACE'",
		"'TABLE_TYPE'", "'TEMPORARY'", "'TEMPTABLE'", "'THAN'", "'TRADITIONAL'",
		"'TRANSACTION'", "'TRANSACTIONAL'", "'TRIGGERS'", "'TRUNCATE'", "'UNBOUNDED'",
		"'UNDEFINED'", "'UNDOFILE'", "'UNDO_BUFFER_SIZE'", "'UNINSTALL'", "'UNKNOWN'",
		"'UNTIL'", "'UPGRADE'", "'USER'", "'USE_FRM'", "'USER_RESOURCES'", "'VALIDATION'",
		"'VALUE'", "'VARIABLES'", "'VIEW'", "'VIRTUAL'", "'VISIBLE'", "'WAIT'",
		"'WARNINGS'", "'WINDOW'", "'WITHOUT'", "'WORK'", "'WRAPPER'", "'X509'",
		"'XA'", "'XML'", "'YES'", "'EUR'", "'USA'", "'JIS'", "'ISO'", "'INTERNAL'",
		"'QUARTER'", "'MONTH'", "'DAY'", "'HOUR'", "'MINUTE'", "'WEEK'", "'SECOND'",
		"'MICROSECOND'", "'TABLES'", "'ROUTINE'", "'EXECUTE'", "'FILE'", "'PROCESS'",
		"'RELOAD'", "'SHUTDOWN'", "'SUPER'", "'PRIVILEGES'", "'APPLICATION_PASSWORD_ADMIN'",
		"'AUDIT_ADMIN'", "'BACKUP_ADMIN'", "'BINLOG_ADMIN'", "'BINLOG_ENCRYPTION_ADMIN'",
		"'CLONE_ADMIN'", "'CONNECTION_ADMIN'", "'ENCRYPTION_KEY_ADMIN'", "'FIREWALL_ADMIN'",
		"'FIREWALL_USER'", "'FLUSH_OPTIMIZER_COSTS'", "'FLUSH_STATUS'", "'FLUSH_TABLES'",
		"'FLUSH_USER_RESOURCES'", "'ADMIN'", "'GROUP_REPLICATION_ADMIN'", "'INNODB_REDO_LOG_ARCHIVE'",
		"'INNODB_REDO_LOG_ENABLE'", "'INVOKE'", "'LAMBDA'", "'NDB_STORED_USER'",
		"'PASSWORDLESS_USER_ADMIN'", "'PERSIST_RO_VARIABLES_ADMIN'", "'REPLICATION_APPLIER'",
		"'REPLICATION_SLAVE_ADMIN'", "'RESOURCE_GROUP_ADMIN'", "'RESOURCE_GROUP_USER'",
		"'ROLE_ADMIN'", "'S3'", "'SERVICE_CONNECTION_ADMIN'", "", "'SET_USER_ID'",
		"'SHOW_ROUTINE'", "'SYSTEM_VARIABLES_ADMIN'", "'TABLE_ENCRYPTION_ADMIN'",
		"'VERSION_TOKEN_ADMIN'", "'XA_RECOVER_ADMIN'", "'ARMSCII8'", "'ASCII'",
		"'BIG5'", "'CP1250'", "'CP1251'", "'CP1256'", "'CP1257'", "'CP850'",
		"'CP852'", "'CP866'", "'CP932'", "'DEC8'", "'EUCJPMS'", "'EUCKR'", "'GB18030'",
		"'GB2312'", "'GBK'", "'GEOSTD8'", "'GREEK'", "'HEBREW'", "'HP8'", "'KEYBCS2'",
		"'KOI8R'", "'KOI8U'", "'LATIN1'", "'LATIN2'", "'LATIN5'", "'LATIN7'",
		"'MACCE'", "'MACROMAN'", "'SJIS'", "'SWE7'", "'TIS620'", "'UCS2'", "'UJIS'",
		"'UTF16'", "'UTF16LE'", "'UTF32'", "'UTF8'", "'UTF8MB3'", "'UTF8MB4'",
		"'ARCHIVE'", "'BLACKHOLE'", "'CSV'", "'FEDERATED'", "'INNODB'", "'MEMORY'",
		"'MRG_MYISAM'", "'MYISAM'", "'NDB'", "'NDBCLUSTER'", "'PERFORMANCE_SCHEMA'",
		"'TOKUDB'", "'REPEATABLE'", "'COMMITTED'", "'UNCOMMITTED'", "'SERIALIZABLE'",
		"'GEOMETRYCOLLECTION'", "'GEOMCOLLECTION'", "'GEOMETRY'", "'LINESTRING'",
		"'MULTILINESTRING'", "'MULTIPOINT'", "'MULTIPOLYGON'", "'POINT'", "'POLYGON'",
		"'ABS'", "'ACOS'", "'ADDDATE'", "'ADDTIME'", "'AES_DECRYPT'", "'AES_ENCRYPT'",
		"'AREA'", "'ASBINARY'", "'ASIN'", "'ASTEXT'", "'ASWKB'", "'ASWKT'",
		"'ASYMMETRIC_DECRYPT'", "'ASYMMETRIC_DERIVE'", "'ASYMMETRIC_ENCRYPT'",
		"'ASYMMETRIC_SIGN'", "'ASYMMETRIC_VERIFY'", "'ATAN'", "'ATAN2'", "'BENCHMARK'",
		"'BIN'", "'BIT_COUNT'", "'BIT_LENGTH'", "'BUFFER'", "'CATALOG_NAME'",
		"'CEIL'", "'CEILING'", "'CENTROID'", "'CHARACTER_LENGTH'", "'CHARSET'",
		"'CHAR_LENGTH'", "'COERCIBILITY'", "'COLLATION'", "'COMPRESS'", "'CONCAT'",
		"'CONCAT_WS'", "'CONNECTION_ID'", "'CONV'", "'CONVERT_TZ'", "'COS'",
		"'COT'", "'CRC32'", "'CREATE_ASYMMETRIC_PRIV_KEY'", "'CREATE_ASYMMETRIC_PUB_KEY'",
		"'CREATE_DH_PARAMETERS'", "'CREATE_DIGEST'", "'CROSSES'", "'DATEDIFF'",
		"'DATE_FORMAT'", "'DAYNAME'", "'DAYOFMONTH'", "'DAYOFWEEK'", "'DAYOFYEAR'",
		"'DECODE'", "'DEGREES'", "'DES_DECRYPT'", "'DES_ENCRYPT'", "'DIMENSION'",
		"'DISJOINT'", "'ELT'", "'ENCODE'", "'ENCRYPT'", "'ENDPOINT'", "'ENGINE_ATTRIBUTE'",
		"'ENVELOPE'", "'EQUALS'", "'EXP'", "'EXPORT_SET'", "'EXTERIORRING'",
		"'EXTRACTVALUE'", "'FIELD'", "'FIND_IN_SET'", "'FLOOR'", "'FORMAT'",
		"'FOUND_ROWS'", "'FROM_BASE64'", "'FROM_DAYS'", "'FROM_UNIXTIME'", "'GEOMCOLLFROMTEXT'",
		"'GEOMCOLLFROMWKB'", "'GEOMETRYCOLLECTIONFROMTEXT'", "'GEOMETRYCOLLECTIONFROMWKB'",
		"'GEOMETRYFROMTEXT'", "'GEOMETRYFROMWKB'", "'GEOMETRYN'", "'GEOMETRYTYPE'",
		"'GEOMFROMTEXT'", "'GEOMFROMWKB'", "'GET_FORMAT'", "'GET_LOCK'", "'GLENGTH'",
		"'GREATEST'", "'GTID_SUBSET'", "'GTID_SUBTRACT'", "'HEX'", "'IFNULL'",
		"'INET6_ATON'", "'INET6_NTOA'", "'INET_ATON'", "'INET_NTOA'", "'INSTR'",
		"'INTERIORRINGN'", "'INTERSECTS'", "'ISCLOSED'", "'ISEMPTY'", "'ISNULL'",
		"'ISSIMPLE'", "'IS_FREE_LOCK'", "'IS_IPV4'", "'IS_IPV4_COMPAT'", "'IS_IPV4_MAPPED'",
		"'IS_IPV6'", "'IS_USED_LOCK'", "'LAST_INSERT_ID'", "'LCASE'", "'LEAST'",
		"'LENGTH'", "'LINEFROMTEXT'", "'LINEFROMWKB'", "'LINESTRINGFROMTEXT'",
		"'LINESTRINGFROMWKB'", "'LN'", "'LOAD_FILE'", "'LOCATE'", "'LOG'", "'LOG10'",
		"'LOG2'", "'LOWER'", "'LPAD'", "'LTRIM'", "'MAKEDATE'", "'MAKETIME'",
		"'MAKE_SET'", "'MASTER_POS_WAIT'", "'MBRCONTAINS'", "'MBRDISJOINT'",
		"'MBREQUAL'", "'MBRINTERSECTS'", "'MBROVERLAPS'", "'MBRTOUCHES'", "'MBRWITHIN'",
		"'MD5'", "'MLINEFROMTEXT'", "'MLINEFROMWKB'", "'MONTHNAME'", "'MPOINTFROMTEXT'",
		"'MPOINTFROMWKB'", "'MPOLYFROMTEXT'", "'MPOLYFROMWKB'", "'MULTILINESTRINGFROMTEXT'",
		"'MULTILINESTRINGFROMWKB'", "'MULTIPOINTFROMTEXT'", "'MULTIPOINTFROMWKB'",
		"'MULTIPOLYGONFROMTEXT'", "'MULTIPOLYGONFROMWKB'", "'NAME_CONST'", "'NULLIF'",
		"'NUMGEOMETRIES'", "'NUMINTERIORRINGS'", "'NUMPOINTS'", "'OCT'", "'OCTET_LENGTH'",
		"'ORD'", "'OVERLAPS'", "'PERIOD_ADD'", "'PERIOD_DIFF'", "'PI'", "'POINTFROMTEXT'",
		"'POINTFROMWKB'", "'POINTN'", "'POLYFROMTEXT'", "'POLYFROMWKB'", "'POLYGONFROMTEXT'",
		"'POLYGONFROMWKB'", "'POW'", "'POWER'", "'QUOTE'", "'RADIANS'", "'RAND'",
		"'RANDOM_BYTES'", "'RELEASE_LOCK'", "'REVERSE'", "'ROUND'", "'ROW_COUNT'",
		"'RPAD'", "'RTRIM'", "'SEC_TO_TIME'", "'SECONDARY_ENGINE_ATTRIBUTE'",
		"'SESSION_USER'", "'SHA'", "'SHA1'", "'SHA2'", "'SCHEMA_NAME'", "'SIGN'",
		"'SIN'", "'SLEEP'", "'SOUNDEX'", "'SQL_THREAD_WAIT_AFTER_GTIDS'", "'SQRT'",
		"'SRID'", "'STARTPOINT'", "'STRCMP'", "'STR_TO_DATE'", "'ST_AREA'",
		"'ST_ASBINARY'", "'ST_ASTEXT'", "'ST_ASWKB'", "'ST_ASWKT'", "'ST_BUFFER'",
		"'ST_CENTROID'", "'ST_CONTAINS'", "'ST_CROSSES'", "'ST_DIFFERENCE'",
		"'ST_DIMENSION'", "'ST_DISJOINT'", "'ST_DISTANCE'", "'ST_ENDPOINT'",
		"'ST_ENVELOPE'", "'ST_EQUALS'", "'ST_EXTERIORRING'", "'ST_GEOMCOLLFROMTEXT'",
		"'ST_GEOMCOLLFROMTXT'", "'ST_GEOMCOLLFROMWKB'", "'ST_GEOMETRYCOLLECTIONFROMTEXT'",
		"'ST_GEOMETRYCOLLECTIONFROMWKB'", "'ST_GEOMETRYFROMTEXT'", "'ST_GEOMETRYFROMWKB'",
		"'ST_GEOMETRYN'", "'ST_GEOMETRYTYPE'", "'ST_GEOMFROMTEXT'", "'ST_GEOMFROMWKB'",
		"'ST_INTERIORRINGN'", "'ST_INTERSECTION'", "'ST_INTERSECTS'", "'ST_ISCLOSED'",
		"'ST_ISEMPTY'", "'ST_ISSIMPLE'", "'ST_LINEFROMTEXT'", "'ST_LINEFROMWKB'",
		"'ST_LINESTRINGFROMTEXT'", "'ST_LINESTRINGFROMWKB'", "'ST_NUMGEOMETRIES'",
		"'ST_NUMINTERIORRING'", "'ST_NUMINTERIORRINGS'", "'ST_NUMPOINTS'", "'ST_OVERLAPS'",
		"'ST_POINTFROMTEXT'", "'ST_POINTFROMWKB'", "'ST_POINTN'", "'ST_POLYFROMTEXT'",
		"'ST_POLYFROMWKB'", "'ST_POLYGONFROMTEXT'", "'ST_POLYGONFROMWKB'", "'ST_SRID'",
		"'ST_STARTPOINT'", "'ST_SYMDIFFERENCE'", "'ST_TOUCHES'", "'ST_UNION'",
		"'ST_WITHIN'", "'ST_X'", "'ST_Y'", "'SUBDATE'", "'SUBSTRING_INDEX'",
		"'SUBTIME'", "'SYSTEM_USER'", "'TAN'", "'TIMEDIFF'", "'TIMESTAMPADD'",
		"'TIMESTAMPDIFF'", "'TIME_FORMAT'", "'TIME_TO_SEC'", "'TOUCHES'", "'TO_BASE64'",
		"'TO_DAYS'", "'TO_SECONDS'", "'UCASE'", "'UNCOMPRESS'", "'UNCOMPRESSED_LENGTH'",
		"'UNHEX'", "'UNIX_TIMESTAMP'", "'UPDATEXML'", "'UPPER'", "'UUID'", "'UUID_SHORT'",
		"'VALIDATE_PASSWORD_STRENGTH'", "'VERSION'", "'WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS'",
		"'WEEKDAY'", "'WEEKOFYEAR'", "'WEIGHT_STRING'", "'WITHIN'", "'YEARWEEK'",
		"'Y'", "'X'", "'VIA'", "'LASTVAL'", "'NEXTVAL'", "'SETVAL'", "'PREVIOUS'",
		"'PERSISTENT'", "'BINLOG_MONITOR'", "'BINLOG_REPLAY'", "'FEDERATED_ADMIN'",
		"'READ_ONLY_ADMIN'", "'REPLICA'", "'REPLICATION_MASTER_ADMIN'", "':='",
		"'+='", "'-='", "'*='", "'/='", "'%='", "'&='", "'^='", "'|='", "'*'",
		"'/'", "'%'", "'+'", "'-'", "'DIV'", "'MOD'", "'='", "'>'", "'<'", "'!'",
		"'~'", "'|'", "'&'", "'^'", "'.'", "'('", "')'", "','", "';'", "'@'",
		"'0'", "'1'", "'2'", "'''", "'\"'", "'`'", "':'",
	}
	staticData.SymbolicNames = []string{
		"", "SPACE", "SPEC_MYSQL_COMMENT", "COMMENT_INPUT", "LINE_COMMENT",
		"ADD", "ALL", "ALTER", "ALWAYS", "ANALYZE", "AND", "ARRAY", "AS", "ASC",
		"BEFORE", "BETWEEN", "BOTH", "BUCKETS", "BY", "CALL", "CASCADE", "CASE",
		"CAST", "CHANGE", "CHARACTER", "CHECK", "COLLATE", "COLUMN", "CONDITION",
		"CONSTRAINT", "CONTINUE", "CONVERT", "CREATE", "CROSS", "CURRENT", "CURRENT_USER",
		"CURSOR", "DATABASE", "DATABASES", "DECLARE", "DEFAULT", "DELAYED",
		"DELETE", "DESC", "DESCRIBE", "DETERMINISTIC", "DIAGNOSTICS", "DISTINCT",
		"DISTINCTROW", "DROP", "EACH", "ELSE", "ELSEIF", "EMPTY", "ENCLOSED",
		"ESCAPED", "EXCEPT", "EXISTS", "EXIT", "EXPLAIN", "FALSE", "FETCH",
		"FOR", "FORCE", "FOREIGN", "FROM", "FULLTEXT", "GENERATED", "GET", "GRANT",
		"GROUP", "HAVING", "HIGH_PRIORITY", "HISTOGRAM", "IF", "IGNORE", "IGNORED",
		"IN", "INDEX", "INFILE", "INNER", "INOUT", "INSERT", "INTERVAL", "INTO",
		"IS", "ITERATE", "JOIN", "KEY", "KEYS", "KILL", "LEADING", "LEAVE",
		"LEFT", "LIKE", "LIMIT", "LINEAR", "LINES", "LOAD", "LOCK", "LOCKED",
		"LOOP", "LOW_PRIORITY", "MASTER_BIND", "MASTER_SSL_VERIFY_SERVER_CERT",
		"MATCH", "MAXVALUE", "MINVALUE", "MODIFIES", "NATURAL", "NOT", "NO_WRITE_TO_BINLOG",
		"NULL_LITERAL", "NUMBER", "ON", "OPTIMIZE", "OPTION", "OPTIONAL", "OPTIONALLY",
		"OR", "ORDER", "OUT", "OVER", "OUTER", "OUTFILE", "PARTITION", "PRIMARY",
		"PROCEDURE", "PURGE", "RANGE", "READ", "READS", "REFERENCES", "REGEXP",
		"RELEASE", "RENAME", "REPEAT", "REPLACE", "REQUIRE", "RESIGNAL", "RESTRICT",
		"RETAIN", "RETURN", "REVOKE", "RIGHT", "RLIKE", "SCHEMA", "SCHEMAS",
		"SELECT", "SET", "SEPARATOR", "SHOW", "SIGNAL", "SKIP_", "SPATIAL",
		"SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT", "SQL_CALC_FOUND_ROWS",
		"SQL_SMALL_RESULT", "SSL", "STACKED", "STARTING", "STRAIGHT_JOIN", "TABLE",
		"TERMINATED", "THEN", "TO", "TRAILING", "TRIGGER", "TRUE", "UNDO", "UNION",
		"UNIQUE", "UNLOCK", "UNSIGNED", "UPDATE", "USAGE", "USE", "USING", "VALUES",
		"WHEN", "WHERE", "WHILE", "WITH", "WRITE", "XOR", "ZEROFILL", "TINYINT",
		"SMALLINT", "MEDIUMINT", "MIDDLEINT", "INT", "INT1", "INT2", "INT3",
		"INT4", "INT8", "INTEGER", "BIGINT", "REAL", "DOUBLE", "PRECISION",
		"FLOAT", "FLOAT4", "FLOAT8", "DECIMAL", "DEC", "NUMERIC", "DATE", "TIME",
		"TIMESTAMP", "DATETIME", "YEAR", "CHAR", "VARCHAR", "NVARCHAR", "NATIONAL",
		"BINARY", "VARBINARY", "TINYBLOB", "BLOB", "MEDIUMBLOB", "LONG", "LONGBLOB",
		"TINYTEXT", "TEXT", "MEDIUMTEXT", "LONGTEXT", "ENUM", "VARYING", "SERIAL",
		"YEAR_MONTH", "DAY_HOUR", "DAY_MINUTE", "DAY_SECOND", "HOUR_MINUTE",
		"HOUR_SECOND", "MINUTE_SECOND", "SECOND_MICROSECOND", "MINUTE_MICROSECOND",
		"HOUR_MICROSECOND", "DAY_MICROSECOND", "JSON_ARRAY", "JSON_OBJECT",
		"JSON_QUOTE", "JSON_CONTAINS", "JSON_CONTAINS_PATH", "JSON_EXTRACT",
		"JSON_KEYS", "JSON_OVERLAPS", "JSON_SEARCH", "JSON_VALUE", "JSON_ARRAY_APPEND",
		"JSON_ARRAY_INSERT", "JSON_INSERT", "JSON_MERGE", "JSON_MERGE_PATCH",
		"JSON_MERGE_PRESERVE", "JSON_REMOVE", "JSON_REPLACE", "JSON_SET", "JSON_UNQUOTE",
		"JSON_DEPTH", "JSON_LENGTH", "JSON_TYPE", "JSON_VALID", "JSON_TABLE",
		"JSON_SCHEMA_VALID", "JSON_SCHEMA_VALIDATION_REPORT", "JSON_PRETTY",
		"JSON_STORAGE_FREE", "JSON_STORAGE_SIZE", "JSON_ARRAYAGG", "JSON_OBJECTAGG",
		"AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "COUNT", "CUME_DIST", "DENSE_RANK",
		"FIRST_VALUE", "GROUP_CONCAT", "LAG", "LAST_VALUE", "LEAD", "MAX", "MIN",
		"NTILE", "NTH_VALUE", "PERCENT_RANK", "RANK", "ROW_NUMBER", "STD", "STDDEV",
		"STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP", "VARIANCE",
		"CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "LOCALTIME", "CURDATE",
		"CURTIME", "DATE_ADD", "DATE_SUB", "EXTRACT", "LOCALTIMESTAMP", "NOW",
		"POSITION", "SUBSTR", "SUBSTRING", "SYSDATE", "TRIM", "UTC_DATE", "UTC_TIME",
		"UTC_TIMESTAMP", "ACCOUNT", "ACTION", "AFTER", "AGGREGATE", "ALGORITHM",
		"ANY", "AT", "AUTHORS", "AUTOCOMMIT", "AUTOEXTEND_SIZE", "AUTO_INCREMENT",
		"AVG_ROW_LENGTH", "BEGIN", "BINLOG", "BIT", "BLOCK", "BOOL", "BOOLEAN",
		"BTREE", "CACHE", "CASCADED", "CHAIN", "CHANGED", "CHANNEL", "CHECKSUM",
		"PAGE_CHECKSUM", "CIPHER", "CLASS_ORIGIN", "CLIENT", "CLOSE", "CLUSTERING",
		"COALESCE", "CODE", "COLUMNS", "COLUMN_FORMAT", "COLUMN_NAME", "COMMENT",
		"COMMIT", "COMPACT", "COMPLETION", "COMPRESSED", "COMPRESSION", "CONCURRENT",
		"CONNECT", "CONNECTION", "CONSISTENT", "CONSTRAINT_CATALOG", "CONSTRAINT_SCHEMA",
		"CONSTRAINT_NAME", "CONTAINS", "CONTEXT", "CONTRIBUTORS", "COPY", "CPU",
		"CYCLE", "CURSOR_NAME", "DATA", "DATAFILE", "DEALLOCATE", "DEFAULT_AUTH",
		"DEFINER", "DELAY_KEY_WRITE", "DES_KEY_FILE", "DIRECTORY", "DISABLE",
		"DISCARD", "DISK", "DO", "DUMPFILE", "DUPLICATE", "DYNAMIC", "ENABLE",
		"ENCRYPTION", "END", "ENDS", "ENGINE", "ENGINES", "ERROR", "ERRORS",
		"ESCAPE", "EVEN", "EVENT", "EVENTS", "EVERY", "EXCHANGE", "EXCLUSIVE",
		"EXPIRE", "EXPORT", "EXTENDED", "EXTENT_SIZE", "FAST", "FAULTS", "FIELDS",
		"FILE_BLOCK_SIZE", "FILTER", "FIRST", "FIXED", "FLUSH", "FOLLOWING",
		"FOLLOWS", "FOUND", "FULL", "FUNCTION", "GENERAL", "GLOBAL", "GRANTS",
		"GROUP_REPLICATION", "HANDLER", "HASH", "HELP", "HOST", "HOSTS", "IDENTIFIED",
		"IGNORE_SERVER_IDS", "IMPORT", "INCREMENT", "INDEXES", "INITIAL_SIZE",
		"INPLACE", "INSERT_METHOD", "INSTALL", "INSTANCE", "INSTANT", "INVISIBLE",
		"INVOKER", "IO", "IO_THREAD", "IPC", "ISOLATION", "ISSUER", "JSON",
		"KEY_BLOCK_SIZE", "LANGUAGE", "LAST", "LEAVES", "LESS", "LEVEL", "LIST",
		"LOCAL", "LOGFILE", "LOGS", "MASTER", "MASTER_AUTO_POSITION", "MASTER_CONNECT_RETRY",
		"MASTER_DELAY", "MASTER_HEARTBEAT_PERIOD", "MASTER_HOST", "MASTER_LOG_FILE",
		"MASTER_LOG_POS", "MASTER_PASSWORD", "MASTER_PORT", "MASTER_RETRY_COUNT",
		"MASTER_SSL", "MASTER_SSL_CA", "MASTER_SSL_CAPATH", "MASTER_SSL_CERT",
		"MASTER_SSL_CIPHER", "MASTER_SSL_CRL", "MASTER_SSL_CRLPATH", "MASTER_SSL_KEY",
		"MASTER_TLS_VERSION", "MASTER_USER", "MAX_CONNECTIONS_PER_HOUR", "MAX_QUERIES_PER_HOUR",
		"MAX_ROWS", "MAX_SIZE", "MAX_UPDATES_PER_HOUR", "MAX_USER_CONNECTIONS",
		"MEDIUM", "MEMBER", "MERGE", "MESSAGE_TEXT", "MID", "MIGRATE", "MIN_ROWS",
		"MODE", "MODIFY", "MUTEX", "MYSQL", "MYSQL_ERRNO", "NAME", "NAMES",
		"NCHAR", "NEVER", "NEXT", "NO", "NOCACHE", "NOCOPY", "NOCYCLE", "NOMAXVALUE",
		"NOMINVALUE", "NOWAIT", "NODEGROUP", "NONE", "ODBC", "OFFLINE", "OFFSET",
		"OF", "OJ", "OLD_PASSWORD", "ONE", "ONLINE", "ONLY", "OPEN", "OPTIMIZER_COSTS",
		"OPTIONS", "OWNER", "PACK_KEYS", "PAGE", "PARSER", "PARTIAL", "PARTITIONING",
		"PARTITIONS", "PASSWORD", "PHASE", "PLUGIN", "PLUGIN_DIR", "PLUGINS",
		"PORT", "PRECEDES", "PRECEDING", "PREPARE", "PRESERVE", "PREV", "PROCESSLIST",
		"PROFILE", "PROFILES", "PROXY", "QUERY", "QUICK", "REBUILD", "RECOVER",
		"RECURSIVE", "REDO_BUFFER_SIZE", "REDUNDANT", "RELAY", "RELAY_LOG_FILE",
		"RELAY_LOG_POS", "RELAYLOG", "REMOVE", "REORGANIZE", "REPAIR", "REPLICATE_DO_DB",
		"REPLICATE_DO_TABLE", "REPLICATE_IGNORE_DB", "REPLICATE_IGNORE_TABLE",
		"REPLICATE_REWRITE_DB", "REPLICATE_WILD_DO_TABLE", "REPLICATE_WILD_IGNORE_TABLE",
		"REPLICATION", "RESET", "RESTART", "RESUME", "RETURNED_SQLSTATE", "RETURNING",
		"RETURNS", "ROLE", "ROLLBACK", "ROLLUP", "ROTATE", "ROW", "ROWS", "ROW_FORMAT",
		"RTREE", "SAVEPOINT", "SCHEDULE", "SECURITY", "SEQUENCE", "SERVER",
		"SESSION", "SHARE", "SHARED", "SIGNED", "SIMPLE", "SLAVE", "SLOW", "SNAPSHOT",
		"SOCKET", "SOME", "SONAME", "SOUNDS", "SOURCE", "SQL_AFTER_GTIDS", "SQL_AFTER_MTS_GAPS",
		"SQL_BEFORE_GTIDS", "SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_NO_CACHE",
		"SQL_THREAD", "START", "STARTS", "STATS_AUTO_RECALC", "STATS_PERSISTENT",
		"STATS_SAMPLE_PAGES", "STATUS", "STOP", "STORAGE", "STORED", "STRING",
		"SUBCLASS_ORIGIN", "SUBJECT", "SUBPARTITION", "SUBPARTITIONS", "SUSPEND",
		"SWAPS", "SWITCHES", "TABLE_NAME", "TABLESPACE", "TABLE_TYPE", "TEMPORARY",
		"TEMPTABLE", "THAN", "TRADITIONAL", "TRANSACTION", "TRANSACTIONAL",
		"TRIGGERS", "TRUNCATE", "UNBOUNDED", "UNDEFINED", "UNDOFILE", "UNDO_BUFFER_SIZE",
		"UNINSTALL", "UNKNOWN", "UNTIL", "UPGRADE", "USER", "USE_FRM", "USER_RESOURCES",
		"VALIDATION", "VALUE", "VARIABLES", "VIEW", "VIRTUAL", "VISIBLE", "WAIT",
		"WARNINGS", "WINDOW", "WITHOUT", "WORK", "WRAPPER", "X509", "XA", "XML",
		"YES", "EUR", "USA", "JIS", "ISO", "INTERNAL", "QUARTER", "MONTH", "DAY",
		"HOUR", "MINUTE", "WEEK", "SECOND", "MICROSECOND", "TABLES", "ROUTINE",
		"EXECUTE", "FILE", "PROCESS", "RELOAD", "SHUTDOWN", "SUPER", "PRIVILEGES",
		"APPLICATION_PASSWORD_ADMIN", "AUDIT_ADMIN", "BACKUP_ADMIN", "BINLOG_ADMIN",
		"BINLOG_ENCRYPTION_ADMIN", "CLONE_ADMIN", "CONNECTION_ADMIN", "ENCRYPTION_KEY_ADMIN",
		"FIREWALL_ADMIN", "FIREWALL_USER", "FLUSH_OPTIMIZER_COSTS", "FLUSH_STATUS",
		"FLUSH_TABLES", "FLUSH_USER_RESOURCES", "ADMIN", "GROUP_REPLICATION_ADMIN",
		"INNODB_REDO_LOG_ARCHIVE", "INNODB_REDO_LOG_ENABLE", "INVOKE", "LAMBDA",
		"NDB_STORED_USER", "PASSWORDLESS_USER_ADMIN", "PERSIST_RO_VARIABLES_ADMIN",
		"REPLICATION_APPLIER", "REPLICATION_SLAVE_ADMIN", "RESOURCE_GROUP_ADMIN",
		"RESOURCE_GROUP_USER", "ROLE_ADMIN", "S3", "SERVICE_CONNECTION_ADMIN",
		"SESSION_VARIABLES_ADMIN", "SET_USER_ID", "SHOW_ROUTINE", "SYSTEM_VARIABLES_ADMIN",
		"TABLE_ENCRYPTION_ADMIN", "VERSION_TOKEN_ADMIN", "XA_RECOVER_ADMIN",
		"ARMSCII8", "ASCII", "BIG5", "CP1250", "CP1251", "CP1256", "CP1257",
		"CP850", "CP852", "CP866", "CP932", "DEC8", "EUCJPMS", "EUCKR", "GB18030",
		"GB2312", "GBK", "GEOSTD8", "GREEK", "HEBREW", "HP8", "KEYBCS2", "KOI8R",
		"KOI8U", "LATIN1", "LATIN2", "LATIN5", "LATIN7", "MACCE", "MACROMAN",
		"SJIS", "SWE7", "TIS620", "UCS2", "UJIS", "UTF16", "UTF16LE", "UTF32",
		"UTF8", "UTF8MB3", "UTF8MB4", "ARCHIVE", "BLACKHOLE", "CSV", "FEDERATED",
		"INNODB", "MEMORY", "MRG_MYISAM", "MYISAM", "NDB", "NDBCLUSTER", "PERFORMANCE_SCHEMA",
		"TOKUDB", "REPEATABLE", "COMMITTED", "UNCOMMITTED", "SERIALIZABLE",
		"GEOMETRYCOLLECTION", "GEOMCOLLECTION", "GEOMETRY", "LINESTRING", "MULTILINESTRING",
		"MULTIPOINT", "MULTIPOLYGON", "POINT", "POLYGON", "ABS", "ACOS", "ADDDATE",
		"ADDTIME", "AES_DECRYPT", "AES_ENCRYPT", "AREA", "ASBINARY", "ASIN",
		"ASTEXT", "ASWKB", "ASWKT", "ASYMMETRIC_DECRYPT", "ASYMMETRIC_DERIVE",
		"ASYMMETRIC_ENCRYPT", "ASYMMETRIC_SIGN", "ASYMMETRIC_VERIFY", "ATAN",
		"ATAN2", "BENCHMARK", "BIN", "BIT_COUNT", "BIT_LENGTH", "BUFFER", "CATALOG_NAME",
		"CEIL", "CEILING", "CENTROID", "CHARACTER_LENGTH", "CHARSET", "CHAR_LENGTH",
		"COERCIBILITY", "COLLATION", "COMPRESS", "CONCAT", "CONCAT_WS", "CONNECTION_ID",
		"CONV", "CONVERT_TZ", "COS", "COT", "CRC32", "CREATE_ASYMMETRIC_PRIV_KEY",
		"CREATE_ASYMMETRIC_PUB_KEY", "CREATE_DH_PARAMETERS", "CREATE_DIGEST",
		"CROSSES", "DATEDIFF", "DATE_FORMAT", "DAYNAME", "DAYOFMONTH", "DAYOFWEEK",
		"DAYOFYEAR", "DECODE", "DEGREES", "DES_DECRYPT", "DES_ENCRYPT", "DIMENSION",
		"DISJOINT", "ELT", "ENCODE", "ENCRYPT", "ENDPOINT", "ENGINE_ATTRIBUTE",
		"ENVELOPE", "EQUALS", "EXP", "EXPORT_SET", "EXTERIORRING", "EXTRACTVALUE",
		"FIELD", "FIND_IN_SET", "FLOOR", "FORMAT", "FOUND_ROWS", "FROM_BASE64",
		"FROM_DAYS", "FROM_UNIXTIME", "GEOMCOLLFROMTEXT", "GEOMCOLLFROMWKB",
		"GEOMETRYCOLLECTIONFROMTEXT", "GEOMETRYCOLLECTIONFROMWKB", "GEOMETRYFROMTEXT",
		"GEOMETRYFROMWKB", "GEOMETRYN", "GEOMETRYTYPE", "GEOMFROMTEXT", "GEOMFROMWKB",
		"GET_FORMAT", "GET_LOCK", "GLENGTH", "GREATEST", "GTID_SUBSET", "GTID_SUBTRACT",
		"HEX", "IFNULL", "INET6_ATON", "INET6_NTOA", "INET_ATON", "INET_NTOA",
		"INSTR", "INTERIORRINGN", "INTERSECTS", "ISCLOSED", "ISEMPTY", "ISNULL",
		"ISSIMPLE", "IS_FREE_LOCK", "IS_IPV4", "IS_IPV4_COMPAT", "IS_IPV4_MAPPED",
		"IS_IPV6", "IS_USED_LOCK", "LAST_INSERT_ID", "LCASE", "LEAST", "LENGTH",
		"LINEFROMTEXT", "LINEFROMWKB", "LINESTRINGFROMTEXT", "LINESTRINGFROMWKB",
		"LN", "LOAD_FILE", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD",
		"LTRIM", "MAKEDATE", "MAKETIME", "MAKE_SET", "MASTER_POS_WAIT", "MBRCONTAINS",
		"MBRDISJOINT", "MBREQUAL", "MBRINTERSECTS", "MBROVERLAPS", "MBRTOUCHES",
		"MBRWITHIN", "MD5", "MLINEFROMTEXT", "MLINEFROMWKB", "MONTHNAME", "MPOINTFROMTEXT",
		"MPOINTFROMWKB", "MPOLYFROMTEXT", "MPOLYFROMWKB", "MULTILINESTRINGFROMTEXT",
		"MULTILINESTRINGFROMWKB", "MULTIPOINTFROMTEXT", "MULTIPOINTFROMWKB",
		"MULTIPOLYGONFROMTEXT", "MULTIPOLYGONFROMWKB", "NAME_CONST", "NULLIF",
		"NUMGEOMETRIES", "NUMINTERIORRINGS", "NUMPOINTS", "OCT", "OCTET_LENGTH",
		"ORD", "OVERLAPS", "PERIOD_ADD", "PERIOD_DIFF", "PI", "POINTFROMTEXT",
		"POINTFROMWKB", "POINTN", "POLYFROMTEXT", "POLYFROMWKB", "POLYGONFROMTEXT",
		"POLYGONFROMWKB", "POW", "POWER", "QUOTE", "RADIANS", "RAND", "RANDOM_BYTES",
		"RELEASE_LOCK", "REVERSE", "ROUND", "ROW_COUNT", "RPAD", "RTRIM", "SEC_TO_TIME",
		"SECONDARY_ENGINE_ATTRIBUTE", "SESSION_USER", "SHA", "SHA1", "SHA2",
		"SCHEMA_NAME", "SIGN", "SIN", "SLEEP", "SOUNDEX", "SQL_THREAD_WAIT_AFTER_GTIDS",
		"SQRT", "SRID", "STARTPOINT", "STRCMP", "STR_TO_DATE", "ST_AREA", "ST_ASBINARY",
		"ST_ASTEXT", "ST_ASWKB", "ST_ASWKT", "ST_BUFFER", "ST_CENTROID", "ST_CONTAINS",
		"ST_CROSSES", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE",
		"ST_ENDPOINT", "ST_ENVELOPE", "ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMCOLLFROMTEXT",
		"ST_GEOMCOLLFROMTXT", "ST_GEOMCOLLFROMWKB", "ST_GEOMETRYCOLLECTIONFROMTEXT",
		"ST_GEOMETRYCOLLECTIONFROMWKB", "ST_GEOMETRYFROMTEXT", "ST_GEOMETRYFROMWKB",
		"ST_GEOMETRYN", "ST_GEOMETRYTYPE", "ST_GEOMFROMTEXT", "ST_GEOMFROMWKB",
		"ST_INTERIORRINGN", "ST_INTERSECTION", "ST_INTERSECTS", "ST_ISCLOSED",
		"ST_ISEMPTY", "ST_ISSIMPLE", "ST_LINEFROMTEXT", "ST_LINEFROMWKB", "ST_LINESTRINGFROMTEXT",
		"ST_LINESTRINGFROMWKB", "ST_NUMGEOMETRIES", "ST_NUMINTERIORRING", "ST_NUMINTERIORRINGS",
		"ST_NUMPOINTS", "ST_OVERLAPS", "ST_POINTFROMTEXT", "ST_POINTFROMWKB",
		"ST_POINTN", "ST_POLYFROMTEXT", "ST_POLYFROMWKB", "ST_POLYGONFROMTEXT",
		"ST_POLYGONFROMWKB", "ST_SRID", "ST_STARTPOINT", "ST_SYMDIFFERENCE",
		"ST_TOUCHES", "ST_UNION", "ST_WITHIN", "ST_X", "ST_Y", "SUBDATE", "SUBSTRING_INDEX",
		"SUBTIME", "SYSTEM_USER", "TAN", "TIMEDIFF", "TIMESTAMPADD", "TIMESTAMPDIFF",
		"TIME_FORMAT", "TIME_TO_SEC", "TOUCHES", "TO_BASE64", "TO_DAYS", "TO_SECONDS",
		"UCASE", "UNCOMPRESS", "UNCOMPRESSED_LENGTH", "UNHEX", "UNIX_TIMESTAMP",
		"UPDATEXML", "UPPER", "UUID", "UUID_SHORT", "VALIDATE_PASSWORD_STRENGTH",
		"VERSION", "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS", "WEEKDAY", "WEEKOFYEAR",
		"WEIGHT_STRING", "WITHIN", "YEARWEEK", "Y_FUNCTION", "X_FUNCTION", "VIA",
		"LASTVAL", "NEXTVAL", "SETVAL", "PREVIOUS", "PERSISTENT", "BINLOG_MONITOR",
		"BINLOG_REPLAY", "FEDERATED_ADMIN", "READ_ONLY_ADMIN", "REPLICA", "REPLICATION_MASTER_ADMIN",
		"VAR_ASSIGN", "PLUS_ASSIGN", "MINUS_ASSIGN", "MULT_ASSIGN", "DIV_ASSIGN",
		"MOD_ASSIGN", "AND_ASSIGN", "XOR_ASSIGN", "OR_ASSIGN", "STAR", "DIVIDE",
		"MODULE", "PLUS", "MINUS", "DIV", "MOD", "EQUAL_SYMBOL", "GREATER_SYMBOL",
		"LESS_SYMBOL", "EXCLAMATION_SYMBOL", "BIT_NOT_OP", "BIT_OR_OP", "BIT_AND_OP",
		"BIT_XOR_OP", "DOT", "LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", "AT_SIGN",
		"ZERO_DECIMAL", "ONE_DECIMAL", "TWO_DECIMAL", "SINGLE_QUOTE_SYMB", "DOUBLE_QUOTE_SYMB",
		"REVERSE_QUOTE_SYMB", "COLON_SYMB", "CHARSET_REVERSE_QOUTE_STRING",
		"FILESIZE_LITERAL", "START_NATIONAL_STRING_LITERAL", "STRING_LITERAL",
		"DECIMAL_LITERAL", "HEXADECIMAL_LITERAL", "REAL_LITERAL", "NULL_SPEC_LITERAL",
		"BIT_STRING", "STRING_CHARSET_NAME", "DOT_ID", "ID", "REVERSE_QUOTE_ID",
		"STRING_USER_NAME", "IP_ADDRESS", "STRING_USER_NAME_MARIADB", "LOCAL_ID",
		"GLOBAL_ID", "ERROR_RECONGNIGION",
	}
	staticData.RuleNames = []string{
		"prog", "sqlStatement", "charSet", "intervalType", "indexType", "indexOption",
		"createDefinitions", "createDefinition", "columnDefinition", "columnConstraint",
		"tableConstraint", "referenceDefinition", "referenceAction", "referenceControlType",
		"indexColumnDefinition", "tableOption", "tableType", "tablespaceStorage",
		"partitionDefinitions", "partitionFunctionDefinition", "subpartitionFunctionDefinition",
		"partitionDefinition", "partitionDefinerAtom", "partitionDefinerVector",
		"subpartitionDefinition", "partitionOption", "fullId", "tableName",
		"fullColumnName", "indexColumnName", "mysqlVariable", "charsetName",
		"collationName", "engineName", "uid", "simpleId", "dottedId", "decimalLiteral",
		"fileSizeLiteral", "stringLiteral", "booleanLiteral", "hexadecimalLiteral",
		"nullNotnull", "constant", "dataType", "collectionOptions", "convertedDataType",
		"lengthOneDimension", "lengthTwoDimension", "lengthTwoOptionalDimension",
		"uidList", "tables", "indexColumnNames", "defaultValue", "currentTimestamp",
		"ifNotExists", "scalarFunctionName", "expression", "predicate", "expressionAtom",
		"unaryOperator", "comparisonOperator", "logicalOperator", "bitOperator",
		"mathOperator", "jsonOperator", "charsetNameBase", "transactionLevelBase",
		"privilegesBase", "intervalTypeBase", "dataTypeBase", "keywordsCanBeId",
		"functionNameBase",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 1153, 1577, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 1, 0,
		1, 0, 3, 0, 149, 8, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 3, 1, 156, 8, 1, 1,
		1, 3, 1, 159, 8, 1, 1, 1, 1, 1, 3, 1, 163, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		3, 1, 169, 8, 1, 1, 1, 5, 1, 172, 8, 1, 10, 1, 12, 1, 175, 9, 1, 3, 1,
		177, 8, 1, 1, 1, 3, 1, 180, 8, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 187,
		8, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 3, 3, 202, 8, 3, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 3, 5, 209, 8,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 221,
		8, 5, 1, 5, 1, 5, 1, 5, 3, 5, 226, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 3, 5, 235, 8, 5, 3, 5, 237, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 5,
		6, 243, 8, 6, 10, 6, 12, 6, 246, 9, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1,
		7, 1, 7, 3, 7, 255, 8, 7, 1, 8, 1, 8, 5, 8, 259, 8, 8, 10, 8, 12, 8, 262,
		9, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 273,
		8, 9, 1, 9, 3, 9, 276, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 281, 8, 9, 1, 9, 1,
		9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 294, 8,
		9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 301, 8, 9, 1, 9, 1, 9, 1, 9, 1,
		9, 1, 9, 3, 9, 308, 8, 9, 3, 9, 310, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		3, 9, 317, 8, 9, 1, 10, 1, 10, 3, 10, 321, 8, 10, 3, 10, 323, 8, 10, 1,
		10, 1, 10, 1, 10, 3, 10, 328, 8, 10, 1, 10, 3, 10, 331, 8, 10, 1, 10, 1,
		10, 5, 10, 335, 8, 10, 10, 10, 12, 10, 338, 9, 10, 1, 10, 1, 10, 3, 10,
		342, 8, 10, 3, 10, 344, 8, 10, 1, 10, 1, 10, 3, 10, 348, 8, 10, 1, 10,
		3, 10, 351, 8, 10, 1, 10, 3, 10, 354, 8, 10, 1, 10, 1, 10, 5, 10, 358,
		8, 10, 10, 10, 12, 10, 361, 9, 10, 1, 10, 1, 10, 3, 10, 365, 8, 10, 3,
		10, 367, 8, 10, 1, 10, 1, 10, 1, 10, 3, 10, 372, 8, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 3, 10, 379, 8, 10, 3, 10, 381, 8, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 3, 10, 388, 8, 10, 1, 11, 1, 11, 1, 11, 3, 11, 393, 8,
		11, 1, 11, 1, 11, 3, 11, 397, 8, 11, 1, 11, 3, 11, 400, 8, 11, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 408, 8, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 3, 12, 416, 8, 12, 3, 12, 418, 8, 12, 1, 13, 1, 13,
		1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 426, 8, 13, 1, 14, 1, 14, 3, 14, 430,
		8, 14, 1, 14, 3, 14, 433, 8, 14, 1, 14, 1, 14, 5, 14, 437, 8, 14, 10, 14,
		12, 14, 440, 9, 14, 1, 14, 1, 14, 3, 14, 444, 8, 14, 1, 14, 3, 14, 447,
		8, 14, 1, 14, 1, 14, 5, 14, 451, 8, 14, 10, 14, 12, 14, 454, 9, 14, 3,
		14, 456, 8, 14, 1, 15, 1, 15, 3, 15, 460, 8, 15, 1, 15, 3, 15, 463, 8,
		15, 1, 15, 1, 15, 3, 15, 467, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 472, 8,
		15, 1, 15, 1, 15, 1, 15, 3, 15, 477, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15,
		482, 8, 15, 1, 15, 1, 15, 3, 15, 486, 8, 15, 1, 15, 1, 15, 3, 15, 490,
		8, 15, 1, 15, 1, 15, 3, 15, 494, 8, 15, 1, 15, 1, 15, 3, 15, 498, 8, 15,
		1, 15, 1, 15, 3, 15, 502, 8, 15, 1, 15, 1, 15, 3, 15, 506, 8, 15, 1, 15,
		1, 15, 1, 15, 3, 15, 511, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 516, 8, 15,
		1, 15, 1, 15, 1, 15, 3, 15, 521, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3,
		15, 527, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 532, 8, 15, 1, 15, 1, 15, 1,
		15, 3, 15, 537, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 543, 8, 15, 1,
		15, 1, 15, 1, 15, 3, 15, 548, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 553, 8,
		15, 1, 15, 1, 15, 1, 15, 3, 15, 558, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15,
		563, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 568, 8, 15, 1, 15, 1, 15, 1, 15,
		3, 15, 573, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 578, 8, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 3, 15, 585, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 590,
		8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 595, 8, 15, 1, 15, 1, 15, 1, 15, 3,
		15, 600, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 606, 8, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 614, 8, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 3, 15, 620, 8, 15, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 18, 1,
		18, 1, 18, 1, 18, 1, 18, 3, 18, 632, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18,
		1, 18, 3, 18, 639, 8, 18, 3, 18, 641, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18,
		5, 18, 647, 8, 18, 10, 18, 12, 18, 650, 9, 18, 1, 18, 1, 18, 3, 18, 654,
		8, 18, 1, 19, 3, 19, 657, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 3, 19, 665, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 671, 8, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19,
		1, 19, 1, 19, 1, 19, 3, 19, 687, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 699, 8, 19, 3, 19, 701, 8,
		19, 1, 20, 3, 20, 704, 8, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20,
		3, 20, 712, 8, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 718, 8, 20, 1, 20,
		1, 20, 1, 20, 1, 20, 3, 20, 724, 8, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1,
		21, 1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 735, 8, 21, 10, 21, 12, 21, 738,
		9, 21, 1, 21, 1, 21, 5, 21, 742, 8, 21, 10, 21, 12, 21, 745, 9, 21, 1,
		21, 1, 21, 1, 21, 1, 21, 5, 21, 751, 8, 21, 10, 21, 12, 21, 754, 9, 21,
		1, 21, 1, 21, 3, 21, 758, 8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1,
		21, 1, 21, 5, 21, 767, 8, 21, 10, 21, 12, 21, 770, 9, 21, 1, 21, 1, 21,
		1, 21, 1, 21, 5, 21, 776, 8, 21, 10, 21, 12, 21, 779, 9, 21, 1, 21, 1,
		21, 3, 21, 783, 8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21,
		1, 21, 5, 21, 793, 8, 21, 10, 21, 12, 21, 796, 9, 21, 1, 21, 1, 21, 5,
		21, 800, 8, 21, 10, 21, 12, 21, 803, 9, 21, 1, 21, 1, 21, 1, 21, 1, 21,
		5, 21, 809, 8, 21, 10, 21, 12, 21, 812, 9, 21, 1, 21, 1, 21, 3, 21, 816,
		8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 826,
		8, 21, 10, 21, 12, 21, 829, 9, 21, 1, 21, 1, 21, 5, 21, 833, 8, 21, 10,
		21, 12, 21, 836, 9, 21, 1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 842, 8, 21,
		10, 21, 12, 21, 845, 9, 21, 1, 21, 1, 21, 3, 21, 849, 8, 21, 1, 21, 1,
		21, 1, 21, 5, 21, 854, 8, 21, 10, 21, 12, 21, 857, 9, 21, 1, 21, 1, 21,
		1, 21, 1, 21, 5, 21, 863, 8, 21, 10, 21, 12, 21, 866, 9, 21, 1, 21, 1,
		21, 3, 21, 870, 8, 21, 3, 21, 872, 8, 21, 1, 22, 1, 22, 1, 22, 3, 22, 877,
		8, 22, 1, 23, 1, 23, 1, 23, 1, 23, 4, 23, 883, 8, 23, 11, 23, 12, 23, 884,
		1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 5, 24, 892, 8, 24, 10, 24, 12, 24, 895,
		9, 24, 1, 25, 3, 25, 898, 8, 25, 1, 25, 3, 25, 901, 8, 25, 1, 25, 1, 25,
		3, 25, 905, 8, 25, 1, 25, 1, 25, 1, 25, 3, 25, 910, 8, 25, 1, 25, 1, 25,
		1, 25, 1, 25, 3, 25, 916, 8, 25, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 922,
		8, 25, 1, 25, 1, 25, 1, 25, 3, 25, 927, 8, 25, 1, 25, 1, 25, 1, 25, 3,
		25, 932, 8, 25, 1, 25, 1, 25, 1, 25, 3, 25, 937, 8, 25, 1, 25, 1, 25, 1,
		25, 3, 25, 942, 8, 25, 1, 25, 3, 25, 945, 8, 25, 1, 26, 1, 26, 1, 26, 1,
		26, 3, 26, 951, 8, 26, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 3, 28, 958, 8,
		28, 3, 28, 960, 8, 28, 1, 28, 1, 28, 1, 28, 3, 28, 965, 8, 28, 3, 28, 967,
		8, 28, 1, 29, 1, 29, 3, 29, 971, 8, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3,
		29, 977, 8, 29, 1, 29, 3, 29, 980, 8, 29, 1, 29, 3, 29, 983, 8, 29, 1,
		30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 991, 8, 31, 1, 32, 1, 32,
		3, 32, 995, 8, 32, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 3, 34, 1002, 8, 34,
		1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 1013,
		8, 35, 1, 36, 1, 36, 1, 36, 3, 36, 1018, 8, 36, 1, 37, 1, 37, 1, 38, 1,
		38, 3, 38, 1024, 8, 38, 1, 39, 3, 39, 1027, 8, 39, 1, 39, 1, 39, 3, 39,
		1031, 8, 39, 1, 39, 4, 39, 1034, 8, 39, 11, 39, 12, 39, 1035, 1, 39, 3,
		39, 1039, 8, 39, 1, 39, 1, 39, 3, 39, 1043, 8, 39, 1, 39, 1, 39, 3, 39,
		1047, 8, 39, 3, 39, 1049, 8, 39, 1, 40, 1, 40, 1, 41, 3, 41, 1054, 8, 41,
		1, 41, 1, 41, 1, 42, 3, 42, 1059, 8, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 1072, 8, 43, 1, 43,
		3, 43, 1075, 8, 43, 1, 44, 1, 44, 3, 44, 1079, 8, 44, 1, 44, 5, 44, 1082,
		8, 44, 10, 44, 12, 44, 1085, 9, 44, 1, 44, 1, 44, 3, 44, 1089, 8, 44, 1,
		44, 5, 44, 1092, 8, 44, 10, 44, 12, 44, 1095, 9, 44, 1, 44, 1, 44, 3, 44,
		1099, 8, 44, 1, 44, 3, 44, 1102, 8, 44, 1, 44, 5, 44, 1105, 8, 44, 10,
		44, 12, 44, 1108, 9, 44, 1, 44, 1, 44, 3, 44, 1112, 8, 44, 1, 44, 5, 44,
		1115, 8, 44, 10, 44, 12, 44, 1118, 9, 44, 1, 44, 1, 44, 3, 44, 1122, 8,
		44, 1, 44, 1, 44, 1, 44, 3, 44, 1127, 8, 44, 1, 44, 3, 44, 1130, 8, 44,
		1, 44, 3, 44, 1133, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1138, 8, 44, 1,
		44, 1, 44, 1, 44, 3, 44, 1143, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1148,
		8, 44, 1, 44, 3, 44, 1151, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1156, 8,
		44, 1, 44, 3, 44, 1159, 8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1165,
		8, 44, 1, 44, 3, 44, 1168, 8, 44, 1, 44, 1, 44, 3, 44, 1172, 8, 44, 1,
		44, 3, 44, 1175, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1180, 8, 44, 1, 44,
		1, 44, 3, 44, 1184, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1189, 8, 44, 1,
		44, 1, 44, 1, 44, 3, 44, 1194, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1199,
		8, 44, 1, 44, 1, 44, 3, 44, 1203, 8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3,
		44, 1209, 8, 44, 1, 44, 3, 44, 1212, 8, 44, 1, 45, 1, 45, 1, 45, 1, 45,
		5, 45, 1218, 8, 45, 10, 45, 12, 45, 1221, 9, 45, 1, 45, 1, 45, 1, 46, 1,
		46, 3, 46, 1227, 8, 46, 1, 46, 1, 46, 3, 46, 1231, 8, 46, 1, 46, 1, 46,
		1, 46, 3, 46, 1236, 8, 46, 1, 46, 1, 46, 1, 46, 3, 46, 1241, 8, 46, 1,
		46, 1, 46, 3, 46, 1245, 8, 46, 3, 46, 1247, 8, 46, 1, 46, 3, 46, 1250,
		8, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1,
		48, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 1266, 8, 49, 1, 49, 1, 49, 1, 50,
		1, 50, 1, 50, 5, 50, 1273, 8, 50, 10, 50, 12, 50, 1276, 9, 50, 1, 51, 1,
		51, 1, 51, 5, 51, 1281, 8, 51, 10, 51, 12, 51, 1284, 9, 51, 1, 52, 1, 52,
		1, 52, 1, 52, 5, 52, 1290, 8, 52, 10, 52, 12, 52, 1293, 9, 52, 1, 52, 1,
		52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53,
		1306, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1313, 8, 53, 1,
		53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53,
		1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1,
		53, 3, 53, 1337, 8, 53, 1, 54, 1, 54, 1, 54, 3, 54, 1342, 8, 54, 1, 54,
		3, 54, 1345, 8, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1350, 8, 54, 1, 54, 3,
		54, 1353, 8, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1,
		56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 1382,
		8, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 1390, 8, 57, 1,
		57, 1, 57, 1, 57, 3, 57, 1395, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 5, 57,
		1401, 8, 57, 10, 57, 12, 57, 1404, 9, 57, 1, 58, 1, 58, 1, 58, 3, 58, 1409,
		8, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 1419,
		8, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1,
		58, 1, 58, 3, 58, 1432, 8, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58,
		1, 58, 3, 58, 1441, 8, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 1447, 8,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 5, 58, 1456, 8, 58,
		10, 58, 12, 58, 1459, 9, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59,
		1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 1474, 8, 59, 10,
		59, 12, 59, 1477, 9, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59,
		4, 59, 1486, 8, 59, 11, 59, 12, 59, 1487, 1, 59, 1, 59, 1, 59, 1, 59, 1,
		59, 1, 59, 3, 59, 1496, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59,
		1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 1513,
		8, 59, 10, 59, 12, 59, 1516, 9, 59, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61,
		1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1,
		61, 3, 61, 1534, 8, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62,
		3, 62, 1543, 8, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3,
		63, 1552, 8, 63, 1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65,
		1561, 8, 65, 1, 66, 1, 66, 1, 67, 1, 67, 1, 68, 1, 68, 1, 69, 1, 69, 1,
		70, 1, 70, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 0, 3, 114, 116, 118, 73,
		0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36,
		38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72,
		74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106,
		108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136,
		138, 140, 142, 144, 0, 56, 3, 0, 341, 341, 431, 431, 586, 586, 2, 0, 446,
		446, 656, 656, 2, 0, 508, 508, 666, 666, 3, 0, 40, 40, 393, 393, 419, 419,
		3, 0, 40, 40, 389, 389, 772, 772, 2, 0, 620, 620, 655, 655, 2, 0, 78, 78,
		88, 88, 3, 0, 424, 424, 533, 533, 596, 596, 2, 0, 66, 66, 154, 154, 1,
		0, 347, 348, 1, 0, 1128, 1129, 2, 0, 1138, 1138, 1146, 1146, 2, 0, 78,
		78, 379, 379, 3, 0, 418, 418, 456, 456, 508, 508, 2, 0, 40, 40, 1128, 1129,
		7, 0, 40, 40, 361, 361, 363, 363, 393, 393, 419, 419, 557, 557, 1146, 1146,
		2, 0, 40, 40, 1139, 1139, 2, 0, 501, 501, 517, 517, 1, 0, 1129, 1130, 2,
		0, 13, 13, 43, 43, 1, 0, 1151, 1152, 4, 0, 366, 366, 767, 778, 1138, 1138,
		1146, 1147, 3, 0, 1128, 1130, 1139, 1139, 1141, 1141, 2, 0, 60, 60, 172,
		172, 2, 0, 112, 112, 1142, 1142, 1, 0, 190, 201, 3, 0, 177, 177, 189, 189,
		595, 595, 2, 0, 205, 210, 419, 419, 1, 0, 212, 214, 5, 0, 24, 24, 216,
		218, 225, 225, 227, 230, 505, 505, 2, 0, 24, 24, 217, 217, 2, 0, 24, 24,
		216, 216, 2, 0, 149, 149, 231, 231, 2, 0, 220, 221, 223, 223, 3, 0, 222,
		222, 224, 224, 226, 226, 2, 0, 233, 233, 339, 340, 2, 0, 215, 215, 337,
		337, 1, 0, 783, 791, 2, 0, 220, 220, 505, 505, 5, 0, 194, 194, 200, 200,
		211, 212, 214, 214, 453, 453, 2, 0, 177, 177, 595, 595, 1, 0, 1087, 1088,
		2, 0, 507, 507, 1090, 1090, 2, 0, 306, 309, 313, 313, 2, 0, 110, 110, 1117,
		1117, 3, 0, 60, 60, 172, 172, 645, 645, 2, 0, 133, 133, 145, 145, 3, 0,
		110, 110, 1110, 1111, 1117, 1118, 1, 0, 1107, 1113, 2, 0, 220, 220, 726,
		766, 1, 0, 779, 782, 1, 0, 680, 688, 1, 0, 672, 679, 3, 0, 211, 215, 228,
		228, 231, 231, 40, 0, 17, 17, 34, 34, 40, 40, 46, 46, 56, 56, 70, 70, 76,
		76, 100, 100, 106, 107, 113, 113, 117, 117, 120, 120, 126, 126, 153, 153,
		163, 163, 233, 233, 277, 281, 285, 285, 289, 290, 296, 303, 323, 420, 422,
		445, 447, 542, 544, 576, 578, 619, 621, 639, 641, 655, 657, 658, 660, 665,
		667, 671, 690, 698, 703, 705, 707, 717, 719, 725, 772, 772, 816, 816, 855,
		855, 979, 979, 984, 984, 1086, 1097, 23, 0, 37, 37, 93, 93, 144, 144, 146,
		146, 211, 213, 215, 215, 245, 276, 281, 284, 286, 288, 291, 295, 315, 315,
		446, 446, 656, 656, 672, 679, 719, 719, 783, 783, 786, 815, 817, 854, 856,
		978, 980, 983, 985, 1085, 1087, 1089, 1113, 1113, 1906, 0, 146, 1, 0, 0,
		0, 2, 152, 1, 0, 0, 0, 4, 186, 1, 0, 0, 0, 6, 201, 1, 0, 0, 0, 8, 203,
		1, 0, 0, 0, 10, 236, 1, 0, 0, 0, 12, 238, 1, 0, 0, 0, 14, 254, 1, 0, 0,
		0, 16, 256, 1, 0, 0, 0, 18, 316, 1, 0, 0, 0, 20, 387, 1, 0, 0, 0, 22, 389,
		1, 0, 0, 0, 24, 417, 1, 0, 0, 0, 26, 425, 1, 0, 0, 0, 28, 455, 1, 0, 0,
		0, 30, 619, 1, 0, 0, 0, 32, 621, 1, 0, 0, 0, 34, 623, 1, 0, 0, 0, 36, 626,
		1, 0, 0, 0, 38, 700, 1, 0, 0, 0, 40, 723, 1, 0, 0, 0, 42, 871, 1, 0, 0,
		0, 44, 876, 1, 0, 0, 0, 46, 878, 1, 0, 0, 0, 48, 888, 1, 0, 0, 0, 50, 944,
		1, 0, 0, 0, 52, 946, 1, 0, 0, 0, 54, 952, 1, 0, 0, 0, 56, 966, 1, 0, 0,
		0, 58, 979, 1, 0, 0, 0, 60, 984, 1, 0, 0, 0, 62, 990, 1, 0, 0, 0, 64, 994,
		1, 0, 0, 0, 66, 996, 1, 0, 0, 0, 68, 1001, 1, 0, 0, 0, 70, 1012, 1, 0,
		0, 0, 72, 1017, 1, 0, 0, 0, 74, 1019, 1, 0, 0, 0, 76, 1023, 1, 0, 0, 0,
		78, 1048, 1, 0, 0, 0, 80, 1050, 1, 0, 0, 0, 82, 1053, 1, 0, 0, 0, 84, 1058,
		1, 0, 0, 0, 86, 1074, 1, 0, 0, 0, 88, 1211, 1, 0, 0, 0, 90, 1213, 1, 0,
		0, 0, 92, 1246, 1, 0, 0, 0, 94, 1251, 1, 0, 0, 0, 96, 1255, 1, 0, 0, 0,
		98, 1261, 1, 0, 0, 0, 100, 1269, 1, 0, 0, 0, 102, 1277, 1, 0, 0, 0, 104,
		1285, 1, 0, 0, 0, 106, 1336, 1, 0, 0, 0, 108, 1352, 1, 0, 0, 0, 110, 1354,
		1, 0, 0, 0, 112, 1381, 1, 0, 0, 0, 114, 1394, 1, 0, 0, 0, 116, 1405, 1,
		0, 0, 0, 118, 1495, 1, 0, 0, 0, 120, 1517, 1, 0, 0, 0, 122, 1533, 1, 0,
		0, 0, 124, 1542, 1, 0, 0, 0, 126, 1551, 1, 0, 0, 0, 128, 1553, 1, 0, 0,
		0, 130, 1560, 1, 0, 0, 0, 132, 1562, 1, 0, 0, 0, 134, 1564, 1, 0, 0, 0,
		136, 1566, 1, 0, 0, 0, 138, 1568, 1, 0, 0, 0, 140, 1570, 1, 0, 0, 0, 142,
		1572, 1, 0, 0, 0, 144, 1574, 1, 0, 0, 0, 146, 148, 3, 2, 1, 0, 147, 149,
		5, 1126, 0, 0, 148, 147, 1, 0, 0, 0, 148, 149, 1, 0, 0, 0, 149, 150, 1,
		0, 0, 0, 150, 151, 5, 0, 0, 1, 151, 1, 1, 0, 0, 0, 152, 155, 5, 32, 0,
		0, 153, 154, 5, 119, 0, 0, 154, 156, 5, 137, 0, 0, 155, 153, 1, 0, 0, 0,
		155, 156, 1, 0, 0, 0, 156, 158, 1, 0, 0, 0, 157, 159, 5, 632, 0, 0, 158,
		157, 1, 0, 0, 0, 158, 159, 1, 0, 0, 0, 159, 160, 1, 0, 0, 0, 160, 162,
		5, 166, 0, 0, 161, 163, 3, 110, 55, 0, 162, 161, 1, 0, 0, 0, 162, 163,
		1, 0, 0, 0, 163, 164, 1, 0, 0, 0, 164, 165, 3, 54, 27, 0, 165, 176, 3,
		12, 6, 0, 166, 173, 3, 30, 15, 0, 167, 169, 5, 1125, 0, 0, 168, 167, 1,
		0, 0, 0, 168, 169, 1, 0, 0, 0, 169, 170, 1, 0, 0, 0, 170, 172, 3, 30, 15,
		0, 171, 168, 1, 0, 0, 0, 172, 175, 1, 0, 0, 0, 173, 171, 1, 0, 0, 0, 173,
		174, 1, 0, 0, 0, 174, 177, 1, 0, 0, 0, 175, 173, 1, 0, 0, 0, 176, 166,
		1, 0, 0, 0, 176, 177, 1, 0, 0, 0, 177, 179, 1, 0, 0, 0, 178, 180, 3, 36,
		18, 0, 179, 178, 1, 0, 0, 0, 179, 180, 1, 0, 0, 0, 180, 3, 1, 0, 0, 0,
		181, 182, 5, 24, 0, 0, 182, 187, 5, 149, 0, 0, 183, 187, 5, 821, 0, 0,
		184, 185, 5, 216, 0, 0, 185, 187, 5, 149, 0, 0, 186, 181, 1, 0, 0, 0, 186,
		183, 1, 0, 0, 0, 186, 184, 1, 0, 0, 0, 187, 5, 1, 0, 0, 0, 188, 202, 3,
		138, 69, 0, 189, 202, 5, 215, 0, 0, 190, 202, 5, 234, 0, 0, 191, 202, 5,
		235, 0, 0, 192, 202, 5, 236, 0, 0, 193, 202, 5, 237, 0, 0, 194, 202, 5,
		238, 0, 0, 195, 202, 5, 239, 0, 0, 196, 202, 5, 240, 0, 0, 197, 202, 5,
		241, 0, 0, 198, 202, 5, 242, 0, 0, 199, 202, 5, 243, 0, 0, 200, 202, 5,
		244, 0, 0, 201, 188, 1, 0, 0, 0, 201, 189, 1, 0, 0, 0, 201, 190, 1, 0,
		0, 0, 201, 191, 1, 0, 0, 0, 201, 192, 1, 0, 0, 0, 201, 193, 1, 0, 0, 0,
		201, 194, 1, 0, 0, 0, 201, 195, 1, 0, 0, 0, 201, 196, 1, 0, 0, 0, 201,
		197, 1, 0, 0, 0, 201, 198, 1, 0, 0, 0, 201, 199, 1, 0, 0, 0, 201, 200,
		1, 0, 0, 0, 202, 7, 1, 0, 0, 0, 203, 204, 5, 181, 0, 0, 204, 205, 7, 0,
		0, 0, 205, 9, 1, 0, 0, 0, 206, 208, 5, 454, 0, 0, 207, 209, 5, 1114, 0,
		0, 208, 207, 1, 0, 0, 0, 208, 209, 1, 0, 0, 0, 209, 210, 1, 0, 0, 0, 210,
		237, 3, 76, 38, 0, 211, 237, 3, 8, 4, 0, 212, 213, 5, 186, 0, 0, 213, 214,
		5, 532, 0, 0, 214, 237, 3, 68, 34, 0, 215, 216, 5, 359, 0, 0, 216, 237,
		5, 1138, 0, 0, 217, 237, 7, 1, 0, 0, 218, 220, 5, 855, 0, 0, 219, 221,
		5, 1114, 0, 0, 220, 219, 1, 0, 0, 0, 220, 221, 1, 0, 0, 0, 221, 222, 1,
		0, 0, 0, 222, 237, 5, 1138, 0, 0, 223, 225, 5, 979, 0, 0, 224, 226, 5,
		1114, 0, 0, 225, 224, 1, 0, 0, 0, 225, 226, 1, 0, 0, 0, 226, 227, 1, 0,
		0, 0, 227, 237, 5, 1138, 0, 0, 228, 229, 5, 353, 0, 0, 229, 230, 5, 1114,
		0, 0, 230, 237, 7, 2, 0, 0, 231, 235, 5, 76, 0, 0, 232, 233, 5, 110, 0,
		0, 233, 235, 5, 76, 0, 0, 234, 231, 1, 0, 0, 0, 234, 232, 1, 0, 0, 0, 235,
		237, 1, 0, 0, 0, 236, 206, 1, 0, 0, 0, 236, 211, 1, 0, 0, 0, 236, 212,
		1, 0, 0, 0, 236, 215, 1, 0, 0, 0, 236, 217, 1, 0, 0, 0, 236, 218, 1, 0,
		0, 0, 236, 223, 1, 0, 0, 0, 236, 228, 1, 0, 0, 0, 236, 234, 1, 0, 0, 0,
		237, 11, 1, 0, 0, 0, 238, 239, 5, 1123, 0, 0, 239, 244, 3, 14, 7, 0, 240,
		241, 5, 1125, 0, 0, 241, 243, 3, 14, 7, 0, 242, 240, 1, 0, 0, 0, 243, 246,
		1, 0, 0, 0, 244, 242, 1, 0, 0, 0, 244, 245, 1, 0, 0, 0, 245, 247, 1, 0,
		0, 0, 246, 244, 1, 0, 0, 0, 247, 248, 5, 1124, 0, 0, 248, 13, 1, 0, 0,
		0, 249, 250, 3, 68, 34, 0, 250, 251, 3, 16, 8, 0, 251, 255, 1, 0, 0, 0,
		252, 255, 3, 20, 10, 0, 253, 255, 3, 28, 14, 0, 254, 249, 1, 0, 0, 0, 254,
		252, 1, 0, 0, 0, 254, 253, 1, 0, 0, 0, 255, 15, 1, 0, 0, 0, 256, 260, 3,
		88, 44, 0, 257, 259, 3, 18, 9, 0, 258, 257, 1, 0, 0, 0, 259, 262, 1, 0,
		0, 0, 260, 258, 1, 0, 0, 0, 260, 261, 1, 0, 0, 0, 261, 17, 1, 0, 0, 0,
		262, 260, 1, 0, 0, 0, 263, 317, 3, 84, 42, 0, 264, 265, 5, 40, 0, 0, 265,
		317, 3, 106, 53, 0, 266, 317, 5, 656, 0, 0, 267, 317, 5, 446, 0, 0, 268,
		273, 5, 333, 0, 0, 269, 270, 5, 114, 0, 0, 270, 271, 5, 178, 0, 0, 271,
		273, 3, 108, 54, 0, 272, 268, 1, 0, 0, 0, 272, 269, 1, 0, 0, 0, 273, 317,
		1, 0, 0, 0, 274, 276, 5, 126, 0, 0, 275, 274, 1, 0, 0, 0, 275, 276, 1,
		0, 0, 0, 276, 277, 1, 0, 0, 0, 277, 317, 5, 88, 0, 0, 278, 280, 5, 175,
		0, 0, 279, 281, 5, 88, 0, 0, 280, 279, 1, 0, 0, 0, 280, 281, 1, 0, 0, 0,
		281, 317, 1, 0, 0, 0, 282, 283, 5, 359, 0, 0, 283, 317, 5, 1138, 0, 0,
		284, 285, 5, 357, 0, 0, 285, 317, 7, 3, 0, 0, 286, 287, 5, 619, 0, 0, 287,
		317, 7, 4, 0, 0, 288, 317, 3, 22, 11, 0, 289, 290, 5, 26, 0, 0, 290, 317,
		3, 64, 32, 0, 291, 292, 5, 67, 0, 0, 292, 294, 5, 8, 0, 0, 293, 291, 1,
		0, 0, 0, 293, 294, 1, 0, 0, 0, 294, 295, 1, 0, 0, 0, 295, 296, 5, 12, 0,
		0, 296, 297, 5, 1123, 0, 0, 297, 298, 3, 114, 57, 0, 298, 300, 5, 1124,
		0, 0, 299, 301, 7, 5, 0, 0, 300, 299, 1, 0, 0, 0, 300, 301, 1, 0, 0, 0,
		301, 317, 1, 0, 0, 0, 302, 303, 5, 233, 0, 0, 303, 304, 5, 40, 0, 0, 304,
		317, 5, 652, 0, 0, 305, 307, 5, 29, 0, 0, 306, 308, 3, 68, 34, 0, 307,
		306, 1, 0, 0, 0, 307, 308, 1, 0, 0, 0, 308, 310, 1, 0, 0, 0, 309, 305,
		1, 0, 0, 0, 309, 310, 1, 0, 0, 0, 310, 311, 1, 0, 0, 0, 311, 312, 5, 25,
		0, 0, 312, 313, 5, 1123, 0, 0, 313, 314, 3, 114, 57, 0, 314, 315, 5, 1124,
		0, 0, 315, 317, 1, 0, 0, 0, 316, 263, 1, 0, 0, 0, 316, 264, 1, 0, 0, 0,
		316, 266, 1, 0, 0, 0, 316, 267, 1, 0, 0, 0, 316, 272, 1, 0, 0, 0, 316,
		275, 1, 0, 0, 0, 316, 278, 1, 0, 0, 0, 316, 282, 1, 0, 0, 0, 316, 284,
		1, 0, 0, 0, 316, 286, 1, 0, 0, 0, 316, 288, 1, 0, 0, 0, 316, 289, 1, 0,
		0, 0, 316, 293, 1, 0, 0, 0, 316, 302, 1, 0, 0, 0, 316, 309, 1, 0, 0, 0,
		317, 19, 1, 0, 0, 0, 318, 320, 5, 29, 0, 0, 319, 321, 3, 68, 34, 0, 320,
		319, 1, 0, 0, 0, 320, 321, 1, 0, 0, 0, 321, 323, 1, 0, 0, 0, 322, 318,
		1, 0, 0, 0, 322, 323, 1, 0, 0, 0, 323, 324, 1, 0, 0, 0, 324, 325, 5, 126,
		0, 0, 325, 327, 5, 88, 0, 0, 326, 328, 3, 68, 34, 0, 327, 326, 1, 0, 0,
		0, 327, 328, 1, 0, 0, 0, 328, 330, 1, 0, 0, 0, 329, 331, 3, 8, 4, 0, 330,
		329, 1, 0, 0, 0, 330, 331, 1, 0, 0, 0, 331, 332, 1, 0, 0, 0, 332, 336,
		3, 104, 52, 0, 333, 335, 3, 10, 5, 0, 334, 333, 1, 0, 0, 0, 335, 338, 1,
		0, 0, 0, 336, 334, 1, 0, 0, 0, 336, 337, 1, 0, 0, 0, 337, 388, 1, 0, 0,
		0, 338, 336, 1, 0, 0, 0, 339, 341, 5, 29, 0, 0, 340, 342, 3, 68, 34, 0,
		341, 340, 1, 0, 0, 0, 341, 342, 1, 0, 0, 0, 342, 344, 1, 0, 0, 0, 343,
		339, 1, 0, 0, 0, 343, 344, 1, 0, 0, 0, 344, 345, 1, 0, 0, 0, 345, 347,
		5, 175, 0, 0, 346, 348, 7, 6, 0, 0, 347, 346, 1, 0, 0, 0, 347, 348, 1,
		0, 0, 0, 348, 350, 1, 0, 0, 0, 349, 351, 3, 68, 34, 0, 350, 349, 1, 0,
		0, 0, 350, 351, 1, 0, 0, 0, 351, 353, 1, 0, 0, 0, 352, 354, 3, 8, 4, 0,
		353, 352, 1, 0, 0, 0, 353, 354, 1, 0, 0, 0, 354, 355, 1, 0, 0, 0, 355,
		359, 3, 104, 52, 0, 356, 358, 3, 10, 5, 0, 357, 356, 1, 0, 0, 0, 358, 361,
		1, 0, 0, 0, 359, 357, 1, 0, 0, 0, 359, 360, 1, 0, 0, 0, 360, 388, 1, 0,
		0, 0, 361, 359, 1, 0, 0, 0, 362, 364, 5, 29, 0, 0, 363, 365, 3, 68, 34,
		0, 364, 363, 1, 0, 0, 0, 364, 365, 1, 0, 0, 0, 365, 367, 1, 0, 0, 0, 366,
		362, 1, 0, 0, 0, 366, 367, 1, 0, 0, 0, 367, 368, 1, 0, 0, 0, 368, 369,
		5, 64, 0, 0, 369, 371, 5, 88, 0, 0, 370, 372, 3, 68, 34, 0, 371, 370, 1,
		0, 0, 0, 371, 372, 1, 0, 0, 0, 372, 373, 1, 0, 0, 0, 373, 374, 3, 104,
		52, 0, 374, 375, 3, 22, 11, 0, 375, 388, 1, 0, 0, 0, 376, 378, 5, 29, 0,
		0, 377, 379, 3, 68, 34, 0, 378, 377, 1, 0, 0, 0, 378, 379, 1, 0, 0, 0,
		379, 381, 1, 0, 0, 0, 380, 376, 1, 0, 0, 0, 380, 381, 1, 0, 0, 0, 381,
		382, 1, 0, 0, 0, 382, 383, 5, 25, 0, 0, 383, 384, 5, 1123, 0, 0, 384, 385,
		3, 114, 57, 0, 385, 386, 5, 1124, 0, 0, 386, 388, 1, 0, 0, 0, 387, 322,
		1, 0, 0, 0, 387, 343, 1, 0, 0, 0, 387, 366, 1, 0, 0, 0, 387, 380, 1, 0,
		0, 0, 388, 21, 1, 0, 0, 0, 389, 390, 5, 132, 0, 0, 390, 392, 3, 54, 27,
		0, 391, 393, 3, 104, 52, 0, 392, 391, 1, 0, 0, 0, 392, 393, 1, 0, 0, 0,
		393, 396, 1, 0, 0, 0, 394, 395, 5, 105, 0, 0, 395, 397, 7, 7, 0, 0, 396,
		394, 1, 0, 0, 0, 396, 397, 1, 0, 0, 0, 397, 399, 1, 0, 0, 0, 398, 400,
		3, 24, 12, 0, 399, 398, 1, 0, 0, 0, 399, 400, 1, 0, 0, 0, 400, 23, 1, 0,
		0, 0, 401, 402, 5, 114, 0, 0, 402, 403, 5, 42, 0, 0, 403, 407, 3, 26, 13,
		0, 404, 405, 5, 114, 0, 0, 405, 406, 5, 178, 0, 0, 406, 408, 3, 26, 13,
		0, 407, 404, 1, 0, 0, 0, 407, 408, 1, 0, 0, 0, 408, 418, 1, 0, 0, 0, 409,
		410, 5, 114, 0, 0, 410, 411, 5, 178, 0, 0, 411, 415, 3, 26, 13, 0, 412,
		413, 5, 114, 0, 0, 413, 414, 5, 42, 0, 0, 414, 416, 3, 26, 13, 0, 415,
		412, 1, 0, 0, 0, 415, 416, 1, 0, 0, 0, 416, 418, 1, 0, 0, 0, 417, 401,
		1, 0, 0, 0, 417, 409, 1, 0, 0, 0, 418, 25, 1, 0, 0, 0, 419, 426, 5, 140,
		0, 0, 420, 426, 5, 20, 0, 0, 421, 422, 5, 149, 0, 0, 422, 426, 5, 112,
		0, 0, 423, 424, 5, 508, 0, 0, 424, 426, 5, 324, 0, 0, 425, 419, 1, 0, 0,
		0, 425, 420, 1, 0, 0, 0, 425, 421, 1, 0, 0, 0, 425, 423, 1, 0, 0, 0, 426,
		27, 1, 0, 0, 0, 427, 429, 7, 6, 0, 0, 428, 430, 3, 68, 34, 0, 429, 428,
		1, 0, 0, 0, 429, 430, 1, 0, 0, 0, 430, 432, 1, 0, 0, 0, 431, 433, 3, 8,
		4, 0, 432, 431, 1, 0, 0, 0, 432, 433, 1, 0, 0, 0, 433, 434, 1, 0, 0, 0,
		434, 438, 3, 104, 52, 0, 435, 437, 3, 10, 5, 0, 436, 435, 1, 0, 0, 0, 437,
		440, 1, 0, 0, 0, 438, 436, 1, 0, 0, 0, 438, 439, 1, 0, 0, 0, 439, 456,
		1, 0, 0, 0, 440, 438, 1, 0, 0, 0, 441, 443, 7, 8, 0, 0, 442, 444, 7, 6,
		0, 0, 443, 442, 1, 0, 0, 0, 443, 444, 1, 0, 0, 0, 444, 446, 1, 0, 0, 0,
		445, 447, 3, 68, 34, 0, 446, 445, 1, 0, 0, 0, 446, 447, 1, 0, 0, 0, 447,
		448, 1, 0, 0, 0, 448, 452, 3, 104, 52, 0, 449, 451, 3, 10, 5, 0, 450, 449,
		1, 0, 0, 0, 451, 454, 1, 0, 0, 0, 452, 450, 1, 0, 0, 0, 452, 453, 1, 0,
		0, 0, 453, 456, 1, 0, 0, 0, 454, 452, 1, 0, 0, 0, 455, 427, 1, 0, 0, 0,
		455, 441, 1, 0, 0, 0, 456, 29, 1, 0, 0, 0, 457, 459, 5, 398, 0, 0, 458,
		460, 5, 1114, 0, 0, 459, 458, 1, 0, 0, 0, 459, 460, 1, 0, 0, 0, 460, 462,
		1, 0, 0, 0, 461, 463, 3, 66, 33, 0, 462, 461, 1, 0, 0, 0, 462, 463, 1,
		0, 0, 0, 463, 620, 1, 0, 0, 0, 464, 466, 5, 855, 0, 0, 465, 467, 5, 1114,
		0, 0, 466, 465, 1, 0, 0, 0, 466, 467, 1, 0, 0, 0, 467, 468, 1, 0, 0, 0,
		468, 620, 5, 1138, 0, 0, 469, 471, 5, 332, 0, 0, 470, 472, 5, 1114, 0,
		0, 471, 470, 1, 0, 0, 0, 471, 472, 1, 0, 0, 0, 472, 473, 1, 0, 0, 0, 473,
		620, 3, 74, 37, 0, 474, 476, 5, 333, 0, 0, 475, 477, 5, 1114, 0, 0, 476,
		475, 1, 0, 0, 0, 476, 477, 1, 0, 0, 0, 477, 478, 1, 0, 0, 0, 478, 620,
		3, 74, 37, 0, 479, 481, 5, 334, 0, 0, 480, 482, 5, 1114, 0, 0, 481, 480,
		1, 0, 0, 0, 481, 482, 1, 0, 0, 0, 482, 483, 1, 0, 0, 0, 483, 620, 3, 74,
		37, 0, 484, 486, 5, 40, 0, 0, 485, 484, 1, 0, 0, 0, 485, 486, 1, 0, 0,
		0, 486, 487, 1, 0, 0, 0, 487, 489, 3, 4, 2, 0, 488, 490, 5, 1114, 0, 0,
		489, 488, 1, 0, 0, 0, 489, 490, 1, 0, 0, 0, 490, 493, 1, 0, 0, 0, 491,
		494, 3, 62, 31, 0, 492, 494, 5, 40, 0, 0, 493, 491, 1, 0, 0, 0, 493, 492,
		1, 0, 0, 0, 494, 620, 1, 0, 0, 0, 495, 497, 7, 9, 0, 0, 496, 498, 5, 1114,
		0, 0, 497, 496, 1, 0, 0, 0, 497, 498, 1, 0, 0, 0, 498, 499, 1, 0, 0, 0,
		499, 620, 7, 10, 0, 0, 500, 502, 5, 40, 0, 0, 501, 500, 1, 0, 0, 0, 501,
		502, 1, 0, 0, 0, 502, 503, 1, 0, 0, 0, 503, 505, 5, 26, 0, 0, 504, 506,
		5, 1114, 0, 0, 505, 504, 1, 0, 0, 0, 505, 506, 1, 0, 0, 0, 506, 507, 1,
		0, 0, 0, 507, 620, 3, 64, 32, 0, 508, 510, 5, 359, 0, 0, 509, 511, 5, 1114,
		0, 0, 510, 509, 1, 0, 0, 0, 510, 511, 1, 0, 0, 0, 511, 512, 1, 0, 0, 0,
		512, 620, 5, 1138, 0, 0, 513, 515, 5, 364, 0, 0, 514, 516, 5, 1114, 0,
		0, 515, 514, 1, 0, 0, 0, 515, 516, 1, 0, 0, 0, 516, 517, 1, 0, 0, 0, 517,
		620, 7, 11, 0, 0, 518, 520, 5, 367, 0, 0, 519, 521, 5, 1114, 0, 0, 520,
		519, 1, 0, 0, 0, 520, 521, 1, 0, 0, 0, 521, 522, 1, 0, 0, 0, 522, 620,
		5, 1138, 0, 0, 523, 524, 7, 12, 0, 0, 524, 526, 5, 386, 0, 0, 525, 527,
		5, 1114, 0, 0, 526, 525, 1, 0, 0, 0, 526, 527, 1, 0, 0, 0, 527, 528, 1,
		0, 0, 0, 528, 620, 5, 1138, 0, 0, 529, 531, 5, 384, 0, 0, 530, 532, 5,
		1114, 0, 0, 531, 530, 1, 0, 0, 0, 531, 532, 1, 0, 0, 0, 532, 533, 1, 0,
		0, 0, 533, 620, 7, 10, 0, 0, 534, 536, 5, 395, 0, 0, 535, 537, 5, 1114,
		0, 0, 536, 535, 1, 0, 0, 0, 536, 537, 1, 0, 0, 0, 537, 538, 1, 0, 0, 0,
		538, 620, 5, 1138, 0, 0, 539, 540, 5, 78, 0, 0, 540, 542, 5, 386, 0, 0,
		541, 543, 5, 1114, 0, 0, 542, 541, 1, 0, 0, 0, 542, 543, 1, 0, 0, 0, 543,
		544, 1, 0, 0, 0, 544, 620, 5, 1138, 0, 0, 545, 547, 5, 442, 0, 0, 546,
		548, 5, 1114, 0, 0, 547, 546, 1, 0, 0, 0, 547, 548, 1, 0, 0, 0, 548, 549,
		1, 0, 0, 0, 549, 620, 7, 13, 0, 0, 550, 552, 5, 454, 0, 0, 551, 553, 5,
		1114, 0, 0, 552, 551, 1, 0, 0, 0, 552, 553, 1, 0, 0, 0, 553, 554, 1, 0,
		0, 0, 554, 620, 3, 76, 38, 0, 555, 557, 5, 487, 0, 0, 556, 558, 5, 1114,
		0, 0, 557, 556, 1, 0, 0, 0, 557, 558, 1, 0, 0, 0, 558, 559, 1, 0, 0, 0,
		559, 620, 3, 74, 37, 0, 560, 562, 5, 497, 0, 0, 561, 563, 5, 1114, 0, 0,
		562, 561, 1, 0, 0, 0, 562, 563, 1, 0, 0, 0, 563, 564, 1, 0, 0, 0, 564,
		620, 3, 74, 37, 0, 565, 567, 5, 530, 0, 0, 566, 568, 5, 1114, 0, 0, 567,
		566, 1, 0, 0, 0, 567, 568, 1, 0, 0, 0, 568, 569, 1, 0, 0, 0, 569, 620,
		7, 14, 0, 0, 570, 572, 5, 536, 0, 0, 571, 573, 5, 1114, 0, 0, 572, 571,
		1, 0, 0, 0, 572, 573, 1, 0, 0, 0, 573, 574, 1, 0, 0, 0, 574, 620, 5, 1138,
		0, 0, 575, 577, 5, 585, 0, 0, 576, 578, 5, 1114, 0, 0, 577, 576, 1, 0,
		0, 0, 577, 578, 1, 0, 0, 0, 578, 579, 1, 0, 0, 0, 579, 620, 7, 15, 0, 0,
		580, 581, 5, 612, 0, 0, 581, 620, 5, 636, 0, 0, 582, 584, 5, 979, 0, 0,
		583, 585, 5, 1114, 0, 0, 584, 583, 1, 0, 0, 0, 584, 585, 1, 0, 0, 0, 585,
		586, 1, 0, 0, 0, 586, 620, 5, 1138, 0, 0, 587, 589, 5, 614, 0, 0, 588,
		590, 5, 1114, 0, 0, 589, 588, 1, 0, 0, 0, 589, 590, 1, 0, 0, 0, 590, 591,
		1, 0, 0, 0, 591, 620, 7, 14, 0, 0, 592, 594, 5, 615, 0, 0, 593, 595, 5,
		1114, 0, 0, 594, 593, 1, 0, 0, 0, 594, 595, 1, 0, 0, 0, 595, 596, 1, 0,
		0, 0, 596, 620, 7, 14, 0, 0, 597, 599, 5, 616, 0, 0, 598, 600, 5, 1114,
		0, 0, 599, 598, 1, 0, 0, 0, 599, 600, 1, 0, 0, 0, 600, 601, 1, 0, 0, 0,
		601, 620, 7, 16, 0, 0, 602, 603, 5, 630, 0, 0, 603, 605, 3, 68, 34, 0,
		604, 606, 3, 34, 17, 0, 605, 604, 1, 0, 0, 0, 605, 606, 1, 0, 0, 0, 606,
		620, 1, 0, 0, 0, 607, 608, 5, 631, 0, 0, 608, 609, 5, 1114, 0, 0, 609,
		620, 3, 32, 16, 0, 610, 620, 3, 34, 17, 0, 611, 613, 5, 174, 0, 0, 612,
		614, 5, 1114, 0, 0, 613, 612, 1, 0, 0, 0, 613, 614, 1, 0, 0, 0, 614, 615,
		1, 0, 0, 0, 615, 616, 5, 1123, 0, 0, 616, 617, 3, 102, 51, 0, 617, 618,
		5, 1124, 0, 0, 618, 620, 1, 0, 0, 0, 619, 457, 1, 0, 0, 0, 619, 464, 1,
		0, 0, 0, 619, 469, 1, 0, 0, 0, 619, 474, 1, 0, 0, 0, 619, 479, 1, 0, 0,
		0, 619, 485, 1, 0, 0, 0, 619, 495, 1, 0, 0, 0, 619, 501, 1, 0, 0, 0, 619,
		508, 1, 0, 0, 0, 619, 513, 1, 0, 0, 0, 619, 518, 1, 0, 0, 0, 619, 523,
		1, 0, 0, 0, 619, 529, 1, 0, 0, 0, 619, 534, 1, 0, 0, 0, 619, 539, 1, 0,
		0, 0, 619, 545, 1, 0, 0, 0, 619, 550, 1, 0, 0, 0, 619, 555, 1, 0, 0, 0,
		619, 560, 1, 0, 0, 0, 619, 565, 1, 0, 0, 0, 619, 570, 1, 0, 0, 0, 619,
		575, 1, 0, 0, 0, 619, 580, 1, 0, 0, 0, 619, 582, 1, 0, 0, 0, 619, 587,
		1, 0, 0, 0, 619, 592, 1, 0, 0, 0, 619, 597, 1, 0, 0, 0, 619, 602, 1, 0,
		0, 0, 619, 607, 1, 0, 0, 0, 619, 610, 1, 0, 0, 0, 619, 611, 1, 0, 0, 0,
		620, 31, 1, 0, 0, 0, 621, 622, 7, 17, 0, 0, 622, 33, 1, 0, 0, 0, 623, 624,
		5, 619, 0, 0, 624, 625, 7, 4, 0, 0, 625, 35, 1, 0, 0, 0, 626, 627, 5, 125,
		0, 0, 627, 628, 5, 18, 0, 0, 628, 631, 3, 38, 19, 0, 629, 630, 5, 535,
		0, 0, 630, 632, 3, 74, 37, 0, 631, 629, 1, 0, 0, 0, 631, 632, 1, 0, 0,
		0, 632, 640, 1, 0, 0, 0, 633, 634, 5, 624, 0, 0, 634, 635, 5, 18, 0, 0,
		635, 638, 3, 40, 20, 0, 636, 637, 5, 625, 0, 0, 637, 639, 3, 74, 37, 0,
		638, 636, 1, 0, 0, 0, 638, 639, 1, 0, 0, 0, 639, 641, 1, 0, 0, 0, 640,
		633, 1, 0, 0, 0, 640, 641, 1, 0, 0, 0, 641, 653, 1, 0, 0, 0, 642, 643,
		5, 1123, 0, 0, 643, 648, 3, 42, 21, 0, 644, 645, 5, 1125, 0, 0, 645, 647,
		3, 42, 21, 0, 646, 644, 1, 0, 0, 0, 647, 650, 1, 0, 0, 0, 648, 646, 1,
		0, 0, 0, 648, 649, 1, 0, 0, 0, 649, 651, 1, 0, 0, 0, 650, 648, 1, 0, 0,
		0, 651, 652, 5, 1124, 0, 0, 652, 654, 1, 0, 0, 0, 653, 642, 1, 0, 0, 0,
		653, 654, 1, 0, 0, 0, 654, 37, 1, 0, 0, 0, 655, 657, 5, 96, 0, 0, 656,
		655, 1, 0, 0, 0, 656, 657, 1, 0, 0, 0, 657, 658, 1, 0, 0, 0, 658, 659,
		5, 431, 0, 0, 659, 660, 5, 1123, 0, 0, 660, 661, 3, 114, 57, 0, 661, 662,
		5, 1124, 0, 0, 662, 701, 1, 0, 0, 0, 663, 665, 5, 96, 0, 0, 664, 663, 1,
		0, 0, 0, 664, 665, 1, 0, 0, 0, 665, 666, 1, 0, 0, 0, 666, 670, 5, 88, 0,
		0, 667, 668, 5, 327, 0, 0, 668, 669, 5, 1114, 0, 0, 669, 671, 7, 18, 0,
		0, 670, 667, 1, 0, 0, 0, 670, 671, 1, 0, 0, 0, 671, 672, 1, 0, 0, 0, 672,
		673, 5, 1123, 0, 0, 673, 674, 3, 100, 50, 0, 674, 675, 5, 1124, 0, 0, 675,
		701, 1, 0, 0, 0, 676, 686, 5, 129, 0, 0, 677, 678, 5, 1123, 0, 0, 678,
		679, 3, 114, 57, 0, 679, 680, 5, 1124, 0, 0, 680, 687, 1, 0, 0, 0, 681,
		682, 5, 356, 0, 0, 682, 683, 5, 1123, 0, 0, 683, 684, 3, 100, 50, 0, 684,
		685, 5, 1124, 0, 0, 685, 687, 1, 0, 0, 0, 686, 677, 1, 0, 0, 0, 686, 681,
		1, 0, 0, 0, 687, 701, 1, 0, 0, 0, 688, 698, 5, 460, 0, 0, 689, 690, 5,
		1123, 0, 0, 690, 691, 3, 114, 57, 0, 691, 692, 5, 1124, 0, 0, 692, 699,
		1, 0, 0, 0, 693, 694, 5, 356, 0, 0, 694, 695, 5, 1123, 0, 0, 695, 696,
		3, 100, 50, 0, 696, 697, 5, 1124, 0, 0, 697, 699, 1, 0, 0, 0, 698, 689,
		1, 0, 0, 0, 698, 693, 1, 0, 0, 0, 699, 701, 1, 0, 0, 0, 700, 656, 1, 0,
		0, 0, 700, 664, 1, 0, 0, 0, 700, 676, 1, 0, 0, 0, 700, 688, 1, 0, 0, 0,
		701, 39, 1, 0, 0, 0, 702, 704, 5, 96, 0, 0, 703, 702, 1, 0, 0, 0, 703,
		704, 1, 0, 0, 0, 704, 705, 1, 0, 0, 0, 705, 706, 5, 431, 0, 0, 706, 707,
		5, 1123, 0, 0, 707, 708, 3, 114, 57, 0, 708, 709, 5, 1124, 0, 0, 709, 724,
		1, 0, 0, 0, 710, 712, 5, 96, 0, 0, 711, 710, 1, 0, 0, 0, 711, 712, 1, 0,
		0, 0, 712, 713, 1, 0, 0, 0, 713, 717, 5, 88, 0, 0, 714, 715, 5, 327, 0,
		0, 715, 716, 5, 1114, 0, 0, 716, 718, 7, 18, 0, 0, 717, 714, 1, 0, 0, 0,
		717, 718, 1, 0, 0, 0, 718, 719, 1, 0, 0, 0, 719, 720, 5, 1123, 0, 0, 720,
		721, 3, 100, 50, 0, 721, 722, 5, 1124, 0, 0, 722, 724, 1, 0, 0, 0, 723,
		703, 1, 0, 0, 0, 723, 711, 1, 0, 0, 0, 724, 41, 1, 0, 0, 0, 725, 726, 5,
		125, 0, 0, 726, 727, 3, 68, 34, 0, 727, 728, 5, 182, 0, 0, 728, 729, 5,
		458, 0, 0, 729, 730, 5, 634, 0, 0, 730, 731, 5, 1123, 0, 0, 731, 736, 3,
		44, 22, 0, 732, 733, 5, 1125, 0, 0, 733, 735, 3, 44, 22, 0, 734, 732, 1,
		0, 0, 0, 735, 738, 1, 0, 0, 0, 736, 734, 1, 0, 0, 0, 736, 737, 1, 0, 0,
		0, 737, 739, 1, 0, 0, 0, 738, 736, 1, 0, 0, 0, 739, 743, 5, 1124, 0, 0,
		740, 742, 3, 50, 25, 0, 741, 740, 1, 0, 0, 0, 742, 745, 1, 0, 0, 0, 743,
		741, 1, 0, 0, 0, 743, 744, 1, 0, 0, 0, 744, 757, 1, 0, 0, 0, 745, 743,
		1, 0, 0, 0, 746, 747, 5, 1123, 0, 0, 747, 752, 3, 48, 24, 0, 748, 749,
		5, 1125, 0, 0, 749, 751, 3, 48, 24, 0, 750, 748, 1, 0, 0, 0, 751, 754,
		1, 0, 0, 0, 752, 750, 1, 0, 0, 0, 752, 753, 1, 0, 0, 0, 753, 755, 1, 0,
		0, 0, 754, 752, 1, 0, 0, 0, 755, 756, 5, 1124, 0, 0, 756, 758, 1, 0, 0,
		0, 757, 746, 1, 0, 0, 0, 757, 758, 1, 0, 0, 0, 758, 872, 1, 0, 0, 0, 759,
		760, 5, 125, 0, 0, 760, 761, 3, 68, 34, 0, 761, 762, 5, 182, 0, 0, 762,
		763, 5, 458, 0, 0, 763, 764, 5, 634, 0, 0, 764, 768, 3, 44, 22, 0, 765,
		767, 3, 50, 25, 0, 766, 765, 1, 0, 0, 0, 767, 770, 1, 0, 0, 0, 768, 766,
		1, 0, 0, 0, 768, 769, 1, 0, 0, 0, 769, 782, 1, 0, 0, 0, 770, 768, 1, 0,
		0, 0, 771, 772, 5, 1123, 0, 0, 772, 777, 3, 48, 24, 0, 773, 774, 5, 1125,
		0, 0, 774, 776, 3, 48, 24, 0, 775, 773, 1, 0, 0, 0, 776, 779, 1, 0, 0,
		0, 777, 775, 1, 0, 0, 0, 777, 778, 1, 0, 0, 0, 778, 780, 1, 0, 0, 0, 779,
		777, 1, 0, 0, 0, 780, 781, 5, 1124, 0, 0, 781, 783, 1, 0, 0, 0, 782, 771,
		1, 0, 0, 0, 782, 783, 1, 0, 0, 0, 783, 872, 1, 0, 0, 0, 784, 785, 5, 125,
		0, 0, 785, 786, 3, 68, 34, 0, 786, 787, 5, 182, 0, 0, 787, 788, 5, 77,
		0, 0, 788, 789, 5, 1123, 0, 0, 789, 794, 3, 44, 22, 0, 790, 791, 5, 1125,
		0, 0, 791, 793, 3, 44, 22, 0, 792, 790, 1, 0, 0, 0, 793, 796, 1, 0, 0,
		0, 794, 792, 1, 0, 0, 0, 794, 795, 1, 0, 0, 0, 795, 797, 1, 0, 0, 0, 796,
		794, 1, 0, 0, 0, 797, 801, 5, 1124, 0, 0, 798, 800, 3, 50, 25, 0, 799,
		798, 1, 0, 0, 0, 800, 803, 1, 0, 0, 0, 801, 799, 1, 0, 0, 0, 801, 802,
		1, 0, 0, 0, 802, 815, 1, 0, 0, 0, 803, 801, 1, 0, 0, 0, 804, 805, 5, 1123,
		0, 0, 805, 810, 3, 48, 24, 0, 806, 807, 5, 1125, 0, 0, 807, 809, 3, 48,
		24, 0, 808, 806, 1, 0, 0, 0, 809, 812, 1, 0, 0, 0, 810, 808, 1, 0, 0, 0,
		810, 811, 1, 0, 0, 0, 811, 813, 1, 0, 0, 0, 812, 810, 1, 0, 0, 0, 813,
		814, 5, 1124, 0, 0, 814, 816, 1, 0, 0, 0, 815, 804, 1, 0, 0, 0, 815, 816,
		1, 0, 0, 0, 816, 872, 1, 0, 0, 0, 817, 818, 5, 125, 0, 0, 818, 819, 3,
		68, 34, 0, 819, 820, 5, 182, 0, 0, 820, 821, 5, 77, 0, 0, 821, 822, 5,
		1123, 0, 0, 822, 827, 3, 46, 23, 0, 823, 824, 5, 1125, 0, 0, 824, 826,
		3, 46, 23, 0, 825, 823, 1, 0, 0, 0, 826, 829, 1, 0, 0, 0, 827, 825, 1,
		0, 0, 0, 827, 828, 1, 0, 0, 0, 828, 830, 1, 0, 0, 0, 829, 827, 1, 0, 0,
		0, 830, 834, 5, 1124, 0, 0, 831, 833, 3, 50, 25, 0, 832, 831, 1, 0, 0,
		0, 833, 836, 1, 0, 0, 0, 834, 832, 1, 0, 0, 0, 834, 835, 1, 0, 0, 0, 835,
		848, 1, 0, 0, 0, 836, 834, 1, 0, 0, 0, 837, 838, 5, 1123, 0, 0, 838, 843,
		3, 48, 24, 0, 839, 840, 5, 1125, 0, 0, 840, 842, 3, 48, 24, 0, 841, 839,
		1, 0, 0, 0, 842, 845, 1, 0, 0, 0, 843, 841, 1, 0, 0, 0, 843, 844, 1, 0,
		0, 0, 844, 846, 1, 0, 0, 0, 845, 843, 1, 0, 0, 0, 846, 847, 5, 1124, 0,
		0, 847, 849, 1, 0, 0, 0, 848, 837, 1, 0, 0, 0, 848, 849, 1, 0, 0, 0, 849,
		872, 1, 0, 0, 0, 850, 851, 5, 125, 0, 0, 851, 855, 3, 68, 34, 0, 852, 854,
		3, 50, 25, 0, 853, 852, 1, 0, 0, 0, 854, 857, 1, 0, 0, 0, 855, 853, 1,
		0, 0, 0, 855, 856, 1, 0, 0, 0, 856, 869, 1, 0, 0, 0, 857, 855, 1, 0, 0,
		0, 858, 859, 5, 1123, 0, 0, 859, 864, 3, 48, 24, 0, 860, 861, 5, 1125,
		0, 0, 861, 863, 3, 48, 24, 0, 862, 860, 1, 0, 0, 0, 863, 866, 1, 0, 0,
		0, 864, 862, 1, 0, 0, 0, 864, 865, 1, 0, 0, 0, 865, 867, 1, 0, 0, 0, 866,
		864, 1, 0, 0, 0, 867, 868, 5, 1124, 0, 0, 868, 870, 1, 0, 0, 0, 869, 858,
		1, 0, 0, 0, 869, 870, 1, 0, 0, 0, 870, 872, 1, 0, 0, 0, 871, 725, 1, 0,
		0, 0, 871, 759, 1, 0, 0, 0, 871, 784, 1, 0, 0, 0, 871, 817, 1, 0, 0, 0,
		871, 850, 1, 0, 0, 0, 872, 43, 1, 0, 0, 0, 873, 877, 3, 86, 43, 0, 874,
		877, 3, 114, 57, 0, 875, 877, 5, 106, 0, 0, 876, 873, 1, 0, 0, 0, 876,
		874, 1, 0, 0, 0, 876, 875, 1, 0, 0, 0, 877, 45, 1, 0, 0, 0, 878, 879, 5,
		1123, 0, 0, 879, 882, 3, 44, 22, 0, 880, 881, 5, 1125, 0, 0, 881, 883,
		3, 44, 22, 0, 882, 880, 1, 0, 0, 0, 883, 884, 1, 0, 0, 0, 884, 882, 1,
		0, 0, 0, 884, 885, 1, 0, 0, 0, 885, 886, 1, 0, 0, 0, 886, 887, 5, 1124,
		0, 0, 887, 47, 1, 0, 0, 0, 888, 889, 5, 624, 0, 0, 889, 893, 3, 68, 34,
		0, 890, 892, 3, 50, 25, 0, 891, 890, 1, 0, 0, 0, 892, 895, 1, 0, 0, 0,
		893, 891, 1, 0, 0, 0, 893, 894, 1, 0, 0, 0, 894, 49, 1, 0, 0, 0, 895, 893,
		1, 0, 0, 0, 896, 898, 5, 40, 0, 0, 897, 896, 1, 0, 0, 0, 897, 898, 1, 0,
		0, 0, 898, 900, 1, 0, 0, 0, 899, 901, 5, 619, 0, 0, 900, 899, 1, 0, 0,
		0, 900, 901, 1, 0, 0, 0, 901, 902, 1, 0, 0, 0, 902, 904, 5, 398, 0, 0,
		903, 905, 5, 1114, 0, 0, 904, 903, 1, 0, 0, 0, 904, 905, 1, 0, 0, 0, 905,
		906, 1, 0, 0, 0, 906, 945, 3, 66, 33, 0, 907, 909, 5, 359, 0, 0, 908, 910,
		5, 1114, 0, 0, 909, 908, 1, 0, 0, 0, 909, 910, 1, 0, 0, 0, 910, 911, 1,
		0, 0, 0, 911, 945, 5, 1138, 0, 0, 912, 913, 5, 379, 0, 0, 913, 915, 5,
		386, 0, 0, 914, 916, 5, 1114, 0, 0, 915, 914, 1, 0, 0, 0, 915, 916, 1,
		0, 0, 0, 916, 917, 1, 0, 0, 0, 917, 945, 5, 1138, 0, 0, 918, 919, 5, 78,
		0, 0, 919, 921, 5, 386, 0, 0, 920, 922, 5, 1114, 0, 0, 921, 920, 1, 0,
		0, 0, 921, 922, 1, 0, 0, 0, 922, 923, 1, 0, 0, 0, 923, 945, 5, 1138, 0,
		0, 924, 926, 5, 487, 0, 0, 925, 927, 5, 1114, 0, 0, 926, 925, 1, 0, 0,
		0, 926, 927, 1, 0, 0, 0, 927, 928, 1, 0, 0, 0, 928, 945, 3, 74, 37, 0,
		929, 931, 5, 497, 0, 0, 930, 932, 5, 1114, 0, 0, 931, 930, 1, 0, 0, 0,
		931, 932, 1, 0, 0, 0, 932, 933, 1, 0, 0, 0, 933, 945, 3, 74, 37, 0, 934,
		936, 5, 630, 0, 0, 935, 937, 5, 1114, 0, 0, 936, 935, 1, 0, 0, 0, 936,
		937, 1, 0, 0, 0, 937, 938, 1, 0, 0, 0, 938, 945, 3, 68, 34, 0, 939, 941,
		5, 515, 0, 0, 940, 942, 5, 1114, 0, 0, 941, 940, 1, 0, 0, 0, 941, 942,
		1, 0, 0, 0, 942, 943, 1, 0, 0, 0, 943, 945, 3, 68, 34, 0, 944, 897, 1,
		0, 0, 0, 944, 907, 1, 0, 0, 0, 944, 912, 1, 0, 0, 0, 944, 918, 1, 0, 0,
		0, 944, 924, 1, 0, 0, 0, 944, 929, 1, 0, 0, 0, 944, 934, 1, 0, 0, 0, 944,
		939, 1, 0, 0, 0, 945, 51, 1, 0, 0, 0, 946, 950, 3, 68, 34, 0, 947, 951,
		5, 1145, 0, 0, 948, 949, 5, 1122, 0, 0, 949, 951, 3, 68, 34, 0, 950, 947,
		1, 0, 0, 0, 950, 948, 1, 0, 0, 0, 950, 951, 1, 0, 0, 0, 951, 53, 1, 0,
		0, 0, 952, 953, 3, 52, 26, 0, 953, 55, 1, 0, 0, 0, 954, 959, 3, 68, 34,
		0, 955, 957, 3, 72, 36, 0, 956, 958, 3, 72, 36, 0, 957, 956, 1, 0, 0, 0,
		957, 958, 1, 0, 0, 0, 958, 960, 1, 0, 0, 0, 959, 955, 1, 0, 0, 0, 959,
		960, 1, 0, 0, 0, 960, 967, 1, 0, 0, 0, 961, 962, 9, 0, 0, 0, 962, 964,
		3, 72, 36, 0, 963, 965, 3, 72, 36, 0, 964, 963, 1, 0, 0, 0, 964, 965, 1,
		0, 0, 0, 965, 967, 1, 0, 0, 0, 966, 954, 1, 0, 0, 0, 966, 961, 1, 0, 0,
		0, 967, 57, 1, 0, 0, 0, 968, 971, 3, 68, 34, 0, 969, 971, 5, 1138, 0, 0,
		970, 968, 1, 0, 0, 0, 970, 969, 1, 0, 0, 0, 971, 976, 1, 0, 0, 0, 972,
		973, 5, 1123, 0, 0, 973, 974, 3, 74, 37, 0, 974, 975, 5, 1124, 0, 0, 975,
		977, 1, 0, 0, 0, 976, 972, 1, 0, 0, 0, 976, 977, 1, 0, 0, 0, 977, 980,
		1, 0, 0, 0, 978, 980, 3, 114, 57, 0, 979, 970, 1, 0, 0, 0, 979, 978, 1,
		0, 0, 0, 980, 982, 1, 0, 0, 0, 981, 983, 7, 19, 0, 0, 982, 981, 1, 0, 0,
		0, 982, 983, 1, 0, 0, 0, 983, 59, 1, 0, 0, 0, 984, 985, 7, 20, 0, 0, 985,
		61, 1, 0, 0, 0, 986, 991, 5, 220, 0, 0, 987, 991, 3, 132, 66, 0, 988, 991,
		5, 1138, 0, 0, 989, 991, 5, 1135, 0, 0, 990, 986, 1, 0, 0, 0, 990, 987,
		1, 0, 0, 0, 990, 988, 1, 0, 0, 0, 990, 989, 1, 0, 0, 0, 991, 63, 1, 0,
		0, 0, 992, 995, 3, 68, 34, 0, 993, 995, 5, 1138, 0, 0, 994, 992, 1, 0,
		0, 0, 994, 993, 1, 0, 0, 0, 995, 65, 1, 0, 0, 0, 996, 997, 7, 21, 0, 0,
		997, 67, 1, 0, 0, 0, 998, 1002, 3, 70, 35, 0, 999, 1002, 5, 1147, 0, 0,
		1000, 1002, 5, 1135, 0, 0, 1001, 998, 1, 0, 0, 0, 1001, 999, 1, 0, 0, 0,
		1001, 1000, 1, 0, 0, 0, 1002, 69, 1, 0, 0, 0, 1003, 1013, 5, 1146, 0, 0,
		1004, 1013, 3, 132, 66, 0, 1005, 1013, 3, 134, 67, 0, 1006, 1013, 3, 66,
		33, 0, 1007, 1013, 3, 136, 68, 0, 1008, 1013, 3, 138, 69, 0, 1009, 1013,
		3, 140, 70, 0, 1010, 1013, 3, 142, 71, 0, 1011, 1013, 3, 112, 56, 0, 1012,
		1003, 1, 0, 0, 0, 1012, 1004, 1, 0, 0, 0, 1012, 1005, 1, 0, 0, 0, 1012,
		1006, 1, 0, 0, 0, 1012, 1007, 1, 0, 0, 0, 1012, 1008, 1, 0, 0, 0, 1012,
		1009, 1, 0, 0, 0, 1012, 1010, 1, 0, 0, 0, 1012, 1011, 1, 0, 0, 0, 1013,
		71, 1, 0, 0, 0, 1014, 1018, 5, 1145, 0, 0, 1015, 1016, 5, 1122, 0, 0, 1016,
		1018, 3, 68, 34, 0, 1017, 1014, 1, 0, 0, 0, 1017, 1015, 1, 0, 0, 0, 1018,
		73, 1, 0, 0, 0, 1019, 1020, 7, 22, 0, 0, 1020, 75, 1, 0, 0, 0, 1021, 1024,
		5, 1136, 0, 0, 1022, 1024, 3, 74, 37, 0, 1023, 1021, 1, 0, 0, 0, 1023,
		1022, 1, 0, 0, 0, 1024, 77, 1, 0, 0, 0, 1025, 1027, 5, 1144, 0, 0, 1026,
		1025, 1, 0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027, 1028, 1, 0, 0, 0, 1028,
		1031, 5, 1138, 0, 0, 1029, 1031, 5, 1137, 0, 0, 1030, 1026, 1, 0, 0, 0,
		1030, 1029, 1, 0, 0, 0, 1031, 1033, 1, 0, 0, 0, 1032, 1034, 5, 1138, 0,
		0, 1033, 1032, 1, 0, 0, 0, 1034, 1035, 1, 0, 0, 0, 1035, 1033, 1, 0, 0,
		0, 1035, 1036, 1, 0, 0, 0, 1036, 1049, 1, 0, 0, 0, 1037, 1039, 5, 1144,
		0, 0, 1038, 1037, 1, 0, 0, 0, 1038, 1039, 1, 0, 0, 0, 1039, 1040, 1, 0,
		0, 0, 1040, 1043, 5, 1138, 0, 0, 1041, 1043, 5, 1137, 0, 0, 1042, 1038,
		1, 0, 0, 0, 1042, 1041, 1, 0, 0, 0, 1043, 1046, 1, 0, 0, 0, 1044, 1045,
		5, 26, 0, 0, 1045, 1047, 3, 64, 32, 0, 1046, 1044, 1, 0, 0, 0, 1046, 1047,
		1, 0, 0, 0, 1047, 1049, 1, 0, 0, 0, 1048, 1030, 1, 0, 0, 0, 1048, 1042,
		1, 0, 0, 0, 1049, 79, 1, 0, 0, 0, 1050, 1051, 7, 23, 0, 0, 1051, 81, 1,
		0, 0, 0, 1052, 1054, 5, 1144, 0, 0, 1053, 1052, 1, 0, 0, 0, 1053, 1054,
		1, 0, 0, 0, 1054, 1055, 1, 0, 0, 0, 1055, 1056, 5, 1140, 0, 0, 1056, 83,
		1, 0, 0, 0, 1057, 1059, 5, 110, 0, 0, 1058, 1057, 1, 0, 0, 0, 1058, 1059,
		1, 0, 0, 0, 1059, 1060, 1, 0, 0, 0, 1060, 1061, 7, 24, 0, 0, 1061, 85,
		1, 0, 0, 0, 1062, 1075, 3, 78, 39, 0, 1063, 1075, 3, 74, 37, 0, 1064, 1065,
		5, 1111, 0, 0, 1065, 1075, 3, 74, 37, 0, 1066, 1075, 3, 82, 41, 0, 1067,
		1075, 3, 80, 40, 0, 1068, 1075, 5, 1141, 0, 0, 1069, 1075, 5, 1143, 0,
		0, 1070, 1072, 5, 110, 0, 0, 1071, 1070, 1, 0, 0, 0, 1071, 1072, 1, 0,
		0, 0, 1072, 1073, 1, 0, 0, 0, 1073, 1075, 7, 24, 0, 0, 1074, 1062, 1, 0,
		0, 0, 1074, 1063, 1, 0, 0, 0, 1074, 1064, 1, 0, 0, 0, 1074, 1066, 1, 0,
		0, 0, 1074, 1067, 1, 0, 0, 0, 1074, 1068, 1, 0, 0, 0, 1074, 1069, 1, 0,
		0, 0, 1074, 1071, 1, 0, 0, 0, 1075, 87, 1, 0, 0, 0, 1076, 1078, 7, 25,
		0, 0, 1077, 1079, 3, 94, 47, 0, 1078, 1077, 1, 0, 0, 0, 1078, 1079, 1,
		0, 0, 0, 1079, 1083, 1, 0, 0, 0, 1080, 1082, 7, 26, 0, 0, 1081, 1080, 1,
		0, 0, 0, 1082, 1085, 1, 0, 0, 0, 1083, 1081, 1, 0, 0, 0, 1083, 1084, 1,
		0, 0, 0, 1084, 1212, 1, 0, 0, 0, 1085, 1083, 1, 0, 0, 0, 1086, 1088, 7,
		27, 0, 0, 1087, 1089, 3, 98, 49, 0, 1088, 1087, 1, 0, 0, 0, 1088, 1089,
		1, 0, 0, 0, 1089, 1093, 1, 0, 0, 0, 1090, 1092, 7, 26, 0, 0, 1091, 1090,
		1, 0, 0, 0, 1092, 1095, 1, 0, 0, 0, 1093, 1091, 1, 0, 0, 0, 1093, 1094,
		1, 0, 0, 0, 1094, 1212, 1, 0, 0, 0, 1095, 1093, 1, 0, 0, 0, 1096, 1098,
		5, 203, 0, 0, 1097, 1099, 5, 204, 0, 0, 1098, 1097, 1, 0, 0, 0, 1098, 1099,
		1, 0, 0, 0, 1099, 1101, 1, 0, 0, 0, 1100, 1102, 3, 96, 48, 0, 1101, 1100,
		1, 0, 0, 0, 1101, 1102, 1, 0, 0, 0, 1102, 1106, 1, 0, 0, 0, 1103, 1105,
		7, 26, 0, 0, 1104, 1103, 1, 0, 0, 0, 1105, 1108, 1, 0, 0, 0, 1106, 1104,
		1, 0, 0, 0, 1106, 1107, 1, 0, 0, 0, 1107, 1212, 1, 0, 0, 0, 1108, 1106,
		1, 0, 0, 0, 1109, 1111, 5, 202, 0, 0, 1110, 1112, 3, 96, 48, 0, 1111, 1110,
		1, 0, 0, 0, 1111, 1112, 1, 0, 0, 0, 1112, 1116, 1, 0, 0, 0, 1113, 1115,
		7, 26, 0, 0, 1114, 1113, 1, 0, 0, 0, 1115, 1118, 1, 0, 0, 0, 1116, 1114,
		1, 0, 0, 0, 1116, 1117, 1, 0, 0, 0, 1117, 1212, 1, 0, 0, 0, 1118, 1116,
		1, 0, 0, 0, 1119, 1121, 7, 28, 0, 0, 1120, 1122, 3, 94, 47, 0, 1121, 1120,
		1, 0, 0, 0, 1121, 1122, 1, 0, 0, 0, 1122, 1212, 1, 0, 0, 0, 1123, 1212,
		5, 211, 0, 0, 1124, 1126, 7, 29, 0, 0, 1125, 1127, 5, 232, 0, 0, 1126,
		1125, 1, 0, 0, 0, 1126, 1127, 1, 0, 0, 0, 1127, 1129, 1, 0, 0, 0, 1128,
		1130, 3, 94, 47, 0, 1129, 1128, 1, 0, 0, 0, 1129, 1130, 1, 0, 0, 0, 1130,
		1132, 1, 0, 0, 0, 1131, 1133, 5, 220, 0, 0, 1132, 1131, 1, 0, 0, 0, 1132,
		1133, 1, 0, 0, 0, 1133, 1137, 1, 0, 0, 0, 1134, 1135, 3, 4, 2, 0, 1135,
		1136, 3, 62, 31, 0, 1136, 1138, 1, 0, 0, 0, 1137, 1134, 1, 0, 0, 0, 1137,
		1138, 1, 0, 0, 0, 1138, 1142, 1, 0, 0, 0, 1139, 1140, 5, 26, 0, 0, 1140,
		1143, 3, 64, 32, 0, 1141, 1143, 5, 220, 0, 0, 1142, 1139, 1, 0, 0, 0, 1142,
		1141, 1, 0, 0, 0, 1142, 1143, 1, 0, 0, 0, 1143, 1212, 1, 0, 0, 0, 1144,
		1145, 5, 219, 0, 0, 1145, 1147, 7, 30, 0, 0, 1146, 1148, 3, 94, 47, 0,
		1147, 1146, 1, 0, 0, 0, 1147, 1148, 1, 0, 0, 0, 1148, 1150, 1, 0, 0, 0,
		1149, 1151, 5, 220, 0, 0, 1150, 1149, 1, 0, 0, 0, 1150, 1151, 1, 0, 0,
		0, 1151, 1212, 1, 0, 0, 0, 1152, 1153, 5, 505, 0, 0, 1153, 1155, 5, 217,
		0, 0, 1154, 1156, 3, 94, 47, 0, 1155, 1154, 1, 0, 0, 0, 1155, 1156, 1,
		0, 0, 0, 1156, 1158, 1, 0, 0, 0, 1157, 1159, 5, 220, 0, 0, 1158, 1157,
		1, 0, 0, 0, 1158, 1159, 1, 0, 0, 0, 1159, 1212, 1, 0, 0, 0, 1160, 1161,
		5, 219, 0, 0, 1161, 1162, 7, 31, 0, 0, 1162, 1164, 5, 232, 0, 0, 1163,
		1165, 3, 94, 47, 0, 1164, 1163, 1, 0, 0, 0, 1164, 1165, 1, 0, 0, 0, 1165,
		1167, 1, 0, 0, 0, 1166, 1168, 5, 220, 0, 0, 1167, 1166, 1, 0, 0, 0, 1167,
		1168, 1, 0, 0, 0, 1168, 1212, 1, 0, 0, 0, 1169, 1171, 5, 225, 0, 0, 1170,
		1172, 5, 217, 0, 0, 1171, 1170, 1, 0, 0, 0, 1171, 1172, 1, 0, 0, 0, 1172,
		1174, 1, 0, 0, 0, 1173, 1175, 5, 220, 0, 0, 1174, 1173, 1, 0, 0, 0, 1174,
		1175, 1, 0, 0, 0, 1175, 1179, 1, 0, 0, 0, 1176, 1177, 3, 4, 2, 0, 1177,
		1178, 3, 62, 31, 0, 1178, 1180, 1, 0, 0, 0, 1179, 1176, 1, 0, 0, 0, 1179,
		1180, 1, 0, 0, 0, 1180, 1183, 1, 0, 0, 0, 1181, 1182, 5, 26, 0, 0, 1182,
		1184, 3, 64, 32, 0, 1183, 1181, 1, 0, 0, 0, 1183, 1184, 1, 0, 0, 0, 1184,
		1212, 1, 0, 0, 0, 1185, 1186, 5, 225, 0, 0, 1186, 1189, 5, 221, 0, 0, 1187,
		1189, 5, 453, 0, 0, 1188, 1185, 1, 0, 0, 0, 1188, 1187, 1, 0, 0, 0, 1189,
		1212, 1, 0, 0, 0, 1190, 1191, 7, 32, 0, 0, 1191, 1193, 3, 90, 45, 0, 1192,
		1194, 5, 220, 0, 0, 1193, 1192, 1, 0, 0, 0, 1193, 1194, 1, 0, 0, 0, 1194,
		1198, 1, 0, 0, 0, 1195, 1196, 3, 4, 2, 0, 1196, 1197, 3, 62, 31, 0, 1197,
		1199, 1, 0, 0, 0, 1198, 1195, 1, 0, 0, 0, 1198, 1199, 1, 0, 0, 0, 1199,
		1212, 1, 0, 0, 0, 1200, 1202, 7, 33, 0, 0, 1201, 1203, 3, 94, 47, 0, 1202,
		1201, 1, 0, 0, 0, 1202, 1203, 1, 0, 0, 0, 1203, 1212, 1, 0, 0, 0, 1204,
		1212, 7, 34, 0, 0, 1205, 1212, 7, 35, 0, 0, 1206, 1208, 7, 36, 0, 0, 1207,
		1209, 3, 94, 47, 0, 1208, 1207, 1, 0, 0, 0, 1208, 1209, 1, 0, 0, 0, 1209,
		1212, 1, 0, 0, 0, 1210, 1212, 7, 37, 0, 0, 1211, 1076, 1, 0, 0, 0, 1211,
		1086, 1, 0, 0, 0, 1211, 1096, 1, 0, 0, 0, 1211, 1109, 1, 0, 0, 0, 1211,
		1119, 1, 0, 0, 0, 1211, 1123, 1, 0, 0, 0, 1211, 1124, 1, 0, 0, 0, 1211,
		1144, 1, 0, 0, 0, 1211, 1152, 1, 0, 0, 0, 1211, 1160, 1, 0, 0, 0, 1211,
		1169, 1, 0, 0, 0, 1211, 1188, 1, 0, 0, 0, 1211, 1190, 1, 0, 0, 0, 1211,
		1200, 1, 0, 0, 0, 1211, 1204, 1, 0, 0, 0, 1211, 1205, 1, 0, 0, 0, 1211,
		1206, 1, 0, 0, 0, 1211, 1210, 1, 0, 0, 0, 1212, 89, 1, 0, 0, 0, 1213, 1214,
		5, 1123, 0, 0, 1214, 1219, 5, 1138, 0, 0, 1215, 1216, 5, 1125, 0, 0, 1216,
		1218, 5, 1138, 0, 0, 1217, 1215, 1, 0, 0, 0, 1218, 1221, 1, 0, 0, 0, 1219,
		1217, 1, 0, 0, 0, 1219, 1220, 1, 0, 0, 0, 1220, 1222, 1, 0, 0, 0, 1221,
		1219, 1, 0, 0, 0, 1222, 1223, 5, 1124, 0, 0, 1223, 91, 1, 0, 0, 0, 1224,
		1226, 7, 38, 0, 0, 1225, 1227, 3, 94, 47, 0, 1226, 1225, 1, 0, 0, 0, 1226,
		1227, 1, 0, 0, 0, 1227, 1247, 1, 0, 0, 0, 1228, 1230, 5, 216, 0, 0, 1229,
		1231, 3, 94, 47, 0, 1230, 1229, 1, 0, 0, 0, 1230, 1231, 1, 0, 0, 0, 1231,
		1235, 1, 0, 0, 0, 1232, 1233, 3, 4, 2, 0, 1233, 1234, 3, 62, 31, 0, 1234,
		1236, 1, 0, 0, 0, 1235, 1232, 1, 0, 0, 0, 1235, 1236, 1, 0, 0, 0, 1236,
		1247, 1, 0, 0, 0, 1237, 1247, 7, 39, 0, 0, 1238, 1240, 5, 208, 0, 0, 1239,
		1241, 3, 98, 49, 0, 1240, 1239, 1, 0, 0, 0, 1240, 1241, 1, 0, 0, 0, 1241,
		1247, 1, 0, 0, 0, 1242, 1244, 7, 40, 0, 0, 1243, 1245, 5, 200, 0, 0, 1244,
		1243, 1, 0, 0, 0, 1244, 1245, 1, 0, 0, 0, 1245, 1247, 1, 0, 0, 0, 1246,
		1224, 1, 0, 0, 0, 1246, 1228, 1, 0, 0, 0, 1246, 1237, 1, 0, 0, 0, 1246,
		1238, 1, 0, 0, 0, 1246, 1242, 1, 0, 0, 0, 1247, 1249, 1, 0, 0, 0, 1248,
		1250, 5, 11, 0, 0, 1249, 1248, 1, 0, 0, 0, 1249, 1250, 1, 0, 0, 0, 1250,
		93, 1, 0, 0, 0, 1251, 1252, 5, 1123, 0, 0, 1252, 1253, 3, 74, 37, 0, 1253,
		1254, 5, 1124, 0, 0, 1254, 95, 1, 0, 0, 0, 1255, 1256, 5, 1123, 0, 0, 1256,
		1257, 3, 74, 37, 0, 1257, 1258, 5, 1125, 0, 0, 1258, 1259, 3, 74, 37, 0,
		1259, 1260, 5, 1124, 0, 0, 1260, 97, 1, 0, 0, 0, 1261, 1262, 5, 1123, 0,
		0, 1262, 1265, 3, 74, 37, 0, 1263, 1264, 5, 1125, 0, 0, 1264, 1266, 3,
		74, 37, 0, 1265, 1263, 1, 0, 0, 0, 1265, 1266, 1, 0, 0, 0, 1266, 1267,
		1, 0, 0, 0, 1267, 1268, 5, 1124, 0, 0, 1268, 99, 1, 0, 0, 0, 1269, 1274,
		3, 68, 34, 0, 1270, 1271, 5, 1125, 0, 0, 1271, 1273, 3, 68, 34, 0, 1272,
		1270, 1, 0, 0, 0, 1273, 1276, 1, 0, 0, 0, 1274, 1272, 1, 0, 0, 0, 1274,
		1275, 1, 0, 0, 0, 1275, 101, 1, 0, 0, 0, 1276, 1274, 1, 0, 0, 0, 1277,
		1282, 3, 54, 27, 0, 1278, 1279, 5, 1125, 0, 0, 1279, 1281, 3, 54, 27, 0,
		1280, 1278, 1, 0, 0, 0, 1281, 1284, 1, 0, 0, 0, 1282, 1280, 1, 0, 0, 0,
		1282, 1283, 1, 0, 0, 0, 1283, 103, 1, 0, 0, 0, 1284, 1282, 1, 0, 0, 0,
		1285, 1286, 5, 1123, 0, 0, 1286, 1291, 3, 58, 29, 0, 1287, 1288, 5, 1125,
		0, 0, 1288, 1290, 3, 58, 29, 0, 1289, 1287, 1, 0, 0, 0, 1290, 1293, 1,
		0, 0, 0, 1291, 1289, 1, 0, 0, 0, 1291, 1292, 1, 0, 0, 0, 1292, 1294, 1,
		0, 0, 0, 1293, 1291, 1, 0, 0, 0, 1294, 1295, 5, 1124, 0, 0, 1295, 105,
		1, 0, 0, 0, 1296, 1337, 5, 112, 0, 0, 1297, 1298, 5, 22, 0, 0, 1298, 1299,
		5, 1123, 0, 0, 1299, 1300, 3, 114, 57, 0, 1300, 1301, 5, 12, 0, 0, 1301,
		1302, 3, 92, 46, 0, 1302, 1303, 5, 1124, 0, 0, 1303, 1337, 1, 0, 0, 0,
		1304, 1306, 3, 120, 60, 0, 1305, 1304, 1, 0, 0, 0, 1305, 1306, 1, 0, 0,
		0, 1306, 1307, 1, 0, 0, 0, 1307, 1337, 3, 86, 43, 0, 1308, 1312, 3, 108,
		54, 0, 1309, 1310, 5, 114, 0, 0, 1310, 1311, 5, 178, 0, 0, 1311, 1313,
		3, 108, 54, 0, 1312, 1309, 1, 0, 0, 0, 1312, 1313, 1, 0, 0, 0, 1313, 1337,
		1, 0, 0, 0, 1314, 1315, 5, 1123, 0, 0, 1315, 1316, 3, 114, 57, 0, 1316,
		1317, 5, 1124, 0, 0, 1317, 1337, 1, 0, 0, 0, 1318, 1319, 7, 41, 0, 0, 1319,
		1320, 5, 1123, 0, 0, 1320, 1321, 3, 52, 26, 0, 1321, 1322, 5, 1124, 0,
		0, 1322, 1337, 1, 0, 0, 0, 1323, 1324, 5, 1123, 0, 0, 1324, 1325, 7, 42,
		0, 0, 1325, 1326, 5, 652, 0, 0, 1326, 1327, 5, 62, 0, 0, 1327, 1328, 3,
		52, 26, 0, 1328, 1329, 5, 1124, 0, 0, 1329, 1337, 1, 0, 0, 0, 1330, 1337,
		3, 114, 57, 0, 1331, 1332, 5, 1123, 0, 0, 1332, 1333, 5, 246, 0, 0, 1333,
		1334, 5, 1123, 0, 0, 1334, 1335, 5, 1124, 0, 0, 1335, 1337, 5, 1124, 0,
		0, 1336, 1296, 1, 0, 0, 0, 1336, 1297, 1, 0, 0, 0, 1336, 1305, 1, 0, 0,
		0, 1336, 1308, 1, 0, 0, 0, 1336, 1314, 1, 0, 0, 0, 1336, 1318, 1, 0, 0,
		0, 1336, 1323, 1, 0, 0, 0, 1336, 1330, 1, 0, 0, 0, 1336, 1331, 1, 0, 0,
		0, 1337, 107, 1, 0, 0, 0, 1338, 1344, 7, 43, 0, 0, 1339, 1341, 5, 1123,
		0, 0, 1340, 1342, 3, 74, 37, 0, 1341, 1340, 1, 0, 0, 0, 1341, 1342, 1,
		0, 0, 0, 1342, 1343, 1, 0, 0, 0, 1343, 1345, 5, 1124, 0, 0, 1344, 1339,
		1, 0, 0, 0, 1344, 1345, 1, 0, 0, 0, 1345, 1353, 1, 0, 0, 0, 1346, 1347,
		5, 314, 0, 0, 1347, 1349, 5, 1123, 0, 0, 1348, 1350, 3, 74, 37, 0, 1349,
		1348, 1, 0, 0, 0, 1349, 1350, 1, 0, 0, 0, 1350, 1351, 1, 0, 0, 0, 1351,
		1353, 5, 1124, 0, 0, 1352, 1338, 1, 0, 0, 0, 1352, 1346, 1, 0, 0, 0, 1353,
		109, 1, 0, 0, 0, 1354, 1355, 5, 74, 0, 0, 1355, 1356, 5, 110, 0, 0, 1356,
		1357, 5, 57, 0, 0, 1357, 111, 1, 0, 0, 0, 1358, 1382, 3, 144, 72, 0, 1359,
		1382, 5, 727, 0, 0, 1360, 1382, 5, 308, 0, 0, 1361, 1382, 5, 304, 0, 0,
		1362, 1382, 5, 305, 0, 0, 1363, 1382, 5, 306, 0, 0, 1364, 1382, 5, 309,
		0, 0, 1365, 1382, 5, 310, 0, 0, 1366, 1382, 5, 311, 0, 0, 1367, 1382, 5,
		74, 0, 0, 1368, 1382, 5, 82, 0, 0, 1369, 1382, 5, 307, 0, 0, 1370, 1382,
		5, 313, 0, 0, 1371, 1382, 5, 495, 0, 0, 1372, 1382, 5, 314, 0, 0, 1373,
		1382, 5, 137, 0, 0, 1374, 1382, 5, 316, 0, 0, 1375, 1382, 5, 317, 0, 0,
		1376, 1382, 5, 318, 0, 0, 1377, 1382, 5, 319, 0, 0, 1378, 1382, 5, 320,
		0, 0, 1379, 1382, 5, 321, 0, 0, 1380, 1382, 5, 322, 0, 0, 1381, 1358, 1,
		0, 0, 0, 1381, 1359, 1, 0, 0, 0, 1381, 1360, 1, 0, 0, 0, 1381, 1361, 1,
		0, 0, 0, 1381, 1362, 1, 0, 0, 0, 1381, 1363, 1, 0, 0, 0, 1381, 1364, 1,
		0, 0, 0, 1381, 1365, 1, 0, 0, 0, 1381, 1366, 1, 0, 0, 0, 1381, 1367, 1,
		0, 0, 0, 1381, 1368, 1, 0, 0, 0, 1381, 1369, 1, 0, 0, 0, 1381, 1370, 1,
		0, 0, 0, 1381, 1371, 1, 0, 0, 0, 1381, 1372, 1, 0, 0, 0, 1381, 1373, 1,
		0, 0, 0, 1381, 1374, 1, 0, 0, 0, 1381, 1375, 1, 0, 0, 0, 1381, 1376, 1,
		0, 0, 0, 1381, 1377, 1, 0, 0, 0, 1381, 1378, 1, 0, 0, 0, 1381, 1379, 1,
		0, 0, 0, 1381, 1380, 1, 0, 0, 0, 1382, 113, 1, 0, 0, 0, 1383, 1384, 6,
		57, -1, 0, 1384, 1385, 7, 44, 0, 0, 1385, 1395, 3, 114, 57, 4, 1386, 1387,
		3, 116, 58, 0, 1387, 1389, 5, 85, 0, 0, 1388, 1390, 5, 110, 0, 0, 1389,
		1388, 1, 0, 0, 0, 1389, 1390, 1, 0, 0, 0, 1390, 1391, 1, 0, 0, 0, 1391,
		1392, 7, 45, 0, 0, 1392, 1395, 1, 0, 0, 0, 1393, 1395, 3, 116, 58, 0, 1394,
		1383, 1, 0, 0, 0, 1394, 1386, 1, 0, 0, 0, 1394, 1393, 1, 0, 0, 0, 1395,
		1402, 1, 0, 0, 0, 1396, 1397, 10, 3, 0, 0, 1397, 1398, 3, 124, 62, 0, 1398,
		1399, 3, 114, 57, 4, 1399, 1401, 1, 0, 0, 0, 1400, 1396, 1, 0, 0, 0, 1401,
		1404, 1, 0, 0, 0, 1402, 1400, 1, 0, 0, 0, 1402, 1403, 1, 0, 0, 0, 1403,
		115, 1, 0, 0, 0, 1404, 1402, 1, 0, 0, 0, 1405, 1408, 6, 58, -1, 0, 1406,
		1407, 5, 1151, 0, 0, 1407, 1409, 5, 1098, 0, 0, 1408, 1406, 1, 0, 0, 0,
		1408, 1409, 1, 0, 0, 0, 1409, 1410, 1, 0, 0, 0, 1410, 1411, 3, 118, 59,
		0, 1411, 1457, 1, 0, 0, 0, 1412, 1413, 10, 7, 0, 0, 1413, 1414, 3, 122,
		61, 0, 1414, 1415, 3, 116, 58, 8, 1415, 1456, 1, 0, 0, 0, 1416, 1418, 10,
		6, 0, 0, 1417, 1419, 5, 110, 0, 0, 1418, 1417, 1, 0, 0, 0, 1418, 1419,
		1, 0, 0, 0, 1419, 1420, 1, 0, 0, 0, 1420, 1421, 5, 15, 0, 0, 1421, 1422,
		3, 116, 58, 0, 1422, 1423, 5, 10, 0, 0, 1423, 1424, 3, 116, 58, 7, 1424,
		1456, 1, 0, 0, 0, 1425, 1426, 10, 5, 0, 0, 1426, 1427, 5, 603, 0, 0, 1427,
		1428, 5, 94, 0, 0, 1428, 1456, 3, 116, 58, 6, 1429, 1431, 10, 3, 0, 0,
		1430, 1432, 5, 110, 0, 0, 1431, 1430, 1, 0, 0, 0, 1431, 1432, 1, 0, 0,
		0, 1432, 1433, 1, 0, 0, 0, 1433, 1434, 7, 46, 0, 0, 1434, 1456, 3, 116,
		58, 4, 1435, 1436, 10, 8, 0, 0, 1436, 1437, 5, 85, 0, 0, 1437, 1456, 3,
		84, 42, 0, 1438, 1440, 10, 4, 0, 0, 1439, 1441, 5, 110, 0, 0, 1440, 1439,
		1, 0, 0, 0, 1440, 1441, 1, 0, 0, 0, 1441, 1442, 1, 0, 0, 0, 1442, 1443,
		5, 94, 0, 0, 1443, 1446, 3, 116, 58, 0, 1444, 1445, 5, 402, 0, 0, 1445,
		1447, 5, 1138, 0, 0, 1446, 1444, 1, 0, 0, 0, 1446, 1447, 1, 0, 0, 0, 1447,
		1456, 1, 0, 0, 0, 1448, 1449, 10, 1, 0, 0, 1449, 1450, 5, 492, 0, 0, 1450,
		1451, 5, 520, 0, 0, 1451, 1452, 5, 1123, 0, 0, 1452, 1453, 3, 116, 58,
		0, 1453, 1454, 5, 1124, 0, 0, 1454, 1456, 1, 0, 0, 0, 1455, 1412, 1, 0,
		0, 0, 1455, 1416, 1, 0, 0, 0, 1455, 1425, 1, 0, 0, 0, 1455, 1429, 1, 0,
		0, 0, 1455, 1435, 1, 0, 0, 0, 1455, 1438, 1, 0, 0, 0, 1455, 1448, 1, 0,
		0, 0, 1456, 1459, 1, 0, 0, 0, 1457, 1455, 1, 0, 0, 0, 1457, 1458, 1, 0,
		0, 0, 1458, 117, 1, 0, 0, 0, 1459, 1457, 1, 0, 0, 0, 1460, 1461, 6, 59,
		-1, 0, 1461, 1496, 3, 86, 43, 0, 1462, 1496, 3, 56, 28, 0, 1463, 1496,
		3, 60, 30, 0, 1464, 1465, 3, 120, 60, 0, 1465, 1466, 3, 118, 59, 8, 1466,
		1496, 1, 0, 0, 0, 1467, 1468, 5, 220, 0, 0, 1468, 1496, 3, 118, 59, 7,
		1469, 1470, 5, 1123, 0, 0, 1470, 1475, 3, 114, 57, 0, 1471, 1472, 5, 1125,
		0, 0, 1472, 1474, 3, 114, 57, 0, 1473, 1471, 1, 0, 0, 0, 1474, 1477, 1,
		0, 0, 0, 1475, 1473, 1, 0, 0, 0, 1475, 1476, 1, 0, 0, 0, 1476, 1478, 1,
		0, 0, 0, 1477, 1475, 1, 0, 0, 0, 1478, 1479, 5, 1124, 0, 0, 1479, 1496,
		1, 0, 0, 0, 1480, 1481, 5, 583, 0, 0, 1481, 1482, 5, 1123, 0, 0, 1482,
		1485, 3, 114, 57, 0, 1483, 1484, 5, 1125, 0, 0, 1484, 1486, 3, 114, 57,
		0, 1485, 1483, 1, 0, 0, 0, 1486, 1487, 1, 0, 0, 0, 1487, 1485, 1, 0, 0,
		0, 1487, 1488, 1, 0, 0, 0, 1488, 1489, 1, 0, 0, 0, 1489, 1490, 5, 1124,
		0, 0, 1490, 1496, 1, 0, 0, 0, 1491, 1492, 5, 83, 0, 0, 1492, 1493, 3, 114,
		57, 0, 1493, 1494, 3, 6, 3, 0, 1494, 1496, 1, 0, 0, 0, 1495, 1460, 1, 0,
		0, 0, 1495, 1462, 1, 0, 0, 0, 1495, 1463, 1, 0, 0, 0, 1495, 1464, 1, 0,
		0, 0, 1495, 1467, 1, 0, 0, 0, 1495, 1469, 1, 0, 0, 0, 1495, 1480, 1, 0,
		0, 0, 1495, 1491, 1, 0, 0, 0, 1496, 1514, 1, 0, 0, 0, 1497, 1498, 10, 3,
		0, 0, 1498, 1499, 3, 126, 63, 0, 1499, 1500, 3, 118, 59, 4, 1500, 1513,
		1, 0, 0, 0, 1501, 1502, 10, 2, 0, 0, 1502, 1503, 3, 128, 64, 0, 1503, 1504,
		3, 118, 59, 3, 1504, 1513, 1, 0, 0, 0, 1505, 1506, 10, 1, 0, 0, 1506, 1507,
		3, 130, 65, 0, 1507, 1508, 3, 118, 59, 2, 1508, 1513, 1, 0, 0, 0, 1509,
		1510, 10, 10, 0, 0, 1510, 1511, 5, 26, 0, 0, 1511, 1513, 3, 64, 32, 0,
		1512, 1497, 1, 0, 0, 0, 1512, 1501, 1, 0, 0, 0, 1512, 1505, 1, 0, 0, 0,
		1512, 1509, 1, 0, 0, 0, 1513, 1516, 1, 0, 0, 0, 1514, 1512, 1, 0, 0, 0,
		1514, 1515, 1, 0, 0, 0, 1515, 119, 1, 0, 0, 0, 1516, 1514, 1, 0, 0, 0,
		1517, 1518, 7, 47, 0, 0, 1518, 121, 1, 0, 0, 0, 1519, 1534, 5, 1114, 0,
		0, 1520, 1534, 5, 1115, 0, 0, 1521, 1534, 5, 1116, 0, 0, 1522, 1523, 5,
		1116, 0, 0, 1523, 1534, 5, 1114, 0, 0, 1524, 1525, 5, 1115, 0, 0, 1525,
		1534, 5, 1114, 0, 0, 1526, 1527, 5, 1116, 0, 0, 1527, 1534, 5, 1115, 0,
		0, 1528, 1529, 5, 1117, 0, 0, 1529, 1534, 5, 1114, 0, 0, 1530, 1531, 5,
		1116, 0, 0, 1531, 1532, 5, 1114, 0, 0, 1532, 1534, 5, 1115, 0, 0, 1533,
		1519, 1, 0, 0, 0, 1533, 1520, 1, 0, 0, 0, 1533, 1521, 1, 0, 0, 0, 1533,
		1522, 1, 0, 0, 0, 1533, 1524, 1, 0, 0, 0, 1533, 1526, 1, 0, 0, 0, 1533,
		1528, 1, 0, 0, 0, 1533, 1530, 1, 0, 0, 0, 1534, 123, 1, 0, 0, 0, 1535,
		1543, 5, 10, 0, 0, 1536, 1537, 5, 1120, 0, 0, 1537, 1543, 5, 1120, 0, 0,
		1538, 1543, 5, 188, 0, 0, 1539, 1543, 5, 119, 0, 0, 1540, 1541, 5, 1119,
		0, 0, 1541, 1543, 5, 1119, 0, 0, 1542, 1535, 1, 0, 0, 0, 1542, 1536, 1,
		0, 0, 0, 1542, 1538, 1, 0, 0, 0, 1542, 1539, 1, 0, 0, 0, 1542, 1540, 1,
		0, 0, 0, 1543, 125, 1, 0, 0, 0, 1544, 1545, 5, 1116, 0, 0, 1545, 1552,
		5, 1116, 0, 0, 1546, 1547, 5, 1115, 0, 0, 1547, 1552, 5, 1115, 0, 0, 1548,
		1552, 5, 1120, 0, 0, 1549, 1552, 5, 1121, 0, 0, 1550, 1552, 5, 1119, 0,
		0, 1551, 1544, 1, 0, 0, 0, 1551, 1546, 1, 0, 0, 0, 1551, 1548, 1, 0, 0,
		0, 1551, 1549, 1, 0, 0, 0, 1551, 1550, 1, 0, 0, 0, 1552, 127, 1, 0, 0,
		0, 1553, 1554, 7, 48, 0, 0, 1554, 129, 1, 0, 0, 0, 1555, 1556, 5, 1111,
		0, 0, 1556, 1561, 5, 1115, 0, 0, 1557, 1558, 5, 1111, 0, 0, 1558, 1559,
		5, 1115, 0, 0, 1559, 1561, 5, 1115, 0, 0, 1560, 1555, 1, 0, 0, 0, 1560,
		1557, 1, 0, 0, 0, 1561, 131, 1, 0, 0, 0, 1562, 1563, 7, 49, 0, 0, 1563,
		133, 1, 0, 0, 0, 1564, 1565, 7, 50, 0, 0, 1565, 135, 1, 0, 0, 0, 1566,
		1567, 7, 51, 0, 0, 1567, 137, 1, 0, 0, 0, 1568, 1569, 7, 52, 0, 0, 1569,
		139, 1, 0, 0, 0, 1570, 1571, 7, 53, 0, 0, 1571, 141, 1, 0, 0, 0, 1572,
		1573, 7, 54, 0, 0, 1573, 143, 1, 0, 0, 0, 1574, 1575, 7, 55, 0, 0, 1575,
		145, 1, 0, 0, 0, 234, 148, 155, 158, 162, 168, 173, 176, 179, 186, 201,
		208, 220, 225, 234, 236, 244, 254, 260, 272, 275, 280, 293, 300, 307, 309,
		316, 320, 322, 327, 330, 336, 341, 343, 347, 350, 353, 359, 364, 366, 371,
		378, 380, 387, 392, 396, 399, 407, 415, 417, 425, 429, 432, 438, 443, 446,
		452, 455, 459, 462, 466, 471, 476, 481, 485, 489, 493, 497, 501, 505, 510,
		515, 520, 526, 531, 536, 542, 547, 552, 557, 562, 567, 572, 577, 584, 589,
		594, 599, 605, 613, 619, 631, 638, 640, 648, 653, 656, 664, 670, 686, 698,
		700, 703, 711, 717, 723, 736, 743, 752, 757, 768, 777, 782, 794, 801, 810,
		815, 827, 834, 843, 848, 855, 864, 869, 871, 876, 884, 893, 897, 900, 904,
		909, 915, 921, 926, 931, 936, 941, 944, 950, 957, 959, 964, 966, 970, 976,
		979, 982, 990, 994, 1001, 1012, 1017, 1023, 1026, 1030, 1035, 1038, 1042,
		1046, 1048, 1053, 1058, 1071, 1074, 1078, 1083, 1088, 1093, 1098, 1101,
		1106, 1111, 1116, 1121, 1126, 1129, 1132, 1137, 1142, 1147, 1150, 1155,
		1158, 1164, 1167, 1171, 1174, 1179, 1183, 1188, 1193, 1198, 1202, 1208,
		1211, 1219, 1226, 1230, 1235, 1240, 1244, 1246, 1249, 1265, 1274, 1282,
		1291, 1305, 1312, 1336, 1341, 1344, 1349, 1352, 1381, 1389, 1394, 1402,
		1408, 1418, 1431, 1440, 1446, 1455, 1457, 1475, 1487, 1495, 1512, 1514,
		1533, 1542, 1551, 1560,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// StmtParserInit initializes any static state used to implement StmtParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewStmtParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func StmtParserInit() {
	staticData := &StmtParserParserStaticData
	staticData.once.Do(stmtparserParserInit)
}

// NewStmtParser produces a new parser instance for the optional input antlr.TokenStream.
func NewStmtParser(input antlr.TokenStream) *StmtParser {
	StmtParserInit()
	this := new(StmtParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &StmtParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "StmtParser.g4"

	return this
}

// StmtParser tokens.
const (
	StmtParserEOF                               = antlr.TokenEOF
	StmtParserSPACE                             = 1
	StmtParserSPEC_MYSQL_COMMENT                = 2
	StmtParserCOMMENT_INPUT                     = 3
	StmtParserLINE_COMMENT                      = 4
	StmtParserADD                               = 5
	StmtParserALL                               = 6
	StmtParserALTER                             = 7
	StmtParserALWAYS                            = 8
	StmtParserANALYZE                           = 9
	StmtParserAND                               = 10
	StmtParserARRAY                             = 11
	StmtParserAS                                = 12
	StmtParserASC                               = 13
	StmtParserBEFORE                            = 14
	StmtParserBETWEEN                           = 15
	StmtParserBOTH                              = 16
	StmtParserBUCKETS                           = 17
	StmtParserBY                                = 18
	StmtParserCALL                              = 19
	StmtParserCASCADE                           = 20
	StmtParserCASE                              = 21
	StmtParserCAST                              = 22
	StmtParserCHANGE                            = 23
	StmtParserCHARACTER                         = 24
	StmtParserCHECK                             = 25
	StmtParserCOLLATE                           = 26
	StmtParserCOLUMN                            = 27
	StmtParserCONDITION                         = 28
	StmtParserCONSTRAINT                        = 29
	StmtParserCONTINUE                          = 30
	StmtParserCONVERT                           = 31
	StmtParserCREATE                            = 32
	StmtParserCROSS                             = 33
	StmtParserCURRENT                           = 34
	StmtParserCURRENT_USER                      = 35
	StmtParserCURSOR                            = 36
	StmtParserDATABASE                          = 37
	StmtParserDATABASES                         = 38
	StmtParserDECLARE                           = 39
	StmtParserDEFAULT                           = 40
	StmtParserDELAYED                           = 41
	StmtParserDELETE                            = 42
	StmtParserDESC                              = 43
	StmtParserDESCRIBE                          = 44
	StmtParserDETERMINISTIC                     = 45
	StmtParserDIAGNOSTICS                       = 46
	StmtParserDISTINCT                          = 47
	StmtParserDISTINCTROW                       = 48
	StmtParserDROP                              = 49
	StmtParserEACH                              = 50
	StmtParserELSE                              = 51
	StmtParserELSEIF                            = 52
	StmtParserEMPTY                             = 53
	StmtParserENCLOSED                          = 54
	StmtParserESCAPED                           = 55
	StmtParserEXCEPT                            = 56
	StmtParserEXISTS                            = 57
	StmtParserEXIT                              = 58
	StmtParserEXPLAIN                           = 59
	StmtParserFALSE                             = 60
	StmtParserFETCH                             = 61
	StmtParserFOR                               = 62
	StmtParserFORCE                             = 63
	StmtParserFOREIGN                           = 64
	StmtParserFROM                              = 65
	StmtParserFULLTEXT                          = 66
	StmtParserGENERATED                         = 67
	StmtParserGET                               = 68
	StmtParserGRANT                             = 69
	StmtParserGROUP                             = 70
	StmtParserHAVING                            = 71
	StmtParserHIGH_PRIORITY                     = 72
	StmtParserHISTOGRAM                         = 73
	StmtParserIF                                = 74
	StmtParserIGNORE                            = 75
	StmtParserIGNORED                           = 76
	StmtParserIN                                = 77
	StmtParserINDEX                             = 78
	StmtParserINFILE                            = 79
	StmtParserINNER                             = 80
	StmtParserINOUT                             = 81
	StmtParserINSERT                            = 82
	StmtParserINTERVAL                          = 83
	StmtParserINTO                              = 84
	StmtParserIS                                = 85
	StmtParserITERATE                           = 86
	StmtParserJOIN                              = 87
	StmtParserKEY                               = 88
	StmtParserKEYS                              = 89
	StmtParserKILL                              = 90
	StmtParserLEADING                           = 91
	StmtParserLEAVE                             = 92
	StmtParserLEFT                              = 93
	StmtParserLIKE                              = 94
	StmtParserLIMIT                             = 95
	StmtParserLINEAR                            = 96
	StmtParserLINES                             = 97
	StmtParserLOAD                              = 98
	StmtParserLOCK                              = 99
	StmtParserLOCKED                            = 100
	StmtParserLOOP                              = 101
	StmtParserLOW_PRIORITY                      = 102
	StmtParserMASTER_BIND                       = 103
	StmtParserMASTER_SSL_VERIFY_SERVER_CERT     = 104
	StmtParserMATCH                             = 105
	StmtParserMAXVALUE                          = 106
	StmtParserMINVALUE                          = 107
	StmtParserMODIFIES                          = 108
	StmtParserNATURAL                           = 109
	StmtParserNOT                               = 110
	StmtParserNO_WRITE_TO_BINLOG                = 111
	StmtParserNULL_LITERAL                      = 112
	StmtParserNUMBER                            = 113
	StmtParserON                                = 114
	StmtParserOPTIMIZE                          = 115
	StmtParserOPTION                            = 116
	StmtParserOPTIONAL                          = 117
	StmtParserOPTIONALLY                        = 118
	StmtParserOR                                = 119
	StmtParserORDER                             = 120
	StmtParserOUT                               = 121
	StmtParserOVER                              = 122
	StmtParserOUTER                             = 123
	StmtParserOUTFILE                           = 124
	StmtParserPARTITION                         = 125
	StmtParserPRIMARY                           = 126
	StmtParserPROCEDURE                         = 127
	StmtParserPURGE                             = 128
	StmtParserRANGE                             = 129
	StmtParserREAD                              = 130
	StmtParserREADS                             = 131
	StmtParserREFERENCES                        = 132
	StmtParserREGEXP                            = 133
	StmtParserRELEASE                           = 134
	StmtParserRENAME                            = 135
	StmtParserREPEAT                            = 136
	StmtParserREPLACE                           = 137
	StmtParserREQUIRE                           = 138
	StmtParserRESIGNAL                          = 139
	StmtParserRESTRICT                          = 140
	StmtParserRETAIN                            = 141
	StmtParserRETURN                            = 142
	StmtParserREVOKE                            = 143
	StmtParserRIGHT                             = 144
	StmtParserRLIKE                             = 145
	StmtParserSCHEMA                            = 146
	StmtParserSCHEMAS                           = 147
	StmtParserSELECT                            = 148
	StmtParserSET                               = 149
	StmtParserSEPARATOR                         = 150
	StmtParserSHOW                              = 151
	StmtParserSIGNAL                            = 152
	StmtParserSKIP_                             = 153
	StmtParserSPATIAL                           = 154
	StmtParserSQL                               = 155
	StmtParserSQLEXCEPTION                      = 156
	StmtParserSQLSTATE                          = 157
	StmtParserSQLWARNING                        = 158
	StmtParserSQL_BIG_RESULT                    = 159
	StmtParserSQL_CALC_FOUND_ROWS               = 160
	StmtParserSQL_SMALL_RESULT                  = 161
	StmtParserSSL                               = 162
	StmtParserSTACKED                           = 163
	StmtParserSTARTING                          = 164
	StmtParserSTRAIGHT_JOIN                     = 165
	StmtParserTABLE                             = 166
	StmtParserTERMINATED                        = 167
	StmtParserTHEN                              = 168
	StmtParserTO                                = 169
	StmtParserTRAILING                          = 170
	StmtParserTRIGGER                           = 171
	StmtParserTRUE                              = 172
	StmtParserUNDO                              = 173
	StmtParserUNION                             = 174
	StmtParserUNIQUE                            = 175
	StmtParserUNLOCK                            = 176
	StmtParserUNSIGNED                          = 177
	StmtParserUPDATE                            = 178
	StmtParserUSAGE                             = 179
	StmtParserUSE                               = 180
	StmtParserUSING                             = 181
	StmtParserVALUES                            = 182
	StmtParserWHEN                              = 183
	StmtParserWHERE                             = 184
	StmtParserWHILE                             = 185
	StmtParserWITH                              = 186
	StmtParserWRITE                             = 187
	StmtParserXOR                               = 188
	StmtParserZEROFILL                          = 189
	StmtParserTINYINT                           = 190
	StmtParserSMALLINT                          = 191
	StmtParserMEDIUMINT                         = 192
	StmtParserMIDDLEINT                         = 193
	StmtParserINT                               = 194
	StmtParserINT1                              = 195
	StmtParserINT2                              = 196
	StmtParserINT3                              = 197
	StmtParserINT4                              = 198
	StmtParserINT8                              = 199
	StmtParserINTEGER                           = 200
	StmtParserBIGINT                            = 201
	StmtParserREAL                              = 202
	StmtParserDOUBLE                            = 203
	StmtParserPRECISION                         = 204
	StmtParserFLOAT                             = 205
	StmtParserFLOAT4                            = 206
	StmtParserFLOAT8                            = 207
	StmtParserDECIMAL                           = 208
	StmtParserDEC                               = 209
	StmtParserNUMERIC                           = 210
	StmtParserDATE                              = 211
	StmtParserTIME                              = 212
	StmtParserTIMESTAMP                         = 213
	StmtParserDATETIME                          = 214
	StmtParserYEAR                              = 215
	StmtParserCHAR                              = 216
	StmtParserVARCHAR                           = 217
	StmtParserNVARCHAR                          = 218
	StmtParserNATIONAL                          = 219
	StmtParserBINARY                            = 220
	StmtParserVARBINARY                         = 221
	StmtParserTINYBLOB                          = 222
	StmtParserBLOB                              = 223
	StmtParserMEDIUMBLOB                        = 224
	StmtParserLONG                              = 225
	StmtParserLONGBLOB                          = 226
	StmtParserTINYTEXT                          = 227
	StmtParserTEXT                              = 228
	StmtParserMEDIUMTEXT                        = 229
	StmtParserLONGTEXT                          = 230
	StmtParserENUM                              = 231
	StmtParserVARYING                           = 232
	StmtParserSERIAL                            = 233
	StmtParserYEAR_MONTH                        = 234
	StmtParserDAY_HOUR                          = 235
	StmtParserDAY_MINUTE                        = 236
	StmtParserDAY_SECOND                        = 237
	StmtParserHOUR_MINUTE                       = 238
	StmtParserHOUR_SECOND                       = 239
	StmtParserMINUTE_SECOND                     = 240
	StmtParserSECOND_MICROSECOND                = 241
	StmtParserMINUTE_MICROSECOND                = 242
	StmtParserHOUR_MICROSECOND                  = 243
	StmtParserDAY_MICROSECOND                   = 244
	StmtParserJSON_ARRAY                        = 245
	StmtParserJSON_OBJECT                       = 246
	StmtParserJSON_QUOTE                        = 247
	StmtParserJSON_CONTAINS                     = 248
	StmtParserJSON_CONTAINS_PATH                = 249
	StmtParserJSON_EXTRACT                      = 250
	StmtParserJSON_KEYS                         = 251
	StmtParserJSON_OVERLAPS                     = 252
	StmtParserJSON_SEARCH                       = 253
	StmtParserJSON_VALUE                        = 254
	StmtParserJSON_ARRAY_APPEND                 = 255
	StmtParserJSON_ARRAY_INSERT                 = 256
	StmtParserJSON_INSERT                       = 257
	StmtParserJSON_MERGE                        = 258
	StmtParserJSON_MERGE_PATCH                  = 259
	StmtParserJSON_MERGE_PRESERVE               = 260
	StmtParserJSON_REMOVE                       = 261
	StmtParserJSON_REPLACE                      = 262
	StmtParserJSON_SET                          = 263
	StmtParserJSON_UNQUOTE                      = 264
	StmtParserJSON_DEPTH                        = 265
	StmtParserJSON_LENGTH                       = 266
	StmtParserJSON_TYPE                         = 267
	StmtParserJSON_VALID                        = 268
	StmtParserJSON_TABLE                        = 269
	StmtParserJSON_SCHEMA_VALID                 = 270
	StmtParserJSON_SCHEMA_VALIDATION_REPORT     = 271
	StmtParserJSON_PRETTY                       = 272
	StmtParserJSON_STORAGE_FREE                 = 273
	StmtParserJSON_STORAGE_SIZE                 = 274
	StmtParserJSON_ARRAYAGG                     = 275
	StmtParserJSON_OBJECTAGG                    = 276
	StmtParserAVG                               = 277
	StmtParserBIT_AND                           = 278
	StmtParserBIT_OR                            = 279
	StmtParserBIT_XOR                           = 280
	StmtParserCOUNT                             = 281
	StmtParserCUME_DIST                         = 282
	StmtParserDENSE_RANK                        = 283
	StmtParserFIRST_VALUE                       = 284
	StmtParserGROUP_CONCAT                      = 285
	StmtParserLAG                               = 286
	StmtParserLAST_VALUE                        = 287
	StmtParserLEAD                              = 288
	StmtParserMAX                               = 289
	StmtParserMIN                               = 290
	StmtParserNTILE                             = 291
	StmtParserNTH_VALUE                         = 292
	StmtParserPERCENT_RANK                      = 293
	StmtParserRANK                              = 294
	StmtParserROW_NUMBER                        = 295
	StmtParserSTD                               = 296
	StmtParserSTDDEV                            = 297
	StmtParserSTDDEV_POP                        = 298
	StmtParserSTDDEV_SAMP                       = 299
	StmtParserSUM                               = 300
	StmtParserVAR_POP                           = 301
	StmtParserVAR_SAMP                          = 302
	StmtParserVARIANCE                          = 303
	StmtParserCURRENT_DATE                      = 304
	StmtParserCURRENT_TIME                      = 305
	StmtParserCURRENT_TIMESTAMP                 = 306
	StmtParserLOCALTIME                         = 307
	StmtParserCURDATE                           = 308
	StmtParserCURTIME                           = 309
	StmtParserDATE_ADD                          = 310
	StmtParserDATE_SUB                          = 311
	StmtParserEXTRACT                           = 312
	StmtParserLOCALTIMESTAMP                    = 313
	StmtParserNOW                               = 314
	StmtParserPOSITION                          = 315
	StmtParserSUBSTR                            = 316
	StmtParserSUBSTRING                         = 317
	StmtParserSYSDATE                           = 318
	StmtParserTRIM                              = 319
	StmtParserUTC_DATE                          = 320
	StmtParserUTC_TIME                          = 321
	StmtParserUTC_TIMESTAMP                     = 322
	StmtParserACCOUNT                           = 323
	StmtParserACTION                            = 324
	StmtParserAFTER                             = 325
	StmtParserAGGREGATE                         = 326
	StmtParserALGORITHM                         = 327
	StmtParserANY                               = 328
	StmtParserAT                                = 329
	StmtParserAUTHORS                           = 330
	StmtParserAUTOCOMMIT                        = 331
	StmtParserAUTOEXTEND_SIZE                   = 332
	StmtParserAUTO_INCREMENT                    = 333
	StmtParserAVG_ROW_LENGTH                    = 334
	StmtParserBEGIN                             = 335
	StmtParserBINLOG                            = 336
	StmtParserBIT                               = 337
	StmtParserBLOCK                             = 338
	StmtParserBOOL                              = 339
	StmtParserBOOLEAN                           = 340
	StmtParserBTREE                             = 341
	StmtParserCACHE                             = 342
	StmtParserCASCADED                          = 343
	StmtParserCHAIN                             = 344
	StmtParserCHANGED                           = 345
	StmtParserCHANNEL                           = 346
	StmtParserCHECKSUM                          = 347
	StmtParserPAGE_CHECKSUM                     = 348
	StmtParserCIPHER                            = 349
	StmtParserCLASS_ORIGIN                      = 350
	StmtParserCLIENT                            = 351
	StmtParserCLOSE                             = 352
	StmtParserCLUSTERING                        = 353
	StmtParserCOALESCE                          = 354
	StmtParserCODE                              = 355
	StmtParserCOLUMNS                           = 356
	StmtParserCOLUMN_FORMAT                     = 357
	StmtParserCOLUMN_NAME                       = 358
	StmtParserCOMMENT                           = 359
	StmtParserCOMMIT                            = 360
	StmtParserCOMPACT                           = 361
	StmtParserCOMPLETION                        = 362
	StmtParserCOMPRESSED                        = 363
	StmtParserCOMPRESSION                       = 364
	StmtParserCONCURRENT                        = 365
	StmtParserCONNECT                           = 366
	StmtParserCONNECTION                        = 367
	StmtParserCONSISTENT                        = 368
	StmtParserCONSTRAINT_CATALOG                = 369
	StmtParserCONSTRAINT_SCHEMA                 = 370
	StmtParserCONSTRAINT_NAME                   = 371
	StmtParserCONTAINS                          = 372
	StmtParserCONTEXT                           = 373
	StmtParserCONTRIBUTORS                      = 374
	StmtParserCOPY                              = 375
	StmtParserCPU                               = 376
	StmtParserCYCLE                             = 377
	StmtParserCURSOR_NAME                       = 378
	StmtParserDATA                              = 379
	StmtParserDATAFILE                          = 380
	StmtParserDEALLOCATE                        = 381
	StmtParserDEFAULT_AUTH                      = 382
	StmtParserDEFINER                           = 383
	StmtParserDELAY_KEY_WRITE                   = 384
	StmtParserDES_KEY_FILE                      = 385
	StmtParserDIRECTORY                         = 386
	StmtParserDISABLE                           = 387
	StmtParserDISCARD                           = 388
	StmtParserDISK                              = 389
	StmtParserDO                                = 390
	StmtParserDUMPFILE                          = 391
	StmtParserDUPLICATE                         = 392
	StmtParserDYNAMIC                           = 393
	StmtParserENABLE                            = 394
	StmtParserENCRYPTION                        = 395
	StmtParserEND                               = 396
	StmtParserENDS                              = 397
	StmtParserENGINE                            = 398
	StmtParserENGINES                           = 399
	StmtParserERROR                             = 400
	StmtParserERRORS                            = 401
	StmtParserESCAPE                            = 402
	StmtParserEVEN                              = 403
	StmtParserEVENT                             = 404
	StmtParserEVENTS                            = 405
	StmtParserEVERY                             = 406
	StmtParserEXCHANGE                          = 407
	StmtParserEXCLUSIVE                         = 408
	StmtParserEXPIRE                            = 409
	StmtParserEXPORT                            = 410
	StmtParserEXTENDED                          = 411
	StmtParserEXTENT_SIZE                       = 412
	StmtParserFAST                              = 413
	StmtParserFAULTS                            = 414
	StmtParserFIELDS                            = 415
	StmtParserFILE_BLOCK_SIZE                   = 416
	StmtParserFILTER                            = 417
	StmtParserFIRST                             = 418
	StmtParserFIXED                             = 419
	StmtParserFLUSH                             = 420
	StmtParserFOLLOWING                         = 421
	StmtParserFOLLOWS                           = 422
	StmtParserFOUND                             = 423
	StmtParserFULL                              = 424
	StmtParserFUNCTION                          = 425
	StmtParserGENERAL                           = 426
	StmtParserGLOBAL                            = 427
	StmtParserGRANTS                            = 428
	StmtParserGROUP_REPLICATION                 = 429
	StmtParserHANDLER                           = 430
	StmtParserHASH                              = 431
	StmtParserHELP                              = 432
	StmtParserHOST                              = 433
	StmtParserHOSTS                             = 434
	StmtParserIDENTIFIED                        = 435
	StmtParserIGNORE_SERVER_IDS                 = 436
	StmtParserIMPORT                            = 437
	StmtParserINCREMENT                         = 438
	StmtParserINDEXES                           = 439
	StmtParserINITIAL_SIZE                      = 440
	StmtParserINPLACE                           = 441
	StmtParserINSERT_METHOD                     = 442
	StmtParserINSTALL                           = 443
	StmtParserINSTANCE                          = 444
	StmtParserINSTANT                           = 445
	StmtParserINVISIBLE                         = 446
	StmtParserINVOKER                           = 447
	StmtParserIO                                = 448
	StmtParserIO_THREAD                         = 449
	StmtParserIPC                               = 450
	StmtParserISOLATION                         = 451
	StmtParserISSUER                            = 452
	StmtParserJSON                              = 453
	StmtParserKEY_BLOCK_SIZE                    = 454
	StmtParserLANGUAGE                          = 455
	StmtParserLAST                              = 456
	StmtParserLEAVES                            = 457
	StmtParserLESS                              = 458
	StmtParserLEVEL                             = 459
	StmtParserLIST                              = 460
	StmtParserLOCAL                             = 461
	StmtParserLOGFILE                           = 462
	StmtParserLOGS                              = 463
	StmtParserMASTER                            = 464
	StmtParserMASTER_AUTO_POSITION              = 465
	StmtParserMASTER_CONNECT_RETRY              = 466
	StmtParserMASTER_DELAY                      = 467
	StmtParserMASTER_HEARTBEAT_PERIOD           = 468
	StmtParserMASTER_HOST                       = 469
	StmtParserMASTER_LOG_FILE                   = 470
	StmtParserMASTER_LOG_POS                    = 471
	StmtParserMASTER_PASSWORD                   = 472
	StmtParserMASTER_PORT                       = 473
	StmtParserMASTER_RETRY_COUNT                = 474
	StmtParserMASTER_SSL                        = 475
	StmtParserMASTER_SSL_CA                     = 476
	StmtParserMASTER_SSL_CAPATH                 = 477
	StmtParserMASTER_SSL_CERT                   = 478
	StmtParserMASTER_SSL_CIPHER                 = 479
	StmtParserMASTER_SSL_CRL                    = 480
	StmtParserMASTER_SSL_CRLPATH                = 481
	StmtParserMASTER_SSL_KEY                    = 482
	StmtParserMASTER_TLS_VERSION                = 483
	StmtParserMASTER_USER                       = 484
	StmtParserMAX_CONNECTIONS_PER_HOUR          = 485
	StmtParserMAX_QUERIES_PER_HOUR              = 486
	StmtParserMAX_ROWS                          = 487
	StmtParserMAX_SIZE                          = 488
	StmtParserMAX_UPDATES_PER_HOUR              = 489
	StmtParserMAX_USER_CONNECTIONS              = 490
	StmtParserMEDIUM                            = 491
	StmtParserMEMBER                            = 492
	StmtParserMERGE                             = 493
	StmtParserMESSAGE_TEXT                      = 494
	StmtParserMID                               = 495
	StmtParserMIGRATE                           = 496
	StmtParserMIN_ROWS                          = 497
	StmtParserMODE                              = 498
	StmtParserMODIFY                            = 499
	StmtParserMUTEX                             = 500
	StmtParserMYSQL                             = 501
	StmtParserMYSQL_ERRNO                       = 502
	StmtParserNAME                              = 503
	StmtParserNAMES                             = 504
	StmtParserNCHAR                             = 505
	StmtParserNEVER                             = 506
	StmtParserNEXT                              = 507
	StmtParserNO                                = 508
	StmtParserNOCACHE                           = 509
	StmtParserNOCOPY                            = 510
	StmtParserNOCYCLE                           = 511
	StmtParserNOMAXVALUE                        = 512
	StmtParserNOMINVALUE                        = 513
	StmtParserNOWAIT                            = 514
	StmtParserNODEGROUP                         = 515
	StmtParserNONE                              = 516
	StmtParserODBC                              = 517
	StmtParserOFFLINE                           = 518
	StmtParserOFFSET                            = 519
	StmtParserOF                                = 520
	StmtParserOJ                                = 521
	StmtParserOLD_PASSWORD                      = 522
	StmtParserONE                               = 523
	StmtParserONLINE                            = 524
	StmtParserONLY                              = 525
	StmtParserOPEN                              = 526
	StmtParserOPTIMIZER_COSTS                   = 527
	StmtParserOPTIONS                           = 528
	StmtParserOWNER                             = 529
	StmtParserPACK_KEYS                         = 530
	StmtParserPAGE                              = 531
	StmtParserPARSER                            = 532
	StmtParserPARTIAL                           = 533
	StmtParserPARTITIONING                      = 534
	StmtParserPARTITIONS                        = 535
	StmtParserPASSWORD                          = 536
	StmtParserPHASE                             = 537
	StmtParserPLUGIN                            = 538
	StmtParserPLUGIN_DIR                        = 539
	StmtParserPLUGINS                           = 540
	StmtParserPORT                              = 541
	StmtParserPRECEDES                          = 542
	StmtParserPRECEDING                         = 543
	StmtParserPREPARE                           = 544
	StmtParserPRESERVE                          = 545
	StmtParserPREV                              = 546
	StmtParserPROCESSLIST                       = 547
	StmtParserPROFILE                           = 548
	StmtParserPROFILES                          = 549
	StmtParserPROXY                             = 550
	StmtParserQUERY                             = 551
	StmtParserQUICK                             = 552
	StmtParserREBUILD                           = 553
	StmtParserRECOVER                           = 554
	StmtParserRECURSIVE                         = 555
	StmtParserREDO_BUFFER_SIZE                  = 556
	StmtParserREDUNDANT                         = 557
	StmtParserRELAY                             = 558
	StmtParserRELAY_LOG_FILE                    = 559
	StmtParserRELAY_LOG_POS                     = 560
	StmtParserRELAYLOG                          = 561
	StmtParserREMOVE                            = 562
	StmtParserREORGANIZE                        = 563
	StmtParserREPAIR                            = 564
	StmtParserREPLICATE_DO_DB                   = 565
	StmtParserREPLICATE_DO_TABLE                = 566
	StmtParserREPLICATE_IGNORE_DB               = 567
	StmtParserREPLICATE_IGNORE_TABLE            = 568
	StmtParserREPLICATE_REWRITE_DB              = 569
	StmtParserREPLICATE_WILD_DO_TABLE           = 570
	StmtParserREPLICATE_WILD_IGNORE_TABLE       = 571
	StmtParserREPLICATION                       = 572
	StmtParserRESET                             = 573
	StmtParserRESTART                           = 574
	StmtParserRESUME                            = 575
	StmtParserRETURNED_SQLSTATE                 = 576
	StmtParserRETURNING                         = 577
	StmtParserRETURNS                           = 578
	StmtParserROLE                              = 579
	StmtParserROLLBACK                          = 580
	StmtParserROLLUP                            = 581
	StmtParserROTATE                            = 582
	StmtParserROW                               = 583
	StmtParserROWS                              = 584
	StmtParserROW_FORMAT                        = 585
	StmtParserRTREE                             = 586
	StmtParserSAVEPOINT                         = 587
	StmtParserSCHEDULE                          = 588
	StmtParserSECURITY                          = 589
	StmtParserSEQUENCE                          = 590
	StmtParserSERVER                            = 591
	StmtParserSESSION                           = 592
	StmtParserSHARE                             = 593
	StmtParserSHARED                            = 594
	StmtParserSIGNED                            = 595
	StmtParserSIMPLE                            = 596
	StmtParserSLAVE                             = 597
	StmtParserSLOW                              = 598
	StmtParserSNAPSHOT                          = 599
	StmtParserSOCKET                            = 600
	StmtParserSOME                              = 601
	StmtParserSONAME                            = 602
	StmtParserSOUNDS                            = 603
	StmtParserSOURCE                            = 604
	StmtParserSQL_AFTER_GTIDS                   = 605
	StmtParserSQL_AFTER_MTS_GAPS                = 606
	StmtParserSQL_BEFORE_GTIDS                  = 607
	StmtParserSQL_BUFFER_RESULT                 = 608
	StmtParserSQL_CACHE                         = 609
	StmtParserSQL_NO_CACHE                      = 610
	StmtParserSQL_THREAD                        = 611
	StmtParserSTART                             = 612
	StmtParserSTARTS                            = 613
	StmtParserSTATS_AUTO_RECALC                 = 614
	StmtParserSTATS_PERSISTENT                  = 615
	StmtParserSTATS_SAMPLE_PAGES                = 616
	StmtParserSTATUS                            = 617
	StmtParserSTOP                              = 618
	StmtParserSTORAGE                           = 619
	StmtParserSTORED                            = 620
	StmtParserSTRING                            = 621
	StmtParserSUBCLASS_ORIGIN                   = 622
	StmtParserSUBJECT                           = 623
	StmtParserSUBPARTITION                      = 624
	StmtParserSUBPARTITIONS                     = 625
	StmtParserSUSPEND                           = 626
	StmtParserSWAPS                             = 627
	StmtParserSWITCHES                          = 628
	StmtParserTABLE_NAME                        = 629
	StmtParserTABLESPACE                        = 630
	StmtParserTABLE_TYPE                        = 631
	StmtParserTEMPORARY                         = 632
	StmtParserTEMPTABLE                         = 633
	StmtParserTHAN                              = 634
	StmtParserTRADITIONAL                       = 635
	StmtParserTRANSACTION                       = 636
	StmtParserTRANSACTIONAL                     = 637
	StmtParserTRIGGERS                          = 638
	StmtParserTRUNCATE                          = 639
	StmtParserUNBOUNDED                         = 640
	StmtParserUNDEFINED                         = 641
	StmtParserUNDOFILE                          = 642
	StmtParserUNDO_BUFFER_SIZE                  = 643
	StmtParserUNINSTALL                         = 644
	StmtParserUNKNOWN                           = 645
	StmtParserUNTIL                             = 646
	StmtParserUPGRADE                           = 647
	StmtParserUSER                              = 648
	StmtParserUSE_FRM                           = 649
	StmtParserUSER_RESOURCES                    = 650
	StmtParserVALIDATION                        = 651
	StmtParserVALUE                             = 652
	StmtParserVARIABLES                         = 653
	StmtParserVIEW                              = 654
	StmtParserVIRTUAL                           = 655
	StmtParserVISIBLE                           = 656
	StmtParserWAIT                              = 657
	StmtParserWARNINGS                          = 658
	StmtParserWINDOW                            = 659
	StmtParserWITHOUT                           = 660
	StmtParserWORK                              = 661
	StmtParserWRAPPER                           = 662
	StmtParserX509                              = 663
	StmtParserXA                                = 664
	StmtParserXML                               = 665
	StmtParserYES                               = 666
	StmtParserEUR                               = 667
	StmtParserUSA                               = 668
	StmtParserJIS                               = 669
	StmtParserISO                               = 670
	StmtParserINTERNAL                          = 671
	StmtParserQUARTER                           = 672
	StmtParserMONTH                             = 673
	StmtParserDAY                               = 674
	StmtParserHOUR                              = 675
	StmtParserMINUTE                            = 676
	StmtParserWEEK                              = 677
	StmtParserSECOND                            = 678
	StmtParserMICROSECOND                       = 679
	StmtParserTABLES                            = 680
	StmtParserROUTINE                           = 681
	StmtParserEXECUTE                           = 682
	StmtParserFILE                              = 683
	StmtParserPROCESS                           = 684
	StmtParserRELOAD                            = 685
	StmtParserSHUTDOWN                          = 686
	StmtParserSUPER                             = 687
	StmtParserPRIVILEGES                        = 688
	StmtParserAPPLICATION_PASSWORD_ADMIN        = 689
	StmtParserAUDIT_ADMIN                       = 690
	StmtParserBACKUP_ADMIN                      = 691
	StmtParserBINLOG_ADMIN                      = 692
	StmtParserBINLOG_ENCRYPTION_ADMIN           = 693
	StmtParserCLONE_ADMIN                       = 694
	StmtParserCONNECTION_ADMIN                  = 695
	StmtParserENCRYPTION_KEY_ADMIN              = 696
	StmtParserFIREWALL_ADMIN                    = 697
	StmtParserFIREWALL_USER                     = 698
	StmtParserFLUSH_OPTIMIZER_COSTS             = 699
	StmtParserFLUSH_STATUS                      = 700
	StmtParserFLUSH_TABLES                      = 701
	StmtParserFLUSH_USER_RESOURCES              = 702
	StmtParserADMIN                             = 703
	StmtParserGROUP_REPLICATION_ADMIN           = 704
	StmtParserINNODB_REDO_LOG_ARCHIVE           = 705
	StmtParserINNODB_REDO_LOG_ENABLE            = 706
	StmtParserINVOKE                            = 707
	StmtParserLAMBDA                            = 708
	StmtParserNDB_STORED_USER                   = 709
	StmtParserPASSWORDLESS_USER_ADMIN           = 710
	StmtParserPERSIST_RO_VARIABLES_ADMIN        = 711
	StmtParserREPLICATION_APPLIER               = 712
	StmtParserREPLICATION_SLAVE_ADMIN           = 713
	StmtParserRESOURCE_GROUP_ADMIN              = 714
	StmtParserRESOURCE_GROUP_USER               = 715
	StmtParserROLE_ADMIN                        = 716
	StmtParserS3                                = 717
	StmtParserSERVICE_CONNECTION_ADMIN          = 718
	StmtParserSESSION_VARIABLES_ADMIN           = 719
	StmtParserSET_USER_ID                       = 720
	StmtParserSHOW_ROUTINE                      = 721
	StmtParserSYSTEM_VARIABLES_ADMIN            = 722
	StmtParserTABLE_ENCRYPTION_ADMIN            = 723
	StmtParserVERSION_TOKEN_ADMIN               = 724
	StmtParserXA_RECOVER_ADMIN                  = 725
	StmtParserARMSCII8                          = 726
	StmtParserASCII                             = 727
	StmtParserBIG5                              = 728
	StmtParserCP1250                            = 729
	StmtParserCP1251                            = 730
	StmtParserCP1256                            = 731
	StmtParserCP1257                            = 732
	StmtParserCP850                             = 733
	StmtParserCP852                             = 734
	StmtParserCP866                             = 735
	StmtParserCP932                             = 736
	StmtParserDEC8                              = 737
	StmtParserEUCJPMS                           = 738
	StmtParserEUCKR                             = 739
	StmtParserGB18030                           = 740
	StmtParserGB2312                            = 741
	StmtParserGBK                               = 742
	StmtParserGEOSTD8                           = 743
	StmtParserGREEK                             = 744
	StmtParserHEBREW                            = 745
	StmtParserHP8                               = 746
	StmtParserKEYBCS2                           = 747
	StmtParserKOI8R                             = 748
	StmtParserKOI8U                             = 749
	StmtParserLATIN1                            = 750
	StmtParserLATIN2                            = 751
	StmtParserLATIN5                            = 752
	StmtParserLATIN7                            = 753
	StmtParserMACCE                             = 754
	StmtParserMACROMAN                          = 755
	StmtParserSJIS                              = 756
	StmtParserSWE7                              = 757
	StmtParserTIS620                            = 758
	StmtParserUCS2                              = 759
	StmtParserUJIS                              = 760
	StmtParserUTF16                             = 761
	StmtParserUTF16LE                           = 762
	StmtParserUTF32                             = 763
	StmtParserUTF8                              = 764
	StmtParserUTF8MB3                           = 765
	StmtParserUTF8MB4                           = 766
	StmtParserARCHIVE                           = 767
	StmtParserBLACKHOLE                         = 768
	StmtParserCSV                               = 769
	StmtParserFEDERATED                         = 770
	StmtParserINNODB                            = 771
	StmtParserMEMORY                            = 772
	StmtParserMRG_MYISAM                        = 773
	StmtParserMYISAM                            = 774
	StmtParserNDB                               = 775
	StmtParserNDBCLUSTER                        = 776
	StmtParserPERFORMANCE_SCHEMA                = 777
	StmtParserTOKUDB                            = 778
	StmtParserREPEATABLE                        = 779
	StmtParserCOMMITTED                         = 780
	StmtParserUNCOMMITTED                       = 781
	StmtParserSERIALIZABLE                      = 782
	StmtParserGEOMETRYCOLLECTION                = 783
	StmtParserGEOMCOLLECTION                    = 784
	StmtParserGEOMETRY                          = 785
	StmtParserLINESTRING                        = 786
	StmtParserMULTILINESTRING                   = 787
	StmtParserMULTIPOINT                        = 788
	StmtParserMULTIPOLYGON                      = 789
	StmtParserPOINT                             = 790
	StmtParserPOLYGON                           = 791
	StmtParserABS                               = 792
	StmtParserACOS                              = 793
	StmtParserADDDATE                           = 794
	StmtParserADDTIME                           = 795
	StmtParserAES_DECRYPT                       = 796
	StmtParserAES_ENCRYPT                       = 797
	StmtParserAREA                              = 798
	StmtParserASBINARY                          = 799
	StmtParserASIN                              = 800
	StmtParserASTEXT                            = 801
	StmtParserASWKB                             = 802
	StmtParserASWKT                             = 803
	StmtParserASYMMETRIC_DECRYPT                = 804
	StmtParserASYMMETRIC_DERIVE                 = 805
	StmtParserASYMMETRIC_ENCRYPT                = 806
	StmtParserASYMMETRIC_SIGN                   = 807
	StmtParserASYMMETRIC_VERIFY                 = 808
	StmtParserATAN                              = 809
	StmtParserATAN2                             = 810
	StmtParserBENCHMARK                         = 811
	StmtParserBIN                               = 812
	StmtParserBIT_COUNT                         = 813
	StmtParserBIT_LENGTH                        = 814
	StmtParserBUFFER                            = 815
	StmtParserCATALOG_NAME                      = 816
	StmtParserCEIL                              = 817
	StmtParserCEILING                           = 818
	StmtParserCENTROID                          = 819
	StmtParserCHARACTER_LENGTH                  = 820
	StmtParserCHARSET                           = 821
	StmtParserCHAR_LENGTH                       = 822
	StmtParserCOERCIBILITY                      = 823
	StmtParserCOLLATION                         = 824
	StmtParserCOMPRESS                          = 825
	StmtParserCONCAT                            = 826
	StmtParserCONCAT_WS                         = 827
	StmtParserCONNECTION_ID                     = 828
	StmtParserCONV                              = 829
	StmtParserCONVERT_TZ                        = 830
	StmtParserCOS                               = 831
	StmtParserCOT                               = 832
	StmtParserCRC32                             = 833
	StmtParserCREATE_ASYMMETRIC_PRIV_KEY        = 834
	StmtParserCREATE_ASYMMETRIC_PUB_KEY         = 835
	StmtParserCREATE_DH_PARAMETERS              = 836
	StmtParserCREATE_DIGEST                     = 837
	StmtParserCROSSES                           = 838
	StmtParserDATEDIFF                          = 839
	StmtParserDATE_FORMAT                       = 840
	StmtParserDAYNAME                           = 841
	StmtParserDAYOFMONTH                        = 842
	StmtParserDAYOFWEEK                         = 843
	StmtParserDAYOFYEAR                         = 844
	StmtParserDECODE                            = 845
	StmtParserDEGREES                           = 846
	StmtParserDES_DECRYPT                       = 847
	StmtParserDES_ENCRYPT                       = 848
	StmtParserDIMENSION                         = 849
	StmtParserDISJOINT                          = 850
	StmtParserELT                               = 851
	StmtParserENCODE                            = 852
	StmtParserENCRYPT                           = 853
	StmtParserENDPOINT                          = 854
	StmtParserENGINE_ATTRIBUTE                  = 855
	StmtParserENVELOPE                          = 856
	StmtParserEQUALS                            = 857
	StmtParserEXP                               = 858
	StmtParserEXPORT_SET                        = 859
	StmtParserEXTERIORRING                      = 860
	StmtParserEXTRACTVALUE                      = 861
	StmtParserFIELD                             = 862
	StmtParserFIND_IN_SET                       = 863
	StmtParserFLOOR                             = 864
	StmtParserFORMAT                            = 865
	StmtParserFOUND_ROWS                        = 866
	StmtParserFROM_BASE64                       = 867
	StmtParserFROM_DAYS                         = 868
	StmtParserFROM_UNIXTIME                     = 869
	StmtParserGEOMCOLLFROMTEXT                  = 870
	StmtParserGEOMCOLLFROMWKB                   = 871
	StmtParserGEOMETRYCOLLECTIONFROMTEXT        = 872
	StmtParserGEOMETRYCOLLECTIONFROMWKB         = 873
	StmtParserGEOMETRYFROMTEXT                  = 874
	StmtParserGEOMETRYFROMWKB                   = 875
	StmtParserGEOMETRYN                         = 876
	StmtParserGEOMETRYTYPE                      = 877
	StmtParserGEOMFROMTEXT                      = 878
	StmtParserGEOMFROMWKB                       = 879
	StmtParserGET_FORMAT                        = 880
	StmtParserGET_LOCK                          = 881
	StmtParserGLENGTH                           = 882
	StmtParserGREATEST                          = 883
	StmtParserGTID_SUBSET                       = 884
	StmtParserGTID_SUBTRACT                     = 885
	StmtParserHEX                               = 886
	StmtParserIFNULL                            = 887
	StmtParserINET6_ATON                        = 888
	StmtParserINET6_NTOA                        = 889
	StmtParserINET_ATON                         = 890
	StmtParserINET_NTOA                         = 891
	StmtParserINSTR                             = 892
	StmtParserINTERIORRINGN                     = 893
	StmtParserINTERSECTS                        = 894
	StmtParserISCLOSED                          = 895
	StmtParserISEMPTY                           = 896
	StmtParserISNULL                            = 897
	StmtParserISSIMPLE                          = 898
	StmtParserIS_FREE_LOCK                      = 899
	StmtParserIS_IPV4                           = 900
	StmtParserIS_IPV4_COMPAT                    = 901
	StmtParserIS_IPV4_MAPPED                    = 902
	StmtParserIS_IPV6                           = 903
	StmtParserIS_USED_LOCK                      = 904
	StmtParserLAST_INSERT_ID                    = 905
	StmtParserLCASE                             = 906
	StmtParserLEAST                             = 907
	StmtParserLENGTH                            = 908
	StmtParserLINEFROMTEXT                      = 909
	StmtParserLINEFROMWKB                       = 910
	StmtParserLINESTRINGFROMTEXT                = 911
	StmtParserLINESTRINGFROMWKB                 = 912
	StmtParserLN                                = 913
	StmtParserLOAD_FILE                         = 914
	StmtParserLOCATE                            = 915
	StmtParserLOG                               = 916
	StmtParserLOG10                             = 917
	StmtParserLOG2                              = 918
	StmtParserLOWER                             = 919
	StmtParserLPAD                              = 920
	StmtParserLTRIM                             = 921
	StmtParserMAKEDATE                          = 922
	StmtParserMAKETIME                          = 923
	StmtParserMAKE_SET                          = 924
	StmtParserMASTER_POS_WAIT                   = 925
	StmtParserMBRCONTAINS                       = 926
	StmtParserMBRDISJOINT                       = 927
	StmtParserMBREQUAL                          = 928
	StmtParserMBRINTERSECTS                     = 929
	StmtParserMBROVERLAPS                       = 930
	StmtParserMBRTOUCHES                        = 931
	StmtParserMBRWITHIN                         = 932
	StmtParserMD5                               = 933
	StmtParserMLINEFROMTEXT                     = 934
	StmtParserMLINEFROMWKB                      = 935
	StmtParserMONTHNAME                         = 936
	StmtParserMPOINTFROMTEXT                    = 937
	StmtParserMPOINTFROMWKB                     = 938
	StmtParserMPOLYFROMTEXT                     = 939
	StmtParserMPOLYFROMWKB                      = 940
	StmtParserMULTILINESTRINGFROMTEXT           = 941
	StmtParserMULTILINESTRINGFROMWKB            = 942
	StmtParserMULTIPOINTFROMTEXT                = 943
	StmtParserMULTIPOINTFROMWKB                 = 944
	StmtParserMULTIPOLYGONFROMTEXT              = 945
	StmtParserMULTIPOLYGONFROMWKB               = 946
	StmtParserNAME_CONST                        = 947
	StmtParserNULLIF                            = 948
	StmtParserNUMGEOMETRIES                     = 949
	StmtParserNUMINTERIORRINGS                  = 950
	StmtParserNUMPOINTS                         = 951
	StmtParserOCT                               = 952
	StmtParserOCTET_LENGTH                      = 953
	StmtParserORD                               = 954
	StmtParserOVERLAPS                          = 955
	StmtParserPERIOD_ADD                        = 956
	StmtParserPERIOD_DIFF                       = 957
	StmtParserPI                                = 958
	StmtParserPOINTFROMTEXT                     = 959
	StmtParserPOINTFROMWKB                      = 960
	StmtParserPOINTN                            = 961
	StmtParserPOLYFROMTEXT                      = 962
	StmtParserPOLYFROMWKB                       = 963
	StmtParserPOLYGONFROMTEXT                   = 964
	StmtParserPOLYGONFROMWKB                    = 965
	StmtParserPOW                               = 966
	StmtParserPOWER                             = 967
	StmtParserQUOTE                             = 968
	StmtParserRADIANS                           = 969
	StmtParserRAND                              = 970
	StmtParserRANDOM_BYTES                      = 971
	StmtParserRELEASE_LOCK                      = 972
	StmtParserREVERSE                           = 973
	StmtParserROUND                             = 974
	StmtParserROW_COUNT                         = 975
	StmtParserRPAD                              = 976
	StmtParserRTRIM                             = 977
	StmtParserSEC_TO_TIME                       = 978
	StmtParserSECONDARY_ENGINE_ATTRIBUTE        = 979
	StmtParserSESSION_USER                      = 980
	StmtParserSHA                               = 981
	StmtParserSHA1                              = 982
	StmtParserSHA2                              = 983
	StmtParserSCHEMA_NAME                       = 984
	StmtParserSIGN                              = 985
	StmtParserSIN                               = 986
	StmtParserSLEEP                             = 987
	StmtParserSOUNDEX                           = 988
	StmtParserSQL_THREAD_WAIT_AFTER_GTIDS       = 989
	StmtParserSQRT                              = 990
	StmtParserSRID                              = 991
	StmtParserSTARTPOINT                        = 992
	StmtParserSTRCMP                            = 993
	StmtParserSTR_TO_DATE                       = 994
	StmtParserST_AREA                           = 995
	StmtParserST_ASBINARY                       = 996
	StmtParserST_ASTEXT                         = 997
	StmtParserST_ASWKB                          = 998
	StmtParserST_ASWKT                          = 999
	StmtParserST_BUFFER                         = 1000
	StmtParserST_CENTROID                       = 1001
	StmtParserST_CONTAINS                       = 1002
	StmtParserST_CROSSES                        = 1003
	StmtParserST_DIFFERENCE                     = 1004
	StmtParserST_DIMENSION                      = 1005
	StmtParserST_DISJOINT                       = 1006
	StmtParserST_DISTANCE                       = 1007
	StmtParserST_ENDPOINT                       = 1008
	StmtParserST_ENVELOPE                       = 1009
	StmtParserST_EQUALS                         = 1010
	StmtParserST_EXTERIORRING                   = 1011
	StmtParserST_GEOMCOLLFROMTEXT               = 1012
	StmtParserST_GEOMCOLLFROMTXT                = 1013
	StmtParserST_GEOMCOLLFROMWKB                = 1014
	StmtParserST_GEOMETRYCOLLECTIONFROMTEXT     = 1015
	StmtParserST_GEOMETRYCOLLECTIONFROMWKB      = 1016
	StmtParserST_GEOMETRYFROMTEXT               = 1017
	StmtParserST_GEOMETRYFROMWKB                = 1018
	StmtParserST_GEOMETRYN                      = 1019
	StmtParserST_GEOMETRYTYPE                   = 1020
	StmtParserST_GEOMFROMTEXT                   = 1021
	StmtParserST_GEOMFROMWKB                    = 1022
	StmtParserST_INTERIORRINGN                  = 1023
	StmtParserST_INTERSECTION                   = 1024
	StmtParserST_INTERSECTS                     = 1025
	StmtParserST_ISCLOSED                       = 1026
	StmtParserST_ISEMPTY                        = 1027
	StmtParserST_ISSIMPLE                       = 1028
	StmtParserST_LINEFROMTEXT                   = 1029
	StmtParserST_LINEFROMWKB                    = 1030
	StmtParserST_LINESTRINGFROMTEXT             = 1031
	StmtParserST_LINESTRINGFROMWKB              = 1032
	StmtParserST_NUMGEOMETRIES                  = 1033
	StmtParserST_NUMINTERIORRING                = 1034
	StmtParserST_NUMINTERIORRINGS               = 1035
	StmtParserST_NUMPOINTS                      = 1036
	StmtParserST_OVERLAPS                       = 1037
	StmtParserST_POINTFROMTEXT                  = 1038
	StmtParserST_POINTFROMWKB                   = 1039
	StmtParserST_POINTN                         = 1040
	StmtParserST_POLYFROMTEXT                   = 1041
	StmtParserST_POLYFROMWKB                    = 1042
	StmtParserST_POLYGONFROMTEXT                = 1043
	StmtParserST_POLYGONFROMWKB                 = 1044
	StmtParserST_SRID                           = 1045
	StmtParserST_STARTPOINT                     = 1046
	StmtParserST_SYMDIFFERENCE                  = 1047
	StmtParserST_TOUCHES                        = 1048
	StmtParserST_UNION                          = 1049
	StmtParserST_WITHIN                         = 1050
	StmtParserST_X                              = 1051
	StmtParserST_Y                              = 1052
	StmtParserSUBDATE                           = 1053
	StmtParserSUBSTRING_INDEX                   = 1054
	StmtParserSUBTIME                           = 1055
	StmtParserSYSTEM_USER                       = 1056
	StmtParserTAN                               = 1057
	StmtParserTIMEDIFF                          = 1058
	StmtParserTIMESTAMPADD                      = 1059
	StmtParserTIMESTAMPDIFF                     = 1060
	StmtParserTIME_FORMAT                       = 1061
	StmtParserTIME_TO_SEC                       = 1062
	StmtParserTOUCHES                           = 1063
	StmtParserTO_BASE64                         = 1064
	StmtParserTO_DAYS                           = 1065
	StmtParserTO_SECONDS                        = 1066
	StmtParserUCASE                             = 1067
	StmtParserUNCOMPRESS                        = 1068
	StmtParserUNCOMPRESSED_LENGTH               = 1069
	StmtParserUNHEX                             = 1070
	StmtParserUNIX_TIMESTAMP                    = 1071
	StmtParserUPDATEXML                         = 1072
	StmtParserUPPER                             = 1073
	StmtParserUUID                              = 1074
	StmtParserUUID_SHORT                        = 1075
	StmtParserVALIDATE_PASSWORD_STRENGTH        = 1076
	StmtParserVERSION                           = 1077
	StmtParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS = 1078
	StmtParserWEEKDAY                           = 1079
	StmtParserWEEKOFYEAR                        = 1080
	StmtParserWEIGHT_STRING                     = 1081
	StmtParserWITHIN                            = 1082
	StmtParserYEARWEEK                          = 1083
	StmtParserY_FUNCTION                        = 1084
	StmtParserX_FUNCTION                        = 1085
	StmtParserVIA                               = 1086
	StmtParserLASTVAL                           = 1087
	StmtParserNEXTVAL                           = 1088
	StmtParserSETVAL                            = 1089
	StmtParserPREVIOUS                          = 1090
	StmtParserPERSISTENT                        = 1091
	StmtParserBINLOG_MONITOR                    = 1092
	StmtParserBINLOG_REPLAY                     = 1093
	StmtParserFEDERATED_ADMIN                   = 1094
	StmtParserREAD_ONLY_ADMIN                   = 1095
	StmtParserREPLICA                           = 1096
	StmtParserREPLICATION_MASTER_ADMIN          = 1097
	StmtParserVAR_ASSIGN                        = 1098
	StmtParserPLUS_ASSIGN                       = 1099
	StmtParserMINUS_ASSIGN                      = 1100
	StmtParserMULT_ASSIGN                       = 1101
	StmtParserDIV_ASSIGN                        = 1102
	StmtParserMOD_ASSIGN                        = 1103
	StmtParserAND_ASSIGN                        = 1104
	StmtParserXOR_ASSIGN                        = 1105
	StmtParserOR_ASSIGN                         = 1106
	StmtParserSTAR                              = 1107
	StmtParserDIVIDE                            = 1108
	StmtParserMODULE                            = 1109
	StmtParserPLUS                              = 1110
	StmtParserMINUS                             = 1111
	StmtParserDIV                               = 1112
	StmtParserMOD                               = 1113
	StmtParserEQUAL_SYMBOL                      = 1114
	StmtParserGREATER_SYMBOL                    = 1115
	StmtParserLESS_SYMBOL                       = 1116
	StmtParserEXCLAMATION_SYMBOL                = 1117
	StmtParserBIT_NOT_OP                        = 1118
	StmtParserBIT_OR_OP                         = 1119
	StmtParserBIT_AND_OP                        = 1120
	StmtParserBIT_XOR_OP                        = 1121
	StmtParserDOT                               = 1122
	StmtParserLR_BRACKET                        = 1123
	StmtParserRR_BRACKET                        = 1124
	StmtParserCOMMA                             = 1125
	StmtParserSEMI                              = 1126
	StmtParserAT_SIGN                           = 1127
	StmtParserZERO_DECIMAL                      = 1128
	StmtParserONE_DECIMAL                       = 1129
	StmtParserTWO_DECIMAL                       = 1130
	StmtParserSINGLE_QUOTE_SYMB                 = 1131
	StmtParserDOUBLE_QUOTE_SYMB                 = 1132
	StmtParserREVERSE_QUOTE_SYMB                = 1133
	StmtParserCOLON_SYMB                        = 1134
	StmtParserCHARSET_REVERSE_QOUTE_STRING      = 1135
	StmtParserFILESIZE_LITERAL                  = 1136
	StmtParserSTART_NATIONAL_STRING_LITERAL     = 1137
	StmtParserSTRING_LITERAL                    = 1138
	StmtParserDECIMAL_LITERAL                   = 1139
	StmtParserHEXADECIMAL_LITERAL               = 1140
	StmtParserREAL_LITERAL                      = 1141
	StmtParserNULL_SPEC_LITERAL                 = 1142
	StmtParserBIT_STRING                        = 1143
	StmtParserSTRING_CHARSET_NAME               = 1144
	StmtParserDOT_ID                            = 1145
	StmtParserID                                = 1146
	StmtParserREVERSE_QUOTE_ID                  = 1147
	StmtParserSTRING_USER_NAME                  = 1148
	StmtParserIP_ADDRESS                        = 1149
	StmtParserSTRING_USER_NAME_MARIADB          = 1150
	StmtParserLOCAL_ID                          = 1151
	StmtParserGLOBAL_ID                         = 1152
	StmtParserERROR_RECONGNIGION                = 1153
)

// StmtParser rules.
const (
	StmtParserRULE_prog                           = 0
	StmtParserRULE_sqlStatement                   = 1
	StmtParserRULE_charSet                        = 2
	StmtParserRULE_intervalType                   = 3
	StmtParserRULE_indexType                      = 4
	StmtParserRULE_indexOption                    = 5
	StmtParserRULE_createDefinitions              = 6
	StmtParserRULE_createDefinition               = 7
	StmtParserRULE_columnDefinition               = 8
	StmtParserRULE_columnConstraint               = 9
	StmtParserRULE_tableConstraint                = 10
	StmtParserRULE_referenceDefinition            = 11
	StmtParserRULE_referenceAction                = 12
	StmtParserRULE_referenceControlType           = 13
	StmtParserRULE_indexColumnDefinition          = 14
	StmtParserRULE_tableOption                    = 15
	StmtParserRULE_tableType                      = 16
	StmtParserRULE_tablespaceStorage              = 17
	StmtParserRULE_partitionDefinitions           = 18
	StmtParserRULE_partitionFunctionDefinition    = 19
	StmtParserRULE_subpartitionFunctionDefinition = 20
	StmtParserRULE_partitionDefinition            = 21
	StmtParserRULE_partitionDefinerAtom           = 22
	StmtParserRULE_partitionDefinerVector         = 23
	StmtParserRULE_subpartitionDefinition         = 24
	StmtParserRULE_partitionOption                = 25
	StmtParserRULE_fullId                         = 26
	StmtParserRULE_tableName                      = 27
	StmtParserRULE_fullColumnName                 = 28
	StmtParserRULE_indexColumnName                = 29
	StmtParserRULE_mysqlVariable                  = 30
	StmtParserRULE_charsetName                    = 31
	StmtParserRULE_collationName                  = 32
	StmtParserRULE_engineName                     = 33
	StmtParserRULE_uid                            = 34
	StmtParserRULE_simpleId                       = 35
	StmtParserRULE_dottedId                       = 36
	StmtParserRULE_decimalLiteral                 = 37
	StmtParserRULE_fileSizeLiteral                = 38
	StmtParserRULE_stringLiteral                  = 39
	StmtParserRULE_booleanLiteral                 = 40
	StmtParserRULE_hexadecimalLiteral             = 41
	StmtParserRULE_nullNotnull                    = 42
	StmtParserRULE_constant                       = 43
	StmtParserRULE_dataType                       = 44
	StmtParserRULE_collectionOptions              = 45
	StmtParserRULE_convertedDataType              = 46
	StmtParserRULE_lengthOneDimension             = 47
	StmtParserRULE_lengthTwoDimension             = 48
	StmtParserRULE_lengthTwoOptionalDimension     = 49
	StmtParserRULE_uidList                        = 50
	StmtParserRULE_tables                         = 51
	StmtParserRULE_indexColumnNames               = 52
	StmtParserRULE_defaultValue                   = 53
	StmtParserRULE_currentTimestamp               = 54
	StmtParserRULE_ifNotExists                    = 55
	StmtParserRULE_scalarFunctionName             = 56
	StmtParserRULE_expression                     = 57
	StmtParserRULE_predicate                      = 58
	StmtParserRULE_expressionAtom                 = 59
	StmtParserRULE_unaryOperator                  = 60
	StmtParserRULE_comparisonOperator             = 61
	StmtParserRULE_logicalOperator                = 62
	StmtParserRULE_bitOperator                    = 63
	StmtParserRULE_mathOperator                   = 64
	StmtParserRULE_jsonOperator                   = 65
	StmtParserRULE_charsetNameBase                = 66
	StmtParserRULE_transactionLevelBase           = 67
	StmtParserRULE_privilegesBase                 = 68
	StmtParserRULE_intervalTypeBase               = 69
	StmtParserRULE_dataTypeBase                   = 70
	StmtParserRULE_keywordsCanBeId                = 71
	StmtParserRULE_functionNameBase               = 72
)

// IProgContext is an interface to support dynamic dispatch.
type IProgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SqlStatement() ISqlStatementContext
	EOF() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsProgContext differentiates from other interfaces.
	IsProgContext()
}

type ProgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgContext() *ProgContext {
	var p = new(ProgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_prog
	return p
}

func InitEmptyProgContext(p *ProgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_prog
}

func (*ProgContext) IsProgContext() {}

func NewProgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgContext {
	var p = new(ProgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_prog

	return p
}

func (s *ProgContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgContext) SqlStatement() ISqlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementContext)
}

func (s *ProgContext) EOF() antlr.TerminalNode {
	return s.GetToken(StmtParserEOF, 0)
}

func (s *ProgContext) SEMI() antlr.TerminalNode {
	return s.GetToken(StmtParserSEMI, 0)
}

func (s *ProgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterProg(s)
	}
}

func (s *ProgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitProg(s)
	}
}

func (p *StmtParser) Prog() (localctx IProgContext) {
	localctx = NewProgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, StmtParserRULE_prog)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(146)
		p.SqlStatement()
	}
	p.SetState(148)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserSEMI {
		{
			p.SetState(147)
			p.Match(StmtParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(150)
		p.Match(StmtParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISqlStatementContext is an interface to support dynamic dispatch.
type ISqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	CreateDefinitions() ICreateDefinitionsContext
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	AllTableOption() []ITableOptionContext
	TableOption(i int) ITableOptionContext
	PartitionDefinitions() IPartitionDefinitionsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSqlStatementContext differentiates from other interfaces.
	IsSqlStatementContext()
}

type SqlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementContext() *SqlStatementContext {
	var p = new(SqlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_sqlStatement
	return p
}

func InitEmptySqlStatementContext(p *SqlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_sqlStatement
}

func (*SqlStatementContext) IsSqlStatementContext() {}

func NewSqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementContext {
	var p = new(SqlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_sqlStatement

	return p
}

func (s *SqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StmtParserCREATE, 0)
}

func (s *SqlStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserTABLE, 0)
}

func (s *SqlStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *SqlStatementContext) CreateDefinitions() ICreateDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionsContext)
}

func (s *SqlStatementContext) OR() antlr.TerminalNode {
	return s.GetToken(StmtParserOR, 0)
}

func (s *SqlStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLACE, 0)
}

func (s *SqlStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StmtParserTEMPORARY, 0)
}

func (s *SqlStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *SqlStatementContext) AllTableOption() []ITableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableOptionContext); ok {
			len++
		}
	}

	tst := make([]ITableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableOptionContext); ok {
			tst[i] = t.(ITableOptionContext)
			i++
		}
	}

	return tst
}

func (s *SqlStatementContext) TableOption(i int) ITableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionContext)
}

func (s *SqlStatementContext) PartitionDefinitions() IPartitionDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionsContext)
}

func (s *SqlStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *SqlStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *SqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSqlStatement(s)
	}
}

func (s *SqlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSqlStatement(s)
	}
}

func (p *StmtParser) SqlStatement() (localctx ISqlStatementContext) {
	localctx = NewSqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, StmtParserRULE_sqlStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(152)
		p.Match(StmtParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserOR {
		{
			p.SetState(153)
			p.Match(StmtParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(154)
			p.Match(StmtParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserTEMPORARY {
		{
			p.SetState(157)
			p.Match(StmtParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(160)
		p.Match(StmtParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(162)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(161)
			p.IfNotExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(164)
		p.TableName()
	}
	{
		p.SetState(165)
		p.CreateDefinitions()
	}
	p.SetState(176)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&18014398509547525) != 0) || _la == StmtParserUNION || _la == StmtParserCHAR || ((int64((_la-332)) & ^0x3f) == 0 && ((int64(1)<<(_la-332))&-9218727660950028281) != 0) || ((int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&72075186223972353) != 0) || ((int64((_la-487)) & ^0x3f) == 0 && ((int64(1)<<(_la-487))&571746046444545) != 0) || ((int64((_la-585)) & ^0x3f) == 0 && ((int64(1)<<(_la-585))&105574188449793) != 0) || _la == StmtParserCHARSET || _la == StmtParserENGINE_ATTRIBUTE || _la == StmtParserSECONDARY_ENGINE_ATTRIBUTE {
		{
			p.SetState(166)
			p.TableOption()
		}
		p.SetState(173)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&18014398509547525) != 0) || _la == StmtParserUNION || _la == StmtParserCHAR || ((int64((_la-332)) & ^0x3f) == 0 && ((int64(1)<<(_la-332))&-9218727660950028281) != 0) || ((int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&72075186223972353) != 0) || ((int64((_la-487)) & ^0x3f) == 0 && ((int64(1)<<(_la-487))&571746046444545) != 0) || ((int64((_la-585)) & ^0x3f) == 0 && ((int64(1)<<(_la-585))&105574188449793) != 0) || _la == StmtParserCHARSET || _la == StmtParserENGINE_ATTRIBUTE || _la == StmtParserSECONDARY_ENGINE_ATTRIBUTE || _la == StmtParserCOMMA {
			p.SetState(168)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StmtParserCOMMA {
				{
					p.SetState(167)
					p.Match(StmtParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(170)
				p.TableOption()
			}

			p.SetState(175)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserPARTITION {
		{
			p.SetState(178)
			p.PartitionDefinitions()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharSetContext is an interface to support dynamic dispatch.
type ICharSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHARACTER() antlr.TerminalNode
	SET() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHAR() antlr.TerminalNode

	// IsCharSetContext differentiates from other interfaces.
	IsCharSetContext()
}

type CharSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharSetContext() *CharSetContext {
	var p = new(CharSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_charSet
	return p
}

func InitEmptyCharSetContext(p *CharSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_charSet
}

func (*CharSetContext) IsCharSetContext() {}

func NewCharSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharSetContext {
	var p = new(CharSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_charSet

	return p
}

func (s *CharSetContext) GetParser() antlr.Parser { return s.parser }

func (s *CharSetContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(StmtParserCHARACTER, 0)
}

func (s *CharSetContext) SET() antlr.TerminalNode {
	return s.GetToken(StmtParserSET, 0)
}

func (s *CharSetContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(StmtParserCHARSET, 0)
}

func (s *CharSetContext) CHAR() antlr.TerminalNode {
	return s.GetToken(StmtParserCHAR, 0)
}

func (s *CharSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCharSet(s)
	}
}

func (s *CharSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCharSet(s)
	}
}

func (p *StmtParser) CharSet() (localctx ICharSetContext) {
	localctx = NewCharSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, StmtParserRULE_charSet)
	p.SetState(186)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StmtParserCHARACTER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(181)
			p.Match(StmtParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(182)
			p.Match(StmtParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserCHARSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(183)
			p.Match(StmtParserCHARSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserCHAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(184)
			p.Match(StmtParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(185)
			p.Match(StmtParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalTypeContext is an interface to support dynamic dispatch.
type IIntervalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntervalTypeBase() IIntervalTypeBaseContext
	YEAR() antlr.TerminalNode
	YEAR_MONTH() antlr.TerminalNode
	DAY_HOUR() antlr.TerminalNode
	DAY_MINUTE() antlr.TerminalNode
	DAY_SECOND() antlr.TerminalNode
	HOUR_MINUTE() antlr.TerminalNode
	HOUR_SECOND() antlr.TerminalNode
	MINUTE_SECOND() antlr.TerminalNode
	SECOND_MICROSECOND() antlr.TerminalNode
	MINUTE_MICROSECOND() antlr.TerminalNode
	HOUR_MICROSECOND() antlr.TerminalNode
	DAY_MICROSECOND() antlr.TerminalNode

	// IsIntervalTypeContext differentiates from other interfaces.
	IsIntervalTypeContext()
}

type IntervalTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalTypeContext() *IntervalTypeContext {
	var p = new(IntervalTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_intervalType
	return p
}

func InitEmptyIntervalTypeContext(p *IntervalTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_intervalType
}

func (*IntervalTypeContext) IsIntervalTypeContext() {}

func NewIntervalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalTypeContext {
	var p = new(IntervalTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_intervalType

	return p
}

func (s *IntervalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalTypeContext) IntervalTypeBase() IIntervalTypeBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeBaseContext)
}

func (s *IntervalTypeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserYEAR, 0)
}

func (s *IntervalTypeContext) YEAR_MONTH() antlr.TerminalNode {
	return s.GetToken(StmtParserYEAR_MONTH, 0)
}

func (s *IntervalTypeContext) DAY_HOUR() antlr.TerminalNode {
	return s.GetToken(StmtParserDAY_HOUR, 0)
}

func (s *IntervalTypeContext) DAY_MINUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserDAY_MINUTE, 0)
}

func (s *IntervalTypeContext) DAY_SECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserDAY_SECOND, 0)
}

func (s *IntervalTypeContext) HOUR_MINUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserHOUR_MINUTE, 0)
}

func (s *IntervalTypeContext) HOUR_SECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserHOUR_SECOND, 0)
}

func (s *IntervalTypeContext) MINUTE_SECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserMINUTE_SECOND, 0)
}

func (s *IntervalTypeContext) SECOND_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserSECOND_MICROSECOND, 0)
}

func (s *IntervalTypeContext) MINUTE_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserMINUTE_MICROSECOND, 0)
}

func (s *IntervalTypeContext) HOUR_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserHOUR_MICROSECOND, 0)
}

func (s *IntervalTypeContext) DAY_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserDAY_MICROSECOND, 0)
}

func (s *IntervalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIntervalType(s)
	}
}

func (s *IntervalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIntervalType(s)
	}
}

func (p *StmtParser) IntervalType() (localctx IIntervalTypeContext) {
	localctx = NewIntervalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, StmtParserRULE_intervalType)
	p.SetState(201)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StmtParserQUARTER, StmtParserMONTH, StmtParserDAY, StmtParserHOUR, StmtParserMINUTE, StmtParserWEEK, StmtParserSECOND, StmtParserMICROSECOND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(188)
			p.IntervalTypeBase()
		}

	case StmtParserYEAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(189)
			p.Match(StmtParserYEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserYEAR_MONTH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(190)
			p.Match(StmtParserYEAR_MONTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserDAY_HOUR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(191)
			p.Match(StmtParserDAY_HOUR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserDAY_MINUTE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(192)
			p.Match(StmtParserDAY_MINUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserDAY_SECOND:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(193)
			p.Match(StmtParserDAY_SECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserHOUR_MINUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(194)
			p.Match(StmtParserHOUR_MINUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserHOUR_SECOND:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(195)
			p.Match(StmtParserHOUR_SECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserMINUTE_SECOND:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(196)
			p.Match(StmtParserMINUTE_SECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserSECOND_MICROSECOND:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(197)
			p.Match(StmtParserSECOND_MICROSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserMINUTE_MICROSECOND:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(198)
			p.Match(StmtParserMINUTE_MICROSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserHOUR_MICROSECOND:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(199)
			p.Match(StmtParserHOUR_MICROSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserDAY_MICROSECOND:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(200)
			p.Match(StmtParserDAY_MICROSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexTypeContext is an interface to support dynamic dispatch.
type IIndexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USING() antlr.TerminalNode
	BTREE() antlr.TerminalNode
	HASH() antlr.TerminalNode
	RTREE() antlr.TerminalNode

	// IsIndexTypeContext differentiates from other interfaces.
	IsIndexTypeContext()
}

type IndexTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexTypeContext() *IndexTypeContext {
	var p = new(IndexTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_indexType
	return p
}

func InitEmptyIndexTypeContext(p *IndexTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_indexType
}

func (*IndexTypeContext) IsIndexTypeContext() {}

func NewIndexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeContext {
	var p = new(IndexTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_indexType

	return p
}

func (s *IndexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeContext) USING() antlr.TerminalNode {
	return s.GetToken(StmtParserUSING, 0)
}

func (s *IndexTypeContext) BTREE() antlr.TerminalNode {
	return s.GetToken(StmtParserBTREE, 0)
}

func (s *IndexTypeContext) HASH() antlr.TerminalNode {
	return s.GetToken(StmtParserHASH, 0)
}

func (s *IndexTypeContext) RTREE() antlr.TerminalNode {
	return s.GetToken(StmtParserRTREE, 0)
}

func (s *IndexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIndexType(s)
	}
}

func (s *IndexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIndexType(s)
	}
}

func (p *StmtParser) IndexType() (localctx IIndexTypeContext) {
	localctx = NewIndexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, StmtParserRULE_indexType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(203)
		p.Match(StmtParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(204)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserBTREE || _la == StmtParserHASH || _la == StmtParserRTREE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexOptionContext is an interface to support dynamic dispatch.
type IIndexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEY_BLOCK_SIZE() antlr.TerminalNode
	FileSizeLiteral() IFileSizeLiteralContext
	EQUAL_SYMBOL() antlr.TerminalNode
	IndexType() IIndexTypeContext
	WITH() antlr.TerminalNode
	PARSER() antlr.TerminalNode
	Uid() IUidContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	VISIBLE() antlr.TerminalNode
	INVISIBLE() antlr.TerminalNode
	ENGINE_ATTRIBUTE() antlr.TerminalNode
	SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode
	CLUSTERING() antlr.TerminalNode
	YES() antlr.TerminalNode
	NO() antlr.TerminalNode
	IGNORED() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsIndexOptionContext differentiates from other interfaces.
	IsIndexOptionContext()
}

type IndexOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexOptionContext() *IndexOptionContext {
	var p = new(IndexOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_indexOption
	return p
}

func InitEmptyIndexOptionContext(p *IndexOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_indexOption
}

func (*IndexOptionContext) IsIndexOptionContext() {}

func NewIndexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexOptionContext {
	var p = new(IndexOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_indexOption

	return p
}

func (s *IndexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexOptionContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY_BLOCK_SIZE, 0)
}

func (s *IndexOptionContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *IndexOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *IndexOptionContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *IndexOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(StmtParserWITH, 0)
}

func (s *IndexOptionContext) PARSER() antlr.TerminalNode {
	return s.GetToken(StmtParserPARSER, 0)
}

func (s *IndexOptionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *IndexOptionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMENT, 0)
}

func (s *IndexOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *IndexOptionContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(StmtParserVISIBLE, 0)
}

func (s *IndexOptionContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(StmtParserINVISIBLE, 0)
}

func (s *IndexOptionContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserENGINE_ATTRIBUTE, 0)
}

func (s *IndexOptionContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *IndexOptionContext) CLUSTERING() antlr.TerminalNode {
	return s.GetToken(StmtParserCLUSTERING, 0)
}

func (s *IndexOptionContext) YES() antlr.TerminalNode {
	return s.GetToken(StmtParserYES, 0)
}

func (s *IndexOptionContext) NO() antlr.TerminalNode {
	return s.GetToken(StmtParserNO, 0)
}

func (s *IndexOptionContext) IGNORED() antlr.TerminalNode {
	return s.GetToken(StmtParserIGNORED, 0)
}

func (s *IndexOptionContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *IndexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIndexOption(s)
	}
}

func (s *IndexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIndexOption(s)
	}
}

func (p *StmtParser) IndexOption() (localctx IIndexOptionContext) {
	localctx = NewIndexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, StmtParserRULE_indexOption)
	var _la int

	p.SetState(236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StmtParserKEY_BLOCK_SIZE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(206)
			p.Match(StmtParserKEY_BLOCK_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(208)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(207)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(210)
			p.FileSizeLiteral()
		}

	case StmtParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(211)
			p.IndexType()
		}

	case StmtParserWITH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(212)
			p.Match(StmtParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(213)
			p.Match(StmtParserPARSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(214)
			p.Uid()
		}

	case StmtParserCOMMENT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(215)
			p.Match(StmtParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(216)
			p.Match(StmtParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserINVISIBLE, StmtParserVISIBLE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(217)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserINVISIBLE || _la == StmtParserVISIBLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case StmtParserENGINE_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(218)
			p.Match(StmtParserENGINE_ATTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(220)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(219)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(222)
			p.Match(StmtParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserSECONDARY_ENGINE_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(223)
			p.Match(StmtParserSECONDARY_ENGINE_ATTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(225)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(224)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(227)
			p.Match(StmtParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserCLUSTERING:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(228)
			p.Match(StmtParserCLUSTERING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(229)
			p.Match(StmtParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(230)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserNO || _la == StmtParserYES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case StmtParserIGNORED, StmtParserNOT:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(234)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StmtParserIGNORED:
			{
				p.SetState(231)
				p.Match(StmtParserIGNORED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case StmtParserNOT:
			{
				p.SetState(232)
				p.Match(StmtParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(233)
				p.Match(StmtParserIGNORED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDefinitionsContext is an interface to support dynamic dispatch.
type ICreateDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllCreateDefinition() []ICreateDefinitionContext
	CreateDefinition(i int) ICreateDefinitionContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateDefinitionsContext differentiates from other interfaces.
	IsCreateDefinitionsContext()
}

type CreateDefinitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDefinitionsContext() *CreateDefinitionsContext {
	var p = new(CreateDefinitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_createDefinitions
	return p
}

func InitEmptyCreateDefinitionsContext(p *CreateDefinitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_createDefinitions
}

func (*CreateDefinitionsContext) IsCreateDefinitionsContext() {}

func NewCreateDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDefinitionsContext {
	var p = new(CreateDefinitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_createDefinitions

	return p
}

func (s *CreateDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDefinitionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *CreateDefinitionsContext) AllCreateDefinition() []ICreateDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDefinitionContext); ok {
			tst[i] = t.(ICreateDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *CreateDefinitionsContext) CreateDefinition(i int) ICreateDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionContext)
}

func (s *CreateDefinitionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *CreateDefinitionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *CreateDefinitionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *CreateDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCreateDefinitions(s)
	}
}

func (s *CreateDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCreateDefinitions(s)
	}
}

func (p *StmtParser) CreateDefinitions() (localctx ICreateDefinitionsContext) {
	localctx = NewCreateDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, StmtParserRULE_createDefinitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(238)
		p.Match(StmtParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(239)
		p.CreateDefinition()
	}
	p.SetState(244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StmtParserCOMMA {
		{
			p.SetState(240)
			p.Match(StmtParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(241)
			p.CreateDefinition()
		}

		p.SetState(246)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(247)
		p.Match(StmtParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDefinitionContext is an interface to support dynamic dispatch.
type ICreateDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCreateDefinitionContext differentiates from other interfaces.
	IsCreateDefinitionContext()
}

type CreateDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDefinitionContext() *CreateDefinitionContext {
	var p = new(CreateDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_createDefinition
	return p
}

func InitEmptyCreateDefinitionContext(p *CreateDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_createDefinition
}

func (*CreateDefinitionContext) IsCreateDefinitionContext() {}

func NewCreateDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDefinitionContext {
	var p = new(CreateDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_createDefinition

	return p
}

func (s *CreateDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDefinitionContext) CopyAll(ctx *CreateDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CreateDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ColumnDeclarationContext struct {
	CreateDefinitionContext
}

func NewColumnDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnDeclarationContext {
	var p = new(ColumnDeclarationContext)

	InitEmptyCreateDefinitionContext(&p.CreateDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateDefinitionContext))

	return p
}

func (s *ColumnDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDeclarationContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ColumnDeclarationContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *ColumnDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterColumnDeclaration(s)
	}
}

func (s *ColumnDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitColumnDeclaration(s)
	}
}

type ConstraintDeclarationContext struct {
	CreateDefinitionContext
}

func NewConstraintDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstraintDeclarationContext {
	var p = new(ConstraintDeclarationContext)

	InitEmptyCreateDefinitionContext(&p.CreateDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateDefinitionContext))

	return p
}

func (s *ConstraintDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintDeclarationContext) TableConstraint() ITableConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableConstraintContext)
}

func (s *ConstraintDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterConstraintDeclaration(s)
	}
}

func (s *ConstraintDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitConstraintDeclaration(s)
	}
}

type IndexDeclarationContext struct {
	CreateDefinitionContext
}

func NewIndexDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexDeclarationContext {
	var p = new(IndexDeclarationContext)

	InitEmptyCreateDefinitionContext(&p.CreateDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateDefinitionContext))

	return p
}

func (s *IndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexDeclarationContext) IndexColumnDefinition() IIndexColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnDefinitionContext)
}

func (s *IndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIndexDeclaration(s)
	}
}

func (s *IndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIndexDeclaration(s)
	}
}

func (p *StmtParser) CreateDefinition() (localctx ICreateDefinitionContext) {
	localctx = NewCreateDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, StmtParserRULE_createDefinition)
	p.SetState(254)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		localctx = NewColumnDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(249)
			p.Uid()
		}
		{
			p.SetState(250)
			p.ColumnDefinition()
		}

	case 2:
		localctx = NewConstraintDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(252)
			p.TableConstraint()
		}

	case 3:
		localctx = NewIndexDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(253)
			p.IndexColumnDefinition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefinitionContext is an interface to support dynamic dispatch.
type IColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	AllColumnConstraint() []IColumnConstraintContext
	ColumnConstraint(i int) IColumnConstraintContext

	// IsColumnDefinitionContext differentiates from other interfaces.
	IsColumnDefinitionContext()
}

type ColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionContext() *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_columnDefinition
	return p
}

func InitEmptyColumnDefinitionContext(p *ColumnDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_columnDefinition
}

func (*ColumnDefinitionContext) IsColumnDefinitionContext() {}

func NewColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_columnDefinition

	return p
}

func (s *ColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ColumnDefinitionContext) AllColumnConstraint() []IColumnConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnConstraintContext); ok {
			len++
		}
	}

	tst := make([]IColumnConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnConstraintContext); ok {
			tst[i] = t.(IColumnConstraintContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefinitionContext) ColumnConstraint(i int) IColumnConstraintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintContext)
}

func (s *ColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitColumnDefinition(s)
	}
}

func (p *StmtParser) ColumnDefinition() (localctx IColumnDefinitionContext) {
	localctx = NewColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, StmtParserRULE_columnDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(256)
		p.DataType()
	}
	p.SetState(260)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-12)) & ^0x3f) == 0 && ((int64(1)<<(_la-12))&36028797287555073) != 0) || ((int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&17867152031745) != 0) || _la == StmtParserUNIQUE || _la == StmtParserSERIAL || ((int64((_la-333)) & ^0x3f) == 0 && ((int64(1)<<(_la-333))&83886081) != 0) || _la == StmtParserINVISIBLE || _la == StmtParserSTORAGE || _la == StmtParserVISIBLE || _la == StmtParserNULL_SPEC_LITERAL {
		{
			p.SetState(257)
			p.ColumnConstraint()
		}

		p.SetState(262)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnConstraintContext is an interface to support dynamic dispatch.
type IColumnConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsColumnConstraintContext differentiates from other interfaces.
	IsColumnConstraintContext()
}

type ColumnConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnConstraintContext() *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_columnConstraint
	return p
}

func InitEmptyColumnConstraintContext(p *ColumnConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_columnConstraint
}

func (*ColumnConstraintContext) IsColumnConstraintContext() {}

func NewColumnConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_columnConstraint

	return p
}

func (s *ColumnConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnConstraintContext) CopyAll(ctx *ColumnConstraintContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StorageColumnConstraintContext struct {
	ColumnConstraintContext
	storageval antlr.Token
}

func NewStorageColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StorageColumnConstraintContext {
	var p = new(StorageColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *StorageColumnConstraintContext) GetStorageval() antlr.Token { return s.storageval }

func (s *StorageColumnConstraintContext) SetStorageval(v antlr.Token) { s.storageval = v }

func (s *StorageColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageColumnConstraintContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StmtParserSTORAGE, 0)
}

func (s *StorageColumnConstraintContext) DISK() antlr.TerminalNode {
	return s.GetToken(StmtParserDISK, 0)
}

func (s *StorageColumnConstraintContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(StmtParserMEMORY, 0)
}

func (s *StorageColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *StorageColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterStorageColumnConstraint(s)
	}
}

func (s *StorageColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitStorageColumnConstraint(s)
	}
}

type VisibilityColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewVisibilityColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VisibilityColumnConstraintContext {
	var p = new(VisibilityColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *VisibilityColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VisibilityColumnConstraintContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(StmtParserVISIBLE, 0)
}

func (s *VisibilityColumnConstraintContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(StmtParserINVISIBLE, 0)
}

func (s *VisibilityColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterVisibilityColumnConstraint(s)
	}
}

func (s *VisibilityColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitVisibilityColumnConstraint(s)
	}
}

type AutoIncrementColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewAutoIncrementColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AutoIncrementColumnConstraintContext {
	var p = new(AutoIncrementColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *AutoIncrementColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AutoIncrementColumnConstraintContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(StmtParserAUTO_INCREMENT, 0)
}

func (s *AutoIncrementColumnConstraintContext) ON() antlr.TerminalNode {
	return s.GetToken(StmtParserON, 0)
}

func (s *AutoIncrementColumnConstraintContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(StmtParserUPDATE, 0)
}

func (s *AutoIncrementColumnConstraintContext) CurrentTimestamp() ICurrentTimestampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentTimestampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentTimestampContext)
}

func (s *AutoIncrementColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterAutoIncrementColumnConstraint(s)
	}
}

func (s *AutoIncrementColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitAutoIncrementColumnConstraint(s)
	}
}

type CommentColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewCommentColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentColumnConstraintContext {
	var p = new(CommentColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *CommentColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentColumnConstraintContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMENT, 0)
}

func (s *CommentColumnConstraintContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *CommentColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCommentColumnConstraint(s)
	}
}

func (s *CommentColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCommentColumnConstraint(s)
	}
}

type UniqueKeyColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewUniqueKeyColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UniqueKeyColumnConstraintContext {
	var p = new(UniqueKeyColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *UniqueKeyColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueKeyColumnConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(StmtParserUNIQUE, 0)
}

func (s *UniqueKeyColumnConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY, 0)
}

func (s *UniqueKeyColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterUniqueKeyColumnConstraint(s)
	}
}

func (s *UniqueKeyColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitUniqueKeyColumnConstraint(s)
	}
}

type SerialDefaultColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewSerialDefaultColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SerialDefaultColumnConstraintContext {
	var p = new(SerialDefaultColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *SerialDefaultColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SerialDefaultColumnConstraintContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSERIAL, 0)
}

func (s *SerialDefaultColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *SerialDefaultColumnConstraintContext) VALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserVALUE, 0)
}

func (s *SerialDefaultColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSerialDefaultColumnConstraint(s)
	}
}

func (s *SerialDefaultColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSerialDefaultColumnConstraint(s)
	}
}

type GeneratedColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewGeneratedColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GeneratedColumnConstraintContext {
	var p = new(GeneratedColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *GeneratedColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratedColumnConstraintContext) AS() antlr.TerminalNode {
	return s.GetToken(StmtParserAS, 0)
}

func (s *GeneratedColumnConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *GeneratedColumnConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GeneratedColumnConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *GeneratedColumnConstraintContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(StmtParserGENERATED, 0)
}

func (s *GeneratedColumnConstraintContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(StmtParserALWAYS, 0)
}

func (s *GeneratedColumnConstraintContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(StmtParserVIRTUAL, 0)
}

func (s *GeneratedColumnConstraintContext) STORED() antlr.TerminalNode {
	return s.GetToken(StmtParserSTORED, 0)
}

func (s *GeneratedColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterGeneratedColumnConstraint(s)
	}
}

func (s *GeneratedColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitGeneratedColumnConstraint(s)
	}
}

type FormatColumnConstraintContext struct {
	ColumnConstraintContext
	colformat antlr.Token
}

func NewFormatColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FormatColumnConstraintContext {
	var p = new(FormatColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *FormatColumnConstraintContext) GetColformat() antlr.Token { return s.colformat }

func (s *FormatColumnConstraintContext) SetColformat(v antlr.Token) { s.colformat = v }

func (s *FormatColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormatColumnConstraintContext) COLUMN_FORMAT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLUMN_FORMAT, 0)
}

func (s *FormatColumnConstraintContext) FIXED() antlr.TerminalNode {
	return s.GetToken(StmtParserFIXED, 0)
}

func (s *FormatColumnConstraintContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(StmtParserDYNAMIC, 0)
}

func (s *FormatColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *FormatColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterFormatColumnConstraint(s)
	}
}

func (s *FormatColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitFormatColumnConstraint(s)
	}
}

type CollateColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewCollateColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateColumnConstraintContext {
	var p = new(CollateColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *CollateColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateColumnConstraintContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLLATE, 0)
}

func (s *CollateColumnConstraintContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *CollateColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCollateColumnConstraint(s)
	}
}

func (s *CollateColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCollateColumnConstraint(s)
	}
}

type PrimaryKeyColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewPrimaryKeyColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryKeyColumnConstraintContext {
	var p = new(PrimaryKeyColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *PrimaryKeyColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyColumnConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY, 0)
}

func (s *PrimaryKeyColumnConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(StmtParserPRIMARY, 0)
}

func (s *PrimaryKeyColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPrimaryKeyColumnConstraint(s)
	}
}

func (s *PrimaryKeyColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPrimaryKeyColumnConstraint(s)
	}
}

type CheckColumnConstraintContext struct {
	ColumnConstraintContext
	name IUidContext
}

func NewCheckColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CheckColumnConstraintContext {
	var p = new(CheckColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *CheckColumnConstraintContext) GetName() IUidContext { return s.name }

func (s *CheckColumnConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *CheckColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckColumnConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(StmtParserCHECK, 0)
}

func (s *CheckColumnConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *CheckColumnConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CheckColumnConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *CheckColumnConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONSTRAINT, 0)
}

func (s *CheckColumnConstraintContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CheckColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCheckColumnConstraint(s)
	}
}

func (s *CheckColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCheckColumnConstraint(s)
	}
}

type NullColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewNullColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullColumnConstraintContext {
	var p = new(NullColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *NullColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullColumnConstraintContext) NullNotnull() INullNotnullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullNotnullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullNotnullContext)
}

func (s *NullColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterNullColumnConstraint(s)
	}
}

func (s *NullColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitNullColumnConstraint(s)
	}
}

type DefaultColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewDefaultColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefaultColumnConstraintContext {
	var p = new(DefaultColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *DefaultColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *DefaultColumnConstraintContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *DefaultColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterDefaultColumnConstraint(s)
	}
}

func (s *DefaultColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitDefaultColumnConstraint(s)
	}
}

type ReferenceColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewReferenceColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReferenceColumnConstraintContext {
	var p = new(ReferenceColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *ReferenceColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceColumnConstraintContext) ReferenceDefinition() IReferenceDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceDefinitionContext)
}

func (s *ReferenceColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterReferenceColumnConstraint(s)
	}
}

func (s *ReferenceColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitReferenceColumnConstraint(s)
	}
}

func (p *StmtParser) ColumnConstraint() (localctx IColumnConstraintContext) {
	localctx = NewColumnConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, StmtParserRULE_columnConstraint)
	var _la int

	p.SetState(316)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StmtParserNOT, StmtParserNULL_LITERAL, StmtParserNULL_SPEC_LITERAL:
		localctx = NewNullColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(263)
			p.NullNotnull()
		}

	case StmtParserDEFAULT:
		localctx = NewDefaultColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(264)
			p.Match(StmtParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(265)
			p.DefaultValue()
		}

	case StmtParserVISIBLE:
		localctx = NewVisibilityColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(266)
			p.Match(StmtParserVISIBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserINVISIBLE:
		localctx = NewVisibilityColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(267)
			p.Match(StmtParserINVISIBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserON, StmtParserAUTO_INCREMENT:
		localctx = NewAutoIncrementColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(272)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StmtParserAUTO_INCREMENT:
			{
				p.SetState(268)
				p.Match(StmtParserAUTO_INCREMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case StmtParserON:
			{
				p.SetState(269)
				p.Match(StmtParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(270)
				p.Match(StmtParserUPDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(271)
				p.CurrentTimestamp()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case StmtParserKEY, StmtParserPRIMARY:
		localctx = NewPrimaryKeyColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(275)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserPRIMARY {
			{
				p.SetState(274)
				p.Match(StmtParserPRIMARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(277)
			p.Match(StmtParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserUNIQUE:
		localctx = NewUniqueKeyColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(278)
			p.Match(StmtParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(280)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(279)
				p.Match(StmtParserKEY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case StmtParserCOMMENT:
		localctx = NewCommentColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(282)
			p.Match(StmtParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(283)
			p.Match(StmtParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserCOLUMN_FORMAT:
		localctx = NewFormatColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(284)
			p.Match(StmtParserCOLUMN_FORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(285)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FormatColumnConstraintContext).colformat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserDEFAULT || _la == StmtParserDYNAMIC || _la == StmtParserFIXED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FormatColumnConstraintContext).colformat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case StmtParserSTORAGE:
		localctx = NewStorageColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(286)
			p.Match(StmtParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(287)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StorageColumnConstraintContext).storageval = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserDEFAULT || _la == StmtParserDISK || _la == StmtParserMEMORY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StorageColumnConstraintContext).storageval = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case StmtParserREFERENCES:
		localctx = NewReferenceColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(288)
			p.ReferenceDefinition()
		}

	case StmtParserCOLLATE:
		localctx = NewCollateColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(289)
			p.Match(StmtParserCOLLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(290)
			p.CollationName()
		}

	case StmtParserAS, StmtParserGENERATED:
		localctx = NewGeneratedColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		p.SetState(293)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserGENERATED {
			{
				p.SetState(291)
				p.Match(StmtParserGENERATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(292)
				p.Match(StmtParserALWAYS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(295)
			p.Match(StmtParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(296)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(297)
			p.expression(0)
		}
		{
			p.SetState(298)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(300)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserSTORED || _la == StmtParserVIRTUAL {
			{
				p.SetState(299)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StmtParserSTORED || _la == StmtParserVIRTUAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case StmtParserSERIAL:
		localctx = NewSerialDefaultColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(302)
			p.Match(StmtParserSERIAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(303)
			p.Match(StmtParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(304)
			p.Match(StmtParserVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserCHECK, StmtParserCONSTRAINT:
		localctx = NewCheckColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		p.SetState(309)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCONSTRAINT {
			{
				p.SetState(305)
				p.Match(StmtParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(307)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72129216912687104) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&73333234766712913) != 0) || ((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&67175041) != 0) || ((int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17174494689) != 0) || ((int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-137438953473) != 0) || ((int64((_la-339)) & ^0x3f) == 0 && ((int64(1)<<(_la-339))&-1) != 0) || ((int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&-262145) != 0) || ((int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&-1) != 0) || ((int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&-70368744181761) != 0) || ((int64((_la-595)) & ^0x3f) == 0 && ((int64(1)<<(_la-595))&-35184405643265) != 0) || ((int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-288308991769968705) != 0) || ((int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-3458764513820540929) != 0) || ((int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-1) != 0) || ((int64((_la-852)) & ^0x3f) == 0 && ((int64(1)<<(_la-852))&-1) != 0) || ((int64((_la-916)) & ^0x3f) == 0 && ((int64(1)<<(_la-916))&-1) != 0) || ((int64((_la-980)) & ^0x3f) == 0 && ((int64(1)<<(_la-980))&-1) != 0) || ((int64((_la-1044)) & ^0x3f) == 0 && ((int64(1)<<(_la-1044))&18014398509481983) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&25807552513) != 0) {
				{
					p.SetState(306)

					var _x = p.Uid()

					localctx.(*CheckColumnConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(311)
			p.Match(StmtParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(312)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(313)
			p.expression(0)
		}
		{
			p.SetState(314)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableConstraintContext is an interface to support dynamic dispatch.
type ITableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableConstraintContext differentiates from other interfaces.
	IsTableConstraintContext()
}

type TableConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableConstraintContext() *TableConstraintContext {
	var p = new(TableConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_tableConstraint
	return p
}

func InitEmptyTableConstraintContext(p *TableConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_tableConstraint
}

func (*TableConstraintContext) IsTableConstraintContext() {}

func NewTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableConstraintContext {
	var p = new(TableConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_tableConstraint

	return p
}

func (s *TableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TableConstraintContext) CopyAll(ctx *TableConstraintContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UniqueKeyTableConstraintContext struct {
	TableConstraintContext
	name        IUidContext
	indexFormat antlr.Token
	index       IUidContext
}

func NewUniqueKeyTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UniqueKeyTableConstraintContext {
	var p = new(UniqueKeyTableConstraintContext)

	InitEmptyTableConstraintContext(&p.TableConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableConstraintContext))

	return p
}

func (s *UniqueKeyTableConstraintContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *UniqueKeyTableConstraintContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *UniqueKeyTableConstraintContext) GetName() IUidContext { return s.name }

func (s *UniqueKeyTableConstraintContext) GetIndex() IUidContext { return s.index }

func (s *UniqueKeyTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *UniqueKeyTableConstraintContext) SetIndex(v IUidContext) { s.index = v }

func (s *UniqueKeyTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueKeyTableConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(StmtParserUNIQUE, 0)
}

func (s *UniqueKeyTableConstraintContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *UniqueKeyTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONSTRAINT, 0)
}

func (s *UniqueKeyTableConstraintContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *UniqueKeyTableConstraintContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *UniqueKeyTableConstraintContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *UniqueKeyTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *UniqueKeyTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UniqueKeyTableConstraintContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StmtParserINDEX, 0)
}

func (s *UniqueKeyTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY, 0)
}

func (s *UniqueKeyTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterUniqueKeyTableConstraint(s)
	}
}

func (s *UniqueKeyTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitUniqueKeyTableConstraint(s)
	}
}

type CheckTableConstraintContext struct {
	TableConstraintContext
	name IUidContext
}

func NewCheckTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CheckTableConstraintContext {
	var p = new(CheckTableConstraintContext)

	InitEmptyTableConstraintContext(&p.TableConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableConstraintContext))

	return p
}

func (s *CheckTableConstraintContext) GetName() IUidContext { return s.name }

func (s *CheckTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *CheckTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckTableConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(StmtParserCHECK, 0)
}

func (s *CheckTableConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *CheckTableConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CheckTableConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *CheckTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONSTRAINT, 0)
}

func (s *CheckTableConstraintContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CheckTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCheckTableConstraint(s)
	}
}

func (s *CheckTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCheckTableConstraint(s)
	}
}

type PrimaryKeyTableConstraintContext struct {
	TableConstraintContext
	name  IUidContext
	index IUidContext
}

func NewPrimaryKeyTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryKeyTableConstraintContext {
	var p = new(PrimaryKeyTableConstraintContext)

	InitEmptyTableConstraintContext(&p.TableConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableConstraintContext))

	return p
}

func (s *PrimaryKeyTableConstraintContext) GetName() IUidContext { return s.name }

func (s *PrimaryKeyTableConstraintContext) GetIndex() IUidContext { return s.index }

func (s *PrimaryKeyTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *PrimaryKeyTableConstraintContext) SetIndex(v IUidContext) { s.index = v }

func (s *PrimaryKeyTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyTableConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(StmtParserPRIMARY, 0)
}

func (s *PrimaryKeyTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY, 0)
}

func (s *PrimaryKeyTableConstraintContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *PrimaryKeyTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONSTRAINT, 0)
}

func (s *PrimaryKeyTableConstraintContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *PrimaryKeyTableConstraintContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *PrimaryKeyTableConstraintContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *PrimaryKeyTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *PrimaryKeyTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PrimaryKeyTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPrimaryKeyTableConstraint(s)
	}
}

func (s *PrimaryKeyTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPrimaryKeyTableConstraint(s)
	}
}

type ForeignKeyTableConstraintContext struct {
	TableConstraintContext
	name  IUidContext
	index IUidContext
}

func NewForeignKeyTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForeignKeyTableConstraintContext {
	var p = new(ForeignKeyTableConstraintContext)

	InitEmptyTableConstraintContext(&p.TableConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableConstraintContext))

	return p
}

func (s *ForeignKeyTableConstraintContext) GetName() IUidContext { return s.name }

func (s *ForeignKeyTableConstraintContext) GetIndex() IUidContext { return s.index }

func (s *ForeignKeyTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *ForeignKeyTableConstraintContext) SetIndex(v IUidContext) { s.index = v }

func (s *ForeignKeyTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeignKeyTableConstraintContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(StmtParserFOREIGN, 0)
}

func (s *ForeignKeyTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY, 0)
}

func (s *ForeignKeyTableConstraintContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *ForeignKeyTableConstraintContext) ReferenceDefinition() IReferenceDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceDefinitionContext)
}

func (s *ForeignKeyTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONSTRAINT, 0)
}

func (s *ForeignKeyTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *ForeignKeyTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ForeignKeyTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterForeignKeyTableConstraint(s)
	}
}

func (s *ForeignKeyTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitForeignKeyTableConstraint(s)
	}
}

func (p *StmtParser) TableConstraint() (localctx ITableConstraintContext) {
	localctx = NewTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, StmtParserRULE_tableConstraint)
	var _la int

	p.SetState(387)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPrimaryKeyTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(322)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCONSTRAINT {
			{
				p.SetState(318)
				p.Match(StmtParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(320)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(319)

					var _x = p.Uid()

					localctx.(*PrimaryKeyTableConstraintContext).name = _x
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		{
			p.SetState(324)
			p.Match(StmtParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(325)
			p.Match(StmtParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72129216912687104) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&73333234766712913) != 0) || ((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&67175041) != 0) || ((int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17174494689) != 0) || ((int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-137438953473) != 0) || ((int64((_la-339)) & ^0x3f) == 0 && ((int64(1)<<(_la-339))&-1) != 0) || ((int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&-262145) != 0) || ((int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&-1) != 0) || ((int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&-70368744181761) != 0) || ((int64((_la-595)) & ^0x3f) == 0 && ((int64(1)<<(_la-595))&-35184405643265) != 0) || ((int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-288308991769968705) != 0) || ((int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-3458764513820540929) != 0) || ((int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-1) != 0) || ((int64((_la-852)) & ^0x3f) == 0 && ((int64(1)<<(_la-852))&-1) != 0) || ((int64((_la-916)) & ^0x3f) == 0 && ((int64(1)<<(_la-916))&-1) != 0) || ((int64((_la-980)) & ^0x3f) == 0 && ((int64(1)<<(_la-980))&-1) != 0) || ((int64((_la-1044)) & ^0x3f) == 0 && ((int64(1)<<(_la-1044))&18014398509481983) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&25807552513) != 0) {
			{
				p.SetState(326)

				var _x = p.Uid()

				localctx.(*PrimaryKeyTableConstraintContext).index = _x
			}

		}
		p.SetState(330)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserUSING {
			{
				p.SetState(329)
				p.IndexType()
			}

		}
		{
			p.SetState(332)
			p.IndexColumnNames()
		}
		p.SetState(336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserIGNORED || _la == StmtParserNOT || _la == StmtParserUSING || _la == StmtParserWITH || _la == StmtParserCLUSTERING || _la == StmtParserCOMMENT || _la == StmtParserINVISIBLE || _la == StmtParserKEY_BLOCK_SIZE || _la == StmtParserVISIBLE || _la == StmtParserENGINE_ATTRIBUTE || _la == StmtParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(333)
				p.IndexOption()
			}

			p.SetState(338)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewUniqueKeyTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(343)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCONSTRAINT {
			{
				p.SetState(339)
				p.Match(StmtParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(341)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72129216912687104) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&73333234766712913) != 0) || ((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&67175041) != 0) || ((int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17174494689) != 0) || ((int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-137438953473) != 0) || ((int64((_la-339)) & ^0x3f) == 0 && ((int64(1)<<(_la-339))&-1) != 0) || ((int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&-262145) != 0) || ((int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&-1) != 0) || ((int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&-70368744181761) != 0) || ((int64((_la-595)) & ^0x3f) == 0 && ((int64(1)<<(_la-595))&-35184405643265) != 0) || ((int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-288308991769968705) != 0) || ((int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-3458764513820540929) != 0) || ((int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-1) != 0) || ((int64((_la-852)) & ^0x3f) == 0 && ((int64(1)<<(_la-852))&-1) != 0) || ((int64((_la-916)) & ^0x3f) == 0 && ((int64(1)<<(_la-916))&-1) != 0) || ((int64((_la-980)) & ^0x3f) == 0 && ((int64(1)<<(_la-980))&-1) != 0) || ((int64((_la-1044)) & ^0x3f) == 0 && ((int64(1)<<(_la-1044))&18014398509481983) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&25807552513) != 0) {
				{
					p.SetState(340)

					var _x = p.Uid()

					localctx.(*UniqueKeyTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(345)
			p.Match(StmtParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(347)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserINDEX || _la == StmtParserKEY {
			{
				p.SetState(346)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*UniqueKeyTableConstraintContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == StmtParserINDEX || _la == StmtParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*UniqueKeyTableConstraintContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(350)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72129216912687104) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&73333234766712913) != 0) || ((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&67175041) != 0) || ((int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17174494689) != 0) || ((int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-137438953473) != 0) || ((int64((_la-339)) & ^0x3f) == 0 && ((int64(1)<<(_la-339))&-1) != 0) || ((int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&-262145) != 0) || ((int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&-1) != 0) || ((int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&-70368744181761) != 0) || ((int64((_la-595)) & ^0x3f) == 0 && ((int64(1)<<(_la-595))&-35184405643265) != 0) || ((int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-288308991769968705) != 0) || ((int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-3458764513820540929) != 0) || ((int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-1) != 0) || ((int64((_la-852)) & ^0x3f) == 0 && ((int64(1)<<(_la-852))&-1) != 0) || ((int64((_la-916)) & ^0x3f) == 0 && ((int64(1)<<(_la-916))&-1) != 0) || ((int64((_la-980)) & ^0x3f) == 0 && ((int64(1)<<(_la-980))&-1) != 0) || ((int64((_la-1044)) & ^0x3f) == 0 && ((int64(1)<<(_la-1044))&18014398509481983) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&25807552513) != 0) {
			{
				p.SetState(349)

				var _x = p.Uid()

				localctx.(*UniqueKeyTableConstraintContext).index = _x
			}

		}
		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserUSING {
			{
				p.SetState(352)
				p.IndexType()
			}

		}
		{
			p.SetState(355)
			p.IndexColumnNames()
		}
		p.SetState(359)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserIGNORED || _la == StmtParserNOT || _la == StmtParserUSING || _la == StmtParserWITH || _la == StmtParserCLUSTERING || _la == StmtParserCOMMENT || _la == StmtParserINVISIBLE || _la == StmtParserKEY_BLOCK_SIZE || _la == StmtParserVISIBLE || _la == StmtParserENGINE_ATTRIBUTE || _la == StmtParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(356)
				p.IndexOption()
			}

			p.SetState(361)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewForeignKeyTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(366)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCONSTRAINT {
			{
				p.SetState(362)
				p.Match(StmtParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(364)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72129216912687104) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&73333234766712913) != 0) || ((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&67175041) != 0) || ((int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17174494689) != 0) || ((int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-137438953473) != 0) || ((int64((_la-339)) & ^0x3f) == 0 && ((int64(1)<<(_la-339))&-1) != 0) || ((int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&-262145) != 0) || ((int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&-1) != 0) || ((int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&-70368744181761) != 0) || ((int64((_la-595)) & ^0x3f) == 0 && ((int64(1)<<(_la-595))&-35184405643265) != 0) || ((int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-288308991769968705) != 0) || ((int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-3458764513820540929) != 0) || ((int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-1) != 0) || ((int64((_la-852)) & ^0x3f) == 0 && ((int64(1)<<(_la-852))&-1) != 0) || ((int64((_la-916)) & ^0x3f) == 0 && ((int64(1)<<(_la-916))&-1) != 0) || ((int64((_la-980)) & ^0x3f) == 0 && ((int64(1)<<(_la-980))&-1) != 0) || ((int64((_la-1044)) & ^0x3f) == 0 && ((int64(1)<<(_la-1044))&18014398509481983) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&25807552513) != 0) {
				{
					p.SetState(363)

					var _x = p.Uid()

					localctx.(*ForeignKeyTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(368)
			p.Match(StmtParserFOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(369)
			p.Match(StmtParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(371)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72129216912687104) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&73333234766712913) != 0) || ((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&67175041) != 0) || ((int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17174494689) != 0) || ((int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-137438953473) != 0) || ((int64((_la-339)) & ^0x3f) == 0 && ((int64(1)<<(_la-339))&-1) != 0) || ((int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&-262145) != 0) || ((int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&-1) != 0) || ((int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&-70368744181761) != 0) || ((int64((_la-595)) & ^0x3f) == 0 && ((int64(1)<<(_la-595))&-35184405643265) != 0) || ((int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-288308991769968705) != 0) || ((int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-3458764513820540929) != 0) || ((int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-1) != 0) || ((int64((_la-852)) & ^0x3f) == 0 && ((int64(1)<<(_la-852))&-1) != 0) || ((int64((_la-916)) & ^0x3f) == 0 && ((int64(1)<<(_la-916))&-1) != 0) || ((int64((_la-980)) & ^0x3f) == 0 && ((int64(1)<<(_la-980))&-1) != 0) || ((int64((_la-1044)) & ^0x3f) == 0 && ((int64(1)<<(_la-1044))&18014398509481983) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&25807552513) != 0) {
			{
				p.SetState(370)

				var _x = p.Uid()

				localctx.(*ForeignKeyTableConstraintContext).index = _x
			}

		}
		{
			p.SetState(373)
			p.IndexColumnNames()
		}
		{
			p.SetState(374)
			p.ReferenceDefinition()
		}

	case 4:
		localctx = NewCheckTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(380)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCONSTRAINT {
			{
				p.SetState(376)
				p.Match(StmtParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(378)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72129216912687104) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&73333234766712913) != 0) || ((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&67175041) != 0) || ((int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17174494689) != 0) || ((int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-137438953473) != 0) || ((int64((_la-339)) & ^0x3f) == 0 && ((int64(1)<<(_la-339))&-1) != 0) || ((int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&-262145) != 0) || ((int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&-1) != 0) || ((int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&-70368744181761) != 0) || ((int64((_la-595)) & ^0x3f) == 0 && ((int64(1)<<(_la-595))&-35184405643265) != 0) || ((int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-288308991769968705) != 0) || ((int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-3458764513820540929) != 0) || ((int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-1) != 0) || ((int64((_la-852)) & ^0x3f) == 0 && ((int64(1)<<(_la-852))&-1) != 0) || ((int64((_la-916)) & ^0x3f) == 0 && ((int64(1)<<(_la-916))&-1) != 0) || ((int64((_la-980)) & ^0x3f) == 0 && ((int64(1)<<(_la-980))&-1) != 0) || ((int64((_la-1044)) & ^0x3f) == 0 && ((int64(1)<<(_la-1044))&18014398509481983) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&25807552513) != 0) {
				{
					p.SetState(377)

					var _x = p.Uid()

					localctx.(*CheckTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(382)
			p.Match(StmtParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(383)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(384)
			p.expression(0)
		}
		{
			p.SetState(385)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferenceDefinitionContext is an interface to support dynamic dispatch.
type IReferenceDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMatchType returns the matchType token.
	GetMatchType() antlr.Token

	// SetMatchType sets the matchType token.
	SetMatchType(antlr.Token)

	// Getter signatures
	REFERENCES() antlr.TerminalNode
	TableName() ITableNameContext
	IndexColumnNames() IIndexColumnNamesContext
	MATCH() antlr.TerminalNode
	ReferenceAction() IReferenceActionContext
	FULL() antlr.TerminalNode
	PARTIAL() antlr.TerminalNode
	SIMPLE() antlr.TerminalNode

	// IsReferenceDefinitionContext differentiates from other interfaces.
	IsReferenceDefinitionContext()
}

type ReferenceDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	matchType antlr.Token
}

func NewEmptyReferenceDefinitionContext() *ReferenceDefinitionContext {
	var p = new(ReferenceDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_referenceDefinition
	return p
}

func InitEmptyReferenceDefinitionContext(p *ReferenceDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_referenceDefinition
}

func (*ReferenceDefinitionContext) IsReferenceDefinitionContext() {}

func NewReferenceDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceDefinitionContext {
	var p = new(ReferenceDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_referenceDefinition

	return p
}

func (s *ReferenceDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceDefinitionContext) GetMatchType() antlr.Token { return s.matchType }

func (s *ReferenceDefinitionContext) SetMatchType(v antlr.Token) { s.matchType = v }

func (s *ReferenceDefinitionContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(StmtParserREFERENCES, 0)
}

func (s *ReferenceDefinitionContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ReferenceDefinitionContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *ReferenceDefinitionContext) MATCH() antlr.TerminalNode {
	return s.GetToken(StmtParserMATCH, 0)
}

func (s *ReferenceDefinitionContext) ReferenceAction() IReferenceActionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceActionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceActionContext)
}

func (s *ReferenceDefinitionContext) FULL() antlr.TerminalNode {
	return s.GetToken(StmtParserFULL, 0)
}

func (s *ReferenceDefinitionContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTIAL, 0)
}

func (s *ReferenceDefinitionContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(StmtParserSIMPLE, 0)
}

func (s *ReferenceDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterReferenceDefinition(s)
	}
}

func (s *ReferenceDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitReferenceDefinition(s)
	}
}

func (p *StmtParser) ReferenceDefinition() (localctx IReferenceDefinitionContext) {
	localctx = NewReferenceDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, StmtParserRULE_referenceDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(389)
		p.Match(StmtParserREFERENCES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(390)
		p.TableName()
	}
	p.SetState(392)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserLR_BRACKET {
		{
			p.SetState(391)
			p.IndexColumnNames()
		}

	}
	p.SetState(396)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserMATCH {
		{
			p.SetState(394)
			p.Match(StmtParserMATCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(395)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ReferenceDefinitionContext).matchType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserFULL || _la == StmtParserPARTIAL || _la == StmtParserSIMPLE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ReferenceDefinitionContext).matchType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(399)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(398)
			p.ReferenceAction()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferenceActionContext is an interface to support dynamic dispatch.
type IReferenceActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOnDelete returns the onDelete rule contexts.
	GetOnDelete() IReferenceControlTypeContext

	// GetOnUpdate returns the onUpdate rule contexts.
	GetOnUpdate() IReferenceControlTypeContext

	// SetOnDelete sets the onDelete rule contexts.
	SetOnDelete(IReferenceControlTypeContext)

	// SetOnUpdate sets the onUpdate rule contexts.
	SetOnUpdate(IReferenceControlTypeContext)

	// Getter signatures
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	DELETE() antlr.TerminalNode
	AllReferenceControlType() []IReferenceControlTypeContext
	ReferenceControlType(i int) IReferenceControlTypeContext
	UPDATE() antlr.TerminalNode

	// IsReferenceActionContext differentiates from other interfaces.
	IsReferenceActionContext()
}

type ReferenceActionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	onDelete IReferenceControlTypeContext
	onUpdate IReferenceControlTypeContext
}

func NewEmptyReferenceActionContext() *ReferenceActionContext {
	var p = new(ReferenceActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_referenceAction
	return p
}

func InitEmptyReferenceActionContext(p *ReferenceActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_referenceAction
}

func (*ReferenceActionContext) IsReferenceActionContext() {}

func NewReferenceActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceActionContext {
	var p = new(ReferenceActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_referenceAction

	return p
}

func (s *ReferenceActionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceActionContext) GetOnDelete() IReferenceControlTypeContext { return s.onDelete }

func (s *ReferenceActionContext) GetOnUpdate() IReferenceControlTypeContext { return s.onUpdate }

func (s *ReferenceActionContext) SetOnDelete(v IReferenceControlTypeContext) { s.onDelete = v }

func (s *ReferenceActionContext) SetOnUpdate(v IReferenceControlTypeContext) { s.onUpdate = v }

func (s *ReferenceActionContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(StmtParserON)
}

func (s *ReferenceActionContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserON, i)
}

func (s *ReferenceActionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(StmtParserDELETE, 0)
}

func (s *ReferenceActionContext) AllReferenceControlType() []IReferenceControlTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReferenceControlTypeContext); ok {
			len++
		}
	}

	tst := make([]IReferenceControlTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReferenceControlTypeContext); ok {
			tst[i] = t.(IReferenceControlTypeContext)
			i++
		}
	}

	return tst
}

func (s *ReferenceActionContext) ReferenceControlType(i int) IReferenceControlTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceControlTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceControlTypeContext)
}

func (s *ReferenceActionContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(StmtParserUPDATE, 0)
}

func (s *ReferenceActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterReferenceAction(s)
	}
}

func (s *ReferenceActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitReferenceAction(s)
	}
}

func (p *StmtParser) ReferenceAction() (localctx IReferenceActionContext) {
	localctx = NewReferenceActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, StmtParserRULE_referenceAction)
	p.SetState(417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(401)
			p.Match(StmtParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(402)
			p.Match(StmtParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(403)

			var _x = p.ReferenceControlType()

			localctx.(*ReferenceActionContext).onDelete = _x
		}
		p.SetState(407)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(404)
				p.Match(StmtParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(405)
				p.Match(StmtParserUPDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(406)

				var _x = p.ReferenceControlType()

				localctx.(*ReferenceActionContext).onUpdate = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(409)
			p.Match(StmtParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(410)
			p.Match(StmtParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(411)

			var _x = p.ReferenceControlType()

			localctx.(*ReferenceActionContext).onUpdate = _x
		}
		p.SetState(415)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(412)
				p.Match(StmtParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(413)
				p.Match(StmtParserDELETE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(414)

				var _x = p.ReferenceControlType()

				localctx.(*ReferenceActionContext).onDelete = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferenceControlTypeContext is an interface to support dynamic dispatch.
type IReferenceControlTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESTRICT() antlr.TerminalNode
	CASCADE() antlr.TerminalNode
	SET() antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	NO() antlr.TerminalNode
	ACTION() antlr.TerminalNode

	// IsReferenceControlTypeContext differentiates from other interfaces.
	IsReferenceControlTypeContext()
}

type ReferenceControlTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceControlTypeContext() *ReferenceControlTypeContext {
	var p = new(ReferenceControlTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_referenceControlType
	return p
}

func InitEmptyReferenceControlTypeContext(p *ReferenceControlTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_referenceControlType
}

func (*ReferenceControlTypeContext) IsReferenceControlTypeContext() {}

func NewReferenceControlTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceControlTypeContext {
	var p = new(ReferenceControlTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_referenceControlType

	return p
}

func (s *ReferenceControlTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceControlTypeContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(StmtParserRESTRICT, 0)
}

func (s *ReferenceControlTypeContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(StmtParserCASCADE, 0)
}

func (s *ReferenceControlTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(StmtParserSET, 0)
}

func (s *ReferenceControlTypeContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNULL_LITERAL, 0)
}

func (s *ReferenceControlTypeContext) NO() antlr.TerminalNode {
	return s.GetToken(StmtParserNO, 0)
}

func (s *ReferenceControlTypeContext) ACTION() antlr.TerminalNode {
	return s.GetToken(StmtParserACTION, 0)
}

func (s *ReferenceControlTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceControlTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceControlTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterReferenceControlType(s)
	}
}

func (s *ReferenceControlTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitReferenceControlType(s)
	}
}

func (p *StmtParser) ReferenceControlType() (localctx IReferenceControlTypeContext) {
	localctx = NewReferenceControlTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, StmtParserRULE_referenceControlType)
	p.SetState(425)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StmtParserRESTRICT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(419)
			p.Match(StmtParserRESTRICT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserCASCADE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(420)
			p.Match(StmtParserCASCADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserSET:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(421)
			p.Match(StmtParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(422)
			p.Match(StmtParserNULL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserNO:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(423)
			p.Match(StmtParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(424)
			p.Match(StmtParserACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexColumnDefinitionContext is an interface to support dynamic dispatch.
type IIndexColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIndexColumnDefinitionContext differentiates from other interfaces.
	IsIndexColumnDefinitionContext()
}

type IndexColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexColumnDefinitionContext() *IndexColumnDefinitionContext {
	var p = new(IndexColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_indexColumnDefinition
	return p
}

func InitEmptyIndexColumnDefinitionContext(p *IndexColumnDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_indexColumnDefinition
}

func (*IndexColumnDefinitionContext) IsIndexColumnDefinitionContext() {}

func NewIndexColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnDefinitionContext {
	var p = new(IndexColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_indexColumnDefinition

	return p
}

func (s *IndexColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnDefinitionContext) CopyAll(ctx *IndexColumnDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IndexColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SpecialIndexDeclarationContext struct {
	IndexColumnDefinitionContext
	indexFormat antlr.Token
}

func NewSpecialIndexDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialIndexDeclarationContext {
	var p = new(SpecialIndexDeclarationContext)

	InitEmptyIndexColumnDefinitionContext(&p.IndexColumnDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*IndexColumnDefinitionContext))

	return p
}

func (s *SpecialIndexDeclarationContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *SpecialIndexDeclarationContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *SpecialIndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialIndexDeclarationContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *SpecialIndexDeclarationContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserFULLTEXT, 0)
}

func (s *SpecialIndexDeclarationContext) SPATIAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSPATIAL, 0)
}

func (s *SpecialIndexDeclarationContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SpecialIndexDeclarationContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *SpecialIndexDeclarationContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *SpecialIndexDeclarationContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StmtParserINDEX, 0)
}

func (s *SpecialIndexDeclarationContext) KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY, 0)
}

func (s *SpecialIndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSpecialIndexDeclaration(s)
	}
}

func (s *SpecialIndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSpecialIndexDeclaration(s)
	}
}

type SimpleIndexDeclarationContext struct {
	IndexColumnDefinitionContext
	indexFormat antlr.Token
}

func NewSimpleIndexDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleIndexDeclarationContext {
	var p = new(SimpleIndexDeclarationContext)

	InitEmptyIndexColumnDefinitionContext(&p.IndexColumnDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*IndexColumnDefinitionContext))

	return p
}

func (s *SimpleIndexDeclarationContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *SimpleIndexDeclarationContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *SimpleIndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIndexDeclarationContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *SimpleIndexDeclarationContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StmtParserINDEX, 0)
}

func (s *SimpleIndexDeclarationContext) KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY, 0)
}

func (s *SimpleIndexDeclarationContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SimpleIndexDeclarationContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *SimpleIndexDeclarationContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleIndexDeclarationContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *SimpleIndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSimpleIndexDeclaration(s)
	}
}

func (s *SimpleIndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSimpleIndexDeclaration(s)
	}
}

func (p *StmtParser) IndexColumnDefinition() (localctx IIndexColumnDefinitionContext) {
	localctx = NewIndexColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, StmtParserRULE_indexColumnDefinition)
	var _la int

	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StmtParserINDEX, StmtParserKEY:
		localctx = NewSimpleIndexDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(427)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SimpleIndexDeclarationContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserINDEX || _la == StmtParserKEY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SimpleIndexDeclarationContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(429)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72129216912687104) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&73333234766712913) != 0) || ((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&67175041) != 0) || ((int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17174494689) != 0) || ((int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-137438953473) != 0) || ((int64((_la-339)) & ^0x3f) == 0 && ((int64(1)<<(_la-339))&-1) != 0) || ((int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&-262145) != 0) || ((int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&-1) != 0) || ((int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&-70368744181761) != 0) || ((int64((_la-595)) & ^0x3f) == 0 && ((int64(1)<<(_la-595))&-35184405643265) != 0) || ((int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-288308991769968705) != 0) || ((int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-3458764513820540929) != 0) || ((int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-1) != 0) || ((int64((_la-852)) & ^0x3f) == 0 && ((int64(1)<<(_la-852))&-1) != 0) || ((int64((_la-916)) & ^0x3f) == 0 && ((int64(1)<<(_la-916))&-1) != 0) || ((int64((_la-980)) & ^0x3f) == 0 && ((int64(1)<<(_la-980))&-1) != 0) || ((int64((_la-1044)) & ^0x3f) == 0 && ((int64(1)<<(_la-1044))&18014398509481983) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&25807552513) != 0) {
			{
				p.SetState(428)
				p.Uid()
			}

		}
		p.SetState(432)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserUSING {
			{
				p.SetState(431)
				p.IndexType()
			}

		}
		{
			p.SetState(434)
			p.IndexColumnNames()
		}
		p.SetState(438)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserIGNORED || _la == StmtParserNOT || _la == StmtParserUSING || _la == StmtParserWITH || _la == StmtParserCLUSTERING || _la == StmtParserCOMMENT || _la == StmtParserINVISIBLE || _la == StmtParserKEY_BLOCK_SIZE || _la == StmtParserVISIBLE || _la == StmtParserENGINE_ATTRIBUTE || _la == StmtParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(435)
				p.IndexOption()
			}

			p.SetState(440)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case StmtParserFULLTEXT, StmtParserSPATIAL:
		localctx = NewSpecialIndexDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(441)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserFULLTEXT || _la == StmtParserSPATIAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserINDEX || _la == StmtParserKEY {
			{
				p.SetState(442)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SpecialIndexDeclarationContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == StmtParserINDEX || _la == StmtParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SpecialIndexDeclarationContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(446)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72129216912687104) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&73333234766712913) != 0) || ((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&67175041) != 0) || ((int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17174494689) != 0) || ((int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-137438953473) != 0) || ((int64((_la-339)) & ^0x3f) == 0 && ((int64(1)<<(_la-339))&-1) != 0) || ((int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&-262145) != 0) || ((int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&-1) != 0) || ((int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&-70368744181761) != 0) || ((int64((_la-595)) & ^0x3f) == 0 && ((int64(1)<<(_la-595))&-35184405643265) != 0) || ((int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-288308991769968705) != 0) || ((int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-3458764513820540929) != 0) || ((int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-1) != 0) || ((int64((_la-852)) & ^0x3f) == 0 && ((int64(1)<<(_la-852))&-1) != 0) || ((int64((_la-916)) & ^0x3f) == 0 && ((int64(1)<<(_la-916))&-1) != 0) || ((int64((_la-980)) & ^0x3f) == 0 && ((int64(1)<<(_la-980))&-1) != 0) || ((int64((_la-1044)) & ^0x3f) == 0 && ((int64(1)<<(_la-1044))&18014398509481983) != 0) || ((int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&25807552513) != 0) {
			{
				p.SetState(445)
				p.Uid()
			}

		}
		{
			p.SetState(448)
			p.IndexColumnNames()
		}
		p.SetState(452)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserIGNORED || _la == StmtParserNOT || _la == StmtParserUSING || _la == StmtParserWITH || _la == StmtParserCLUSTERING || _la == StmtParserCOMMENT || _la == StmtParserINVISIBLE || _la == StmtParserKEY_BLOCK_SIZE || _la == StmtParserVISIBLE || _la == StmtParserENGINE_ATTRIBUTE || _la == StmtParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(449)
				p.IndexOption()
			}

			p.SetState(454)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableOptionContext is an interface to support dynamic dispatch.
type ITableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableOptionContext differentiates from other interfaces.
	IsTableOptionContext()
}

type TableOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOptionContext() *TableOptionContext {
	var p = new(TableOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_tableOption
	return p
}

func InitEmptyTableOptionContext(p *TableOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_tableOption
}

func (*TableOptionContext) IsTableOptionContext() {}

func NewTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOptionContext {
	var p = new(TableOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_tableOption

	return p
}

func (s *TableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOptionContext) CopyAll(ctx *TableOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableOptionEngineContext struct {
	TableOptionContext
}

func NewTableOptionEngineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEngineContext {
	var p = new(TableOptionEngineContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEngineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEngineContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(StmtParserENGINE, 0)
}

func (s *TableOptionEngineContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEngineContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *TableOptionEngineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionEngine(s)
	}
}

func (s *TableOptionEngineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionEngine(s)
	}
}

type TableOptionMaxRowsContext struct {
	TableOptionContext
}

func NewTableOptionMaxRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionMaxRowsContext {
	var p = new(TableOptionMaxRowsContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionMaxRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionMaxRowsContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(StmtParserMAX_ROWS, 0)
}

func (s *TableOptionMaxRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionMaxRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionMaxRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionMaxRows(s)
	}
}

func (s *TableOptionMaxRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionMaxRows(s)
	}
}

type TableOptionCollateContext struct {
	TableOptionContext
}

func NewTableOptionCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCollateContext {
	var p = new(TableOptionCollateContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCollateContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLLATE, 0)
}

func (s *TableOptionCollateContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *TableOptionCollateContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *TableOptionCollateContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionCollate(s)
	}
}

func (s *TableOptionCollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionCollate(s)
	}
}

type TableOptionPersistentContext struct {
	TableOptionContext
	extBoolValue antlr.Token
}

func NewTableOptionPersistentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPersistentContext {
	var p = new(TableOptionPersistentContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPersistentContext) GetExtBoolValue() antlr.Token { return s.extBoolValue }

func (s *TableOptionPersistentContext) SetExtBoolValue(v antlr.Token) { s.extBoolValue = v }

func (s *TableOptionPersistentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPersistentContext) STATS_PERSISTENT() antlr.TerminalNode {
	return s.GetToken(StmtParserSTATS_PERSISTENT, 0)
}

func (s *TableOptionPersistentContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *TableOptionPersistentContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserZERO_DECIMAL, 0)
}

func (s *TableOptionPersistentContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserONE_DECIMAL, 0)
}

func (s *TableOptionPersistentContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPersistentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionPersistent(s)
	}
}

func (s *TableOptionPersistentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionPersistent(s)
	}
}

type TableOptionTablespaceContext struct {
	TableOptionContext
}

func NewTableOptionTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionTablespaceContext {
	var p = new(TableOptionTablespaceContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(StmtParserTABLESPACE, 0)
}

func (s *TableOptionTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *TableOptionTablespaceContext) TablespaceStorage() ITablespaceStorageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceStorageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceStorageContext)
}

func (s *TableOptionTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionTablespace(s)
	}
}

func (s *TableOptionTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionTablespace(s)
	}
}

type TableOptionAutoextendSizeContext struct {
	TableOptionContext
}

func NewTableOptionAutoextendSizeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionAutoextendSizeContext {
	var p = new(TableOptionAutoextendSizeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionAutoextendSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionAutoextendSizeContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserAUTOEXTEND_SIZE, 0)
}

func (s *TableOptionAutoextendSizeContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionAutoextendSizeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionAutoextendSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionAutoextendSize(s)
	}
}

func (s *TableOptionAutoextendSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionAutoextendSize(s)
	}
}

type TableOptionStartTransactionContext struct {
	TableOptionContext
}

func NewTableOptionStartTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionStartTransactionContext {
	var p = new(TableOptionStartTransactionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionStartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionStartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(StmtParserSTART, 0)
}

func (s *TableOptionStartTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(StmtParserTRANSACTION, 0)
}

func (s *TableOptionStartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionStartTransaction(s)
	}
}

func (s *TableOptionStartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionStartTransaction(s)
	}
}

type TableOptionPackKeysContext struct {
	TableOptionContext
	extBoolValue antlr.Token
}

func NewTableOptionPackKeysContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPackKeysContext {
	var p = new(TableOptionPackKeysContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPackKeysContext) GetExtBoolValue() antlr.Token { return s.extBoolValue }

func (s *TableOptionPackKeysContext) SetExtBoolValue(v antlr.Token) { s.extBoolValue = v }

func (s *TableOptionPackKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPackKeysContext) PACK_KEYS() antlr.TerminalNode {
	return s.GetToken(StmtParserPACK_KEYS, 0)
}

func (s *TableOptionPackKeysContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserZERO_DECIMAL, 0)
}

func (s *TableOptionPackKeysContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserONE_DECIMAL, 0)
}

func (s *TableOptionPackKeysContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *TableOptionPackKeysContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPackKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionPackKeys(s)
	}
}

func (s *TableOptionPackKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionPackKeys(s)
	}
}

type TableOptionPasswordContext struct {
	TableOptionContext
}

func NewTableOptionPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPasswordContext {
	var p = new(TableOptionPasswordContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPasswordContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(StmtParserPASSWORD, 0)
}

func (s *TableOptionPasswordContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *TableOptionPasswordContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionPassword(s)
	}
}

func (s *TableOptionPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionPassword(s)
	}
}

type TableOptionUnionContext struct {
	TableOptionContext
}

func NewTableOptionUnionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionUnionContext {
	var p = new(TableOptionUnionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionUnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionUnionContext) UNION() antlr.TerminalNode {
	return s.GetToken(StmtParserUNION, 0)
}

func (s *TableOptionUnionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *TableOptionUnionContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *TableOptionUnionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *TableOptionUnionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionUnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionUnion(s)
	}
}

func (s *TableOptionUnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionUnion(s)
	}
}

type TableOptionSamplePageContext struct {
	TableOptionContext
	extValue antlr.Token
}

func NewTableOptionSamplePageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionSamplePageContext {
	var p = new(TableOptionSamplePageContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionSamplePageContext) GetExtValue() antlr.Token { return s.extValue }

func (s *TableOptionSamplePageContext) SetExtValue(v antlr.Token) { s.extValue = v }

func (s *TableOptionSamplePageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionSamplePageContext) STATS_SAMPLE_PAGES() antlr.TerminalNode {
	return s.GetToken(StmtParserSTATS_SAMPLE_PAGES, 0)
}

func (s *TableOptionSamplePageContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *TableOptionSamplePageContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserDECIMAL_LITERAL, 0)
}

func (s *TableOptionSamplePageContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionSamplePageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionSamplePage(s)
	}
}

func (s *TableOptionSamplePageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionSamplePage(s)
	}
}

type TableOptionCharsetContext struct {
	TableOptionContext
}

func NewTableOptionCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCharsetContext {
	var p = new(TableOptionCharsetContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCharsetContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *TableOptionCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *TableOptionCharsetContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(StmtParserDEFAULT)
}

func (s *TableOptionCharsetContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, i)
}

func (s *TableOptionCharsetContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionCharset(s)
	}
}

func (s *TableOptionCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionCharset(s)
	}
}

type TableOptionIndexDirectoryContext struct {
	TableOptionContext
}

func NewTableOptionIndexDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionIndexDirectoryContext {
	var p = new(TableOptionIndexDirectoryContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionIndexDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionIndexDirectoryContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StmtParserINDEX, 0)
}

func (s *TableOptionIndexDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(StmtParserDIRECTORY, 0)
}

func (s *TableOptionIndexDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *TableOptionIndexDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionIndexDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionIndexDirectory(s)
	}
}

func (s *TableOptionIndexDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionIndexDirectory(s)
	}
}

type TableOptionTableTypeContext struct {
	TableOptionContext
}

func NewTableOptionTableTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionTableTypeContext {
	var p = new(TableOptionTableTypeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionTableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionTableTypeContext) TABLE_TYPE() antlr.TerminalNode {
	return s.GetToken(StmtParserTABLE_TYPE, 0)
}

func (s *TableOptionTableTypeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionTableTypeContext) TableType() ITableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableTypeContext)
}

func (s *TableOptionTableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionTableType(s)
	}
}

func (s *TableOptionTableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionTableType(s)
	}
}

type TableOptionKeyBlockSizeContext struct {
	TableOptionContext
}

func NewTableOptionKeyBlockSizeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionKeyBlockSizeContext {
	var p = new(TableOptionKeyBlockSizeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionKeyBlockSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionKeyBlockSizeContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY_BLOCK_SIZE, 0)
}

func (s *TableOptionKeyBlockSizeContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *TableOptionKeyBlockSizeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionKeyBlockSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionKeyBlockSize(s)
	}
}

func (s *TableOptionKeyBlockSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionKeyBlockSize(s)
	}
}

type TableOptionEncryptionContext struct {
	TableOptionContext
}

func NewTableOptionEncryptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEncryptionContext {
	var p = new(TableOptionEncryptionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEncryptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEncryptionContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(StmtParserENCRYPTION, 0)
}

func (s *TableOptionEncryptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *TableOptionEncryptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEncryptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionEncryption(s)
	}
}

func (s *TableOptionEncryptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionEncryption(s)
	}
}

type TableOptionDataDirectoryContext struct {
	TableOptionContext
}

func NewTableOptionDataDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionDataDirectoryContext {
	var p = new(TableOptionDataDirectoryContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionDataDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionDataDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(StmtParserDIRECTORY, 0)
}

func (s *TableOptionDataDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *TableOptionDataDirectoryContext) DATA() antlr.TerminalNode {
	return s.GetToken(StmtParserDATA, 0)
}

func (s *TableOptionDataDirectoryContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StmtParserINDEX, 0)
}

func (s *TableOptionDataDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionDataDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionDataDirectory(s)
	}
}

func (s *TableOptionDataDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionDataDirectory(s)
	}
}

type TableOptionRecalculationContext struct {
	TableOptionContext
	extBoolValue antlr.Token
}

func NewTableOptionRecalculationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionRecalculationContext {
	var p = new(TableOptionRecalculationContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionRecalculationContext) GetExtBoolValue() antlr.Token { return s.extBoolValue }

func (s *TableOptionRecalculationContext) SetExtBoolValue(v antlr.Token) { s.extBoolValue = v }

func (s *TableOptionRecalculationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionRecalculationContext) STATS_AUTO_RECALC() antlr.TerminalNode {
	return s.GetToken(StmtParserSTATS_AUTO_RECALC, 0)
}

func (s *TableOptionRecalculationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *TableOptionRecalculationContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserZERO_DECIMAL, 0)
}

func (s *TableOptionRecalculationContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserONE_DECIMAL, 0)
}

func (s *TableOptionRecalculationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionRecalculationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionRecalculation(s)
	}
}

func (s *TableOptionRecalculationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionRecalculation(s)
	}
}

type TableOptionAutoIncrementContext struct {
	TableOptionContext
}

func NewTableOptionAutoIncrementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionAutoIncrementContext {
	var p = new(TableOptionAutoIncrementContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionAutoIncrementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionAutoIncrementContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(StmtParserAUTO_INCREMENT, 0)
}

func (s *TableOptionAutoIncrementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionAutoIncrementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionAutoIncrementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionAutoIncrement(s)
	}
}

func (s *TableOptionAutoIncrementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionAutoIncrement(s)
	}
}

type TableOptionChecksumContext struct {
	TableOptionContext
	boolValue antlr.Token
}

func NewTableOptionChecksumContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionChecksumContext {
	var p = new(TableOptionChecksumContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionChecksumContext) GetBoolValue() antlr.Token { return s.boolValue }

func (s *TableOptionChecksumContext) SetBoolValue(v antlr.Token) { s.boolValue = v }

func (s *TableOptionChecksumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionChecksumContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(StmtParserCHECKSUM, 0)
}

func (s *TableOptionChecksumContext) PAGE_CHECKSUM() antlr.TerminalNode {
	return s.GetToken(StmtParserPAGE_CHECKSUM, 0)
}

func (s *TableOptionChecksumContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserZERO_DECIMAL, 0)
}

func (s *TableOptionChecksumContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserONE_DECIMAL, 0)
}

func (s *TableOptionChecksumContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionChecksumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionChecksum(s)
	}
}

func (s *TableOptionChecksumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionChecksum(s)
	}
}

type TableOptionDelayContext struct {
	TableOptionContext
	boolValue antlr.Token
}

func NewTableOptionDelayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionDelayContext {
	var p = new(TableOptionDelayContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionDelayContext) GetBoolValue() antlr.Token { return s.boolValue }

func (s *TableOptionDelayContext) SetBoolValue(v antlr.Token) { s.boolValue = v }

func (s *TableOptionDelayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionDelayContext) DELAY_KEY_WRITE() antlr.TerminalNode {
	return s.GetToken(StmtParserDELAY_KEY_WRITE, 0)
}

func (s *TableOptionDelayContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserZERO_DECIMAL, 0)
}

func (s *TableOptionDelayContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserONE_DECIMAL, 0)
}

func (s *TableOptionDelayContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionDelayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionDelay(s)
	}
}

func (s *TableOptionDelayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionDelay(s)
	}
}

type TableOptionConnectionContext struct {
	TableOptionContext
}

func NewTableOptionConnectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionConnectionContext {
	var p = new(TableOptionConnectionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionConnectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionConnectionContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(StmtParserCONNECTION, 0)
}

func (s *TableOptionConnectionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *TableOptionConnectionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionConnectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionConnection(s)
	}
}

func (s *TableOptionConnectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionConnection(s)
	}
}

type TableOptionSecondaryEngineAttributeContext struct {
	TableOptionContext
}

func NewTableOptionSecondaryEngineAttributeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionSecondaryEngineAttributeContext {
	var p = new(TableOptionSecondaryEngineAttributeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionSecondaryEngineAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionSecondaryEngineAttributeContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *TableOptionSecondaryEngineAttributeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *TableOptionSecondaryEngineAttributeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionSecondaryEngineAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionSecondaryEngineAttribute(s)
	}
}

func (s *TableOptionSecondaryEngineAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionSecondaryEngineAttribute(s)
	}
}

type TableOptionCommentContext struct {
	TableOptionContext
}

func NewTableOptionCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCommentContext {
	var p = new(TableOptionCommentContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMENT, 0)
}

func (s *TableOptionCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *TableOptionCommentContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionComment(s)
	}
}

func (s *TableOptionCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionComment(s)
	}
}

type TableOptionAverageContext struct {
	TableOptionContext
}

func NewTableOptionAverageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionAverageContext {
	var p = new(TableOptionAverageContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionAverageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionAverageContext) AVG_ROW_LENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserAVG_ROW_LENGTH, 0)
}

func (s *TableOptionAverageContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionAverageContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionAverageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionAverage(s)
	}
}

func (s *TableOptionAverageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionAverage(s)
	}
}

type TableOptionRowFormatContext struct {
	TableOptionContext
	rowFormat antlr.Token
}

func NewTableOptionRowFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionRowFormatContext {
	var p = new(TableOptionRowFormatContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionRowFormatContext) GetRowFormat() antlr.Token { return s.rowFormat }

func (s *TableOptionRowFormatContext) SetRowFormat(v antlr.Token) { s.rowFormat = v }

func (s *TableOptionRowFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionRowFormatContext) ROW_FORMAT() antlr.TerminalNode {
	return s.GetToken(StmtParserROW_FORMAT, 0)
}

func (s *TableOptionRowFormatContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *TableOptionRowFormatContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(StmtParserDYNAMIC, 0)
}

func (s *TableOptionRowFormatContext) FIXED() antlr.TerminalNode {
	return s.GetToken(StmtParserFIXED, 0)
}

func (s *TableOptionRowFormatContext) COMPRESSED() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMPRESSED, 0)
}

func (s *TableOptionRowFormatContext) REDUNDANT() antlr.TerminalNode {
	return s.GetToken(StmtParserREDUNDANT, 0)
}

func (s *TableOptionRowFormatContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMPACT, 0)
}

func (s *TableOptionRowFormatContext) ID() antlr.TerminalNode {
	return s.GetToken(StmtParserID, 0)
}

func (s *TableOptionRowFormatContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionRowFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionRowFormat(s)
	}
}

func (s *TableOptionRowFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionRowFormat(s)
	}
}

type TableOptionCompressionContext struct {
	TableOptionContext
}

func NewTableOptionCompressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCompressionContext {
	var p = new(TableOptionCompressionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCompressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCompressionContext) COMPRESSION() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMPRESSION, 0)
}

func (s *TableOptionCompressionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *TableOptionCompressionContext) ID() antlr.TerminalNode {
	return s.GetToken(StmtParserID, 0)
}

func (s *TableOptionCompressionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCompressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionCompression(s)
	}
}

func (s *TableOptionCompressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionCompression(s)
	}
}

type TableOptionInsertMethodContext struct {
	TableOptionContext
	insertMethod antlr.Token
}

func NewTableOptionInsertMethodContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionInsertMethodContext {
	var p = new(TableOptionInsertMethodContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionInsertMethodContext) GetInsertMethod() antlr.Token { return s.insertMethod }

func (s *TableOptionInsertMethodContext) SetInsertMethod(v antlr.Token) { s.insertMethod = v }

func (s *TableOptionInsertMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionInsertMethodContext) INSERT_METHOD() antlr.TerminalNode {
	return s.GetToken(StmtParserINSERT_METHOD, 0)
}

func (s *TableOptionInsertMethodContext) NO() antlr.TerminalNode {
	return s.GetToken(StmtParserNO, 0)
}

func (s *TableOptionInsertMethodContext) FIRST() antlr.TerminalNode {
	return s.GetToken(StmtParserFIRST, 0)
}

func (s *TableOptionInsertMethodContext) LAST() antlr.TerminalNode {
	return s.GetToken(StmtParserLAST, 0)
}

func (s *TableOptionInsertMethodContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionInsertMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionInsertMethod(s)
	}
}

func (s *TableOptionInsertMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionInsertMethod(s)
	}
}

type TableOptionEngineAttributeContext struct {
	TableOptionContext
}

func NewTableOptionEngineAttributeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEngineAttributeContext {
	var p = new(TableOptionEngineAttributeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEngineAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEngineAttributeContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserENGINE_ATTRIBUTE, 0)
}

func (s *TableOptionEngineAttributeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *TableOptionEngineAttributeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEngineAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionEngineAttribute(s)
	}
}

func (s *TableOptionEngineAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionEngineAttribute(s)
	}
}

type TableOptionMinRowsContext struct {
	TableOptionContext
}

func NewTableOptionMinRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionMinRowsContext {
	var p = new(TableOptionMinRowsContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionMinRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionMinRowsContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(StmtParserMIN_ROWS, 0)
}

func (s *TableOptionMinRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionMinRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionMinRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionMinRows(s)
	}
}

func (s *TableOptionMinRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionMinRows(s)
	}
}

func (p *StmtParser) TableOption() (localctx ITableOptionContext) {
	localctx = NewTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, StmtParserRULE_tableOption)
	var _la int

	p.SetState(619)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableOptionEngineContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(457)
			p.Match(StmtParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(459)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(458)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(462)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCONNECT || ((int64((_la-767)) & ^0x3f) == 0 && ((int64(1)<<(_la-767))&4095) != 0) || ((int64((_la-1138)) & ^0x3f) == 0 && ((int64(1)<<(_la-1138))&769) != 0) {
			{
				p.SetState(461)
				p.EngineName()
			}

		}

	case 2:
		localctx = NewTableOptionEngineAttributeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(464)
			p.Match(StmtParserENGINE_ATTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(466)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(465)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(468)
			p.Match(StmtParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewTableOptionAutoextendSizeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(469)
			p.Match(StmtParserAUTOEXTEND_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(471)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(470)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(473)
			p.DecimalLiteral()
		}

	case 4:
		localctx = NewTableOptionAutoIncrementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(474)
			p.Match(StmtParserAUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(476)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(475)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(478)
			p.DecimalLiteral()
		}

	case 5:
		localctx = NewTableOptionAverageContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(479)
			p.Match(StmtParserAVG_ROW_LENGTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(481)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(480)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(483)
			p.DecimalLiteral()
		}

	case 6:
		localctx = NewTableOptionCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(485)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserDEFAULT {
			{
				p.SetState(484)
				p.Match(StmtParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(487)
			p.CharSet()
		}
		p.SetState(489)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(488)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(493)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StmtParserBINARY, StmtParserARMSCII8, StmtParserASCII, StmtParserBIG5, StmtParserCP1250, StmtParserCP1251, StmtParserCP1256, StmtParserCP1257, StmtParserCP850, StmtParserCP852, StmtParserCP866, StmtParserCP932, StmtParserDEC8, StmtParserEUCJPMS, StmtParserEUCKR, StmtParserGB18030, StmtParserGB2312, StmtParserGBK, StmtParserGEOSTD8, StmtParserGREEK, StmtParserHEBREW, StmtParserHP8, StmtParserKEYBCS2, StmtParserKOI8R, StmtParserKOI8U, StmtParserLATIN1, StmtParserLATIN2, StmtParserLATIN5, StmtParserLATIN7, StmtParserMACCE, StmtParserMACROMAN, StmtParserSJIS, StmtParserSWE7, StmtParserTIS620, StmtParserUCS2, StmtParserUJIS, StmtParserUTF16, StmtParserUTF16LE, StmtParserUTF32, StmtParserUTF8, StmtParserUTF8MB3, StmtParserUTF8MB4, StmtParserCHARSET_REVERSE_QOUTE_STRING, StmtParserSTRING_LITERAL:
			{
				p.SetState(491)
				p.CharsetName()
			}

		case StmtParserDEFAULT:
			{
				p.SetState(492)
				p.Match(StmtParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 7:
		localctx = NewTableOptionChecksumContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(495)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserCHECKSUM || _la == StmtParserPAGE_CHECKSUM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(497)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(496)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(499)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionChecksumContext).boolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserZERO_DECIMAL || _la == StmtParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionChecksumContext).boolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 8:
		localctx = NewTableOptionCollateContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		p.SetState(501)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserDEFAULT {
			{
				p.SetState(500)
				p.Match(StmtParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(503)
			p.Match(StmtParserCOLLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(505)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(504)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(507)
			p.CollationName()
		}

	case 9:
		localctx = NewTableOptionCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(508)
			p.Match(StmtParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(509)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(512)
			p.Match(StmtParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewTableOptionCompressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(513)
			p.Match(StmtParserCOMPRESSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(515)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(514)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(517)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserSTRING_LITERAL || _la == StmtParserID) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 11:
		localctx = NewTableOptionConnectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(518)
			p.Match(StmtParserCONNECTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(520)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(519)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(522)
			p.Match(StmtParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewTableOptionDataDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(523)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserINDEX || _la == StmtParserDATA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(524)
			p.Match(StmtParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(526)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(525)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(528)
			p.Match(StmtParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewTableOptionDelayContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(529)
			p.Match(StmtParserDELAY_KEY_WRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(531)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(530)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(533)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionDelayContext).boolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserZERO_DECIMAL || _la == StmtParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionDelayContext).boolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 14:
		localctx = NewTableOptionEncryptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(534)
			p.Match(StmtParserENCRYPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(536)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(535)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(538)
			p.Match(StmtParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		localctx = NewTableOptionIndexDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(539)
			p.Match(StmtParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(540)
			p.Match(StmtParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(542)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(541)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(544)
			p.Match(StmtParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		localctx = NewTableOptionInsertMethodContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(545)
			p.Match(StmtParserINSERT_METHOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(547)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(546)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(549)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionInsertMethodContext).insertMethod = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserFIRST || _la == StmtParserLAST || _la == StmtParserNO) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionInsertMethodContext).insertMethod = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 17:
		localctx = NewTableOptionKeyBlockSizeContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(550)
			p.Match(StmtParserKEY_BLOCK_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(552)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(551)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(554)
			p.FileSizeLiteral()
		}

	case 18:
		localctx = NewTableOptionMaxRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(555)
			p.Match(StmtParserMAX_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(557)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(556)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(559)
			p.DecimalLiteral()
		}

	case 19:
		localctx = NewTableOptionMinRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(560)
			p.Match(StmtParserMIN_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(562)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(561)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(564)
			p.DecimalLiteral()
		}

	case 20:
		localctx = NewTableOptionPackKeysContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(565)
			p.Match(StmtParserPACK_KEYS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(567)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(566)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(569)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionPackKeysContext).extBoolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserDEFAULT || _la == StmtParserZERO_DECIMAL || _la == StmtParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionPackKeysContext).extBoolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 21:
		localctx = NewTableOptionPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(570)
			p.Match(StmtParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(572)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(571)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(574)
			p.Match(StmtParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		localctx = NewTableOptionRowFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(575)
			p.Match(StmtParserROW_FORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(577)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(576)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(579)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionRowFormatContext).rowFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserDEFAULT || ((int64((_la-361)) & ^0x3f) == 0 && ((int64(1)<<(_la-361))&288230380446679045) != 0) || _la == StmtParserREDUNDANT || _la == StmtParserID) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionRowFormatContext).rowFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 23:
		localctx = NewTableOptionStartTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(580)
			p.Match(StmtParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(581)
			p.Match(StmtParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		localctx = NewTableOptionSecondaryEngineAttributeContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(582)
			p.Match(StmtParserSECONDARY_ENGINE_ATTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(584)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(583)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(586)
			p.Match(StmtParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		localctx = NewTableOptionRecalculationContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(587)
			p.Match(StmtParserSTATS_AUTO_RECALC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(589)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(588)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(591)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionRecalculationContext).extBoolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserDEFAULT || _la == StmtParserZERO_DECIMAL || _la == StmtParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionRecalculationContext).extBoolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 26:
		localctx = NewTableOptionPersistentContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(592)
			p.Match(StmtParserSTATS_PERSISTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(594)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(593)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(596)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionPersistentContext).extBoolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserDEFAULT || _la == StmtParserZERO_DECIMAL || _la == StmtParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionPersistentContext).extBoolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 27:
		localctx = NewTableOptionSamplePageContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(597)
			p.Match(StmtParserSTATS_SAMPLE_PAGES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(598)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(601)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionSamplePageContext).extValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserDEFAULT || _la == StmtParserDECIMAL_LITERAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionSamplePageContext).extValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 28:
		localctx = NewTableOptionTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(602)
			p.Match(StmtParserTABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(603)
			p.Uid()
		}
		p.SetState(605)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(604)
				p.TablespaceStorage()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 29:
		localctx = NewTableOptionTableTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(607)
			p.Match(StmtParserTABLE_TYPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(608)
			p.Match(StmtParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(609)
			p.TableType()
		}

	case 30:
		localctx = NewTableOptionTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(610)
			p.TablespaceStorage()
		}

	case 31:
		localctx = NewTableOptionUnionContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(611)
			p.Match(StmtParserUNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(613)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(612)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(615)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(616)
			p.Tables()
		}
		{
			p.SetState(617)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableTypeContext is an interface to support dynamic dispatch.
type ITableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MYSQL() antlr.TerminalNode
	ODBC() antlr.TerminalNode

	// IsTableTypeContext differentiates from other interfaces.
	IsTableTypeContext()
}

type TableTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableTypeContext() *TableTypeContext {
	var p = new(TableTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_tableType
	return p
}

func InitEmptyTableTypeContext(p *TableTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_tableType
}

func (*TableTypeContext) IsTableTypeContext() {}

func NewTableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableTypeContext {
	var p = new(TableTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_tableType

	return p
}

func (s *TableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TableTypeContext) MYSQL() antlr.TerminalNode {
	return s.GetToken(StmtParserMYSQL, 0)
}

func (s *TableTypeContext) ODBC() antlr.TerminalNode {
	return s.GetToken(StmtParserODBC, 0)
}

func (s *TableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableType(s)
	}
}

func (s *TableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableType(s)
	}
}

func (p *StmtParser) TableType() (localctx ITableTypeContext) {
	localctx = NewTableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, StmtParserRULE_tableType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(621)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserMYSQL || _la == StmtParserODBC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablespaceStorageContext is an interface to support dynamic dispatch.
type ITablespaceStorageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STORAGE() antlr.TerminalNode
	DISK() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsTablespaceStorageContext differentiates from other interfaces.
	IsTablespaceStorageContext()
}

type TablespaceStorageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablespaceStorageContext() *TablespaceStorageContext {
	var p = new(TablespaceStorageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_tablespaceStorage
	return p
}

func InitEmptyTablespaceStorageContext(p *TablespaceStorageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_tablespaceStorage
}

func (*TablespaceStorageContext) IsTablespaceStorageContext() {}

func NewTablespaceStorageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablespaceStorageContext {
	var p = new(TablespaceStorageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_tablespaceStorage

	return p
}

func (s *TablespaceStorageContext) GetParser() antlr.Parser { return s.parser }

func (s *TablespaceStorageContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StmtParserSTORAGE, 0)
}

func (s *TablespaceStorageContext) DISK() antlr.TerminalNode {
	return s.GetToken(StmtParserDISK, 0)
}

func (s *TablespaceStorageContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(StmtParserMEMORY, 0)
}

func (s *TablespaceStorageContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *TablespaceStorageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablespaceStorageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablespaceStorageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTablespaceStorage(s)
	}
}

func (s *TablespaceStorageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTablespaceStorage(s)
	}
}

func (p *StmtParser) TablespaceStorage() (localctx ITablespaceStorageContext) {
	localctx = NewTablespaceStorageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, StmtParserRULE_tablespaceStorage)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(623)
		p.Match(StmtParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(624)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserDEFAULT || _la == StmtParserDISK || _la == StmtParserMEMORY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefinitionsContext is an interface to support dynamic dispatch.
type IPartitionDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCount returns the count rule contexts.
	GetCount() IDecimalLiteralContext

	// GetSubCount returns the subCount rule contexts.
	GetSubCount() IDecimalLiteralContext

	// SetCount sets the count rule contexts.
	SetCount(IDecimalLiteralContext)

	// SetSubCount sets the subCount rule contexts.
	SetSubCount(IDecimalLiteralContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	PartitionFunctionDefinition() IPartitionFunctionDefinitionContext
	PARTITIONS() antlr.TerminalNode
	SUBPARTITION() antlr.TerminalNode
	SubpartitionFunctionDefinition() ISubpartitionFunctionDefinitionContext
	LR_BRACKET() antlr.TerminalNode
	AllPartitionDefinition() []IPartitionDefinitionContext
	PartitionDefinition(i int) IPartitionDefinitionContext
	RR_BRACKET() antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	SUBPARTITIONS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionDefinitionsContext differentiates from other interfaces.
	IsPartitionDefinitionsContext()
}

type PartitionDefinitionsContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	count    IDecimalLiteralContext
	subCount IDecimalLiteralContext
}

func NewEmptyPartitionDefinitionsContext() *PartitionDefinitionsContext {
	var p = new(PartitionDefinitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_partitionDefinitions
	return p
}

func InitEmptyPartitionDefinitionsContext(p *PartitionDefinitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_partitionDefinitions
}

func (*PartitionDefinitionsContext) IsPartitionDefinitionsContext() {}

func NewPartitionDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinitionsContext {
	var p = new(PartitionDefinitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_partitionDefinitions

	return p
}

func (s *PartitionDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinitionsContext) GetCount() IDecimalLiteralContext { return s.count }

func (s *PartitionDefinitionsContext) GetSubCount() IDecimalLiteralContext { return s.subCount }

func (s *PartitionDefinitionsContext) SetCount(v IDecimalLiteralContext) { s.count = v }

func (s *PartitionDefinitionsContext) SetSubCount(v IDecimalLiteralContext) { s.subCount = v }

func (s *PartitionDefinitionsContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTITION, 0)
}

func (s *PartitionDefinitionsContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(StmtParserBY)
}

func (s *PartitionDefinitionsContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserBY, i)
}

func (s *PartitionDefinitionsContext) PartitionFunctionDefinition() IPartitionFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionFunctionDefinitionContext)
}

func (s *PartitionDefinitionsContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTITIONS, 0)
}

func (s *PartitionDefinitionsContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBPARTITION, 0)
}

func (s *PartitionDefinitionsContext) SubpartitionFunctionDefinition() ISubpartitionFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionFunctionDefinitionContext)
}

func (s *PartitionDefinitionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *PartitionDefinitionsContext) AllPartitionDefinition() []IPartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinitionContext); ok {
			tst[i] = t.(IPartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinitionsContext) PartitionDefinition(i int) IPartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionContext)
}

func (s *PartitionDefinitionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *PartitionDefinitionsContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinitionsContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PartitionDefinitionsContext) SUBPARTITIONS() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBPARTITIONS, 0)
}

func (s *PartitionDefinitionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *PartitionDefinitionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *PartitionDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionDefinitions(s)
	}
}

func (s *PartitionDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionDefinitions(s)
	}
}

func (p *StmtParser) PartitionDefinitions() (localctx IPartitionDefinitionsContext) {
	localctx = NewPartitionDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, StmtParserRULE_partitionDefinitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(626)
		p.Match(StmtParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(627)
		p.Match(StmtParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(628)
		p.PartitionFunctionDefinition()
	}
	p.SetState(631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserPARTITIONS {
		{
			p.SetState(629)
			p.Match(StmtParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(630)

			var _x = p.DecimalLiteral()

			localctx.(*PartitionDefinitionsContext).count = _x
		}

	}
	p.SetState(640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserSUBPARTITION {
		{
			p.SetState(633)
			p.Match(StmtParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(634)
			p.Match(StmtParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(635)
			p.SubpartitionFunctionDefinition()
		}
		p.SetState(638)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserSUBPARTITIONS {
			{
				p.SetState(636)
				p.Match(StmtParserSUBPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(637)

				var _x = p.DecimalLiteral()

				localctx.(*PartitionDefinitionsContext).subCount = _x
			}

		}

	}
	p.SetState(653)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserLR_BRACKET {
		{
			p.SetState(642)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(643)
			p.PartitionDefinition()
		}
		p.SetState(648)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserCOMMA {
			{
				p.SetState(644)
				p.Match(StmtParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(645)
				p.PartitionDefinition()
			}

			p.SetState(650)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(651)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionFunctionDefinitionContext is an interface to support dynamic dispatch.
type IPartitionFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionFunctionDefinitionContext differentiates from other interfaces.
	IsPartitionFunctionDefinitionContext()
}

type PartitionFunctionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionFunctionDefinitionContext() *PartitionFunctionDefinitionContext {
	var p = new(PartitionFunctionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_partitionFunctionDefinition
	return p
}

func InitEmptyPartitionFunctionDefinitionContext(p *PartitionFunctionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_partitionFunctionDefinition
}

func (*PartitionFunctionDefinitionContext) IsPartitionFunctionDefinitionContext() {}

func NewPartitionFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionFunctionDefinitionContext {
	var p = new(PartitionFunctionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_partitionFunctionDefinition

	return p
}

func (s *PartitionFunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionFunctionDefinitionContext) CopyAll(ctx *PartitionFunctionDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PartitionFunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PartitionFunctionKeyContext struct {
	PartitionFunctionDefinitionContext
	algType antlr.Token
}

func NewPartitionFunctionKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionKeyContext {
	var p = new(PartitionFunctionKeyContext)

	InitEmptyPartitionFunctionDefinitionContext(&p.PartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionKeyContext) GetAlgType() antlr.Token { return s.algType }

func (s *PartitionFunctionKeyContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *PartitionFunctionKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY, 0)
}

func (s *PartitionFunctionKeyContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *PartitionFunctionKeyContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PartitionFunctionKeyContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *PartitionFunctionKeyContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserLINEAR, 0)
}

func (s *PartitionFunctionKeyContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(StmtParserALGORITHM, 0)
}

func (s *PartitionFunctionKeyContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *PartitionFunctionKeyContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserONE_DECIMAL, 0)
}

func (s *PartitionFunctionKeyContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserTWO_DECIMAL, 0)
}

func (s *PartitionFunctionKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionFunctionKey(s)
	}
}

func (s *PartitionFunctionKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionFunctionKey(s)
	}
}

type PartitionFunctionHashContext struct {
	PartitionFunctionDefinitionContext
}

func NewPartitionFunctionHashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionHashContext {
	var p = new(PartitionFunctionHashContext)

	InitEmptyPartitionFunctionDefinitionContext(&p.PartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionHashContext) HASH() antlr.TerminalNode {
	return s.GetToken(StmtParserHASH, 0)
}

func (s *PartitionFunctionHashContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *PartitionFunctionHashContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionFunctionHashContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *PartitionFunctionHashContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserLINEAR, 0)
}

func (s *PartitionFunctionHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionFunctionHash(s)
	}
}

func (s *PartitionFunctionHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionFunctionHash(s)
	}
}

type PartitionFunctionListContext struct {
	PartitionFunctionDefinitionContext
}

func NewPartitionFunctionListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionListContext {
	var p = new(PartitionFunctionListContext)

	InitEmptyPartitionFunctionDefinitionContext(&p.PartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionListContext) LIST() antlr.TerminalNode {
	return s.GetToken(StmtParserLIST, 0)
}

func (s *PartitionFunctionListContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *PartitionFunctionListContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionFunctionListContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *PartitionFunctionListContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLUMNS, 0)
}

func (s *PartitionFunctionListContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PartitionFunctionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionFunctionList(s)
	}
}

func (s *PartitionFunctionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionFunctionList(s)
	}
}

type PartitionFunctionRangeContext struct {
	PartitionFunctionDefinitionContext
}

func NewPartitionFunctionRangeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionRangeContext {
	var p = new(PartitionFunctionRangeContext)

	InitEmptyPartitionFunctionDefinitionContext(&p.PartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionRangeContext) RANGE() antlr.TerminalNode {
	return s.GetToken(StmtParserRANGE, 0)
}

func (s *PartitionFunctionRangeContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *PartitionFunctionRangeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionFunctionRangeContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *PartitionFunctionRangeContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLUMNS, 0)
}

func (s *PartitionFunctionRangeContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PartitionFunctionRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionFunctionRange(s)
	}
}

func (s *PartitionFunctionRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionFunctionRange(s)
	}
}

func (p *StmtParser) PartitionFunctionDefinition() (localctx IPartitionFunctionDefinitionContext) {
	localctx = NewPartitionFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, StmtParserRULE_partitionFunctionDefinition)
	var _la int

	p.SetState(700)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPartitionFunctionHashContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(656)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLINEAR {
			{
				p.SetState(655)
				p.Match(StmtParserLINEAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(658)
			p.Match(StmtParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(659)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(660)
			p.expression(0)
		}
		{
			p.SetState(661)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewPartitionFunctionKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(664)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLINEAR {
			{
				p.SetState(663)
				p.Match(StmtParserLINEAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(666)
			p.Match(StmtParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(670)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserALGORITHM {
			{
				p.SetState(667)
				p.Match(StmtParserALGORITHM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(668)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(669)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*PartitionFunctionKeyContext).algType = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == StmtParserONE_DECIMAL || _la == StmtParserTWO_DECIMAL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*PartitionFunctionKeyContext).algType = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(672)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(673)
			p.UidList()
		}
		{
			p.SetState(674)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewPartitionFunctionRangeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(676)
			p.Match(StmtParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(686)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StmtParserLR_BRACKET:
			{
				p.SetState(677)
				p.Match(StmtParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(678)
				p.expression(0)
			}
			{
				p.SetState(679)
				p.Match(StmtParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case StmtParserCOLUMNS:
			{
				p.SetState(681)
				p.Match(StmtParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(682)
				p.Match(StmtParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(683)
				p.UidList()
			}
			{
				p.SetState(684)
				p.Match(StmtParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		localctx = NewPartitionFunctionListContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(688)
			p.Match(StmtParserLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(698)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StmtParserLR_BRACKET:
			{
				p.SetState(689)
				p.Match(StmtParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(690)
				p.expression(0)
			}
			{
				p.SetState(691)
				p.Match(StmtParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case StmtParserCOLUMNS:
			{
				p.SetState(693)
				p.Match(StmtParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(694)
				p.Match(StmtParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(695)
				p.UidList()
			}
			{
				p.SetState(696)
				p.Match(StmtParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubpartitionFunctionDefinitionContext is an interface to support dynamic dispatch.
type ISubpartitionFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSubpartitionFunctionDefinitionContext differentiates from other interfaces.
	IsSubpartitionFunctionDefinitionContext()
}

type SubpartitionFunctionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubpartitionFunctionDefinitionContext() *SubpartitionFunctionDefinitionContext {
	var p = new(SubpartitionFunctionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_subpartitionFunctionDefinition
	return p
}

func InitEmptySubpartitionFunctionDefinitionContext(p *SubpartitionFunctionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_subpartitionFunctionDefinition
}

func (*SubpartitionFunctionDefinitionContext) IsSubpartitionFunctionDefinitionContext() {}

func NewSubpartitionFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubpartitionFunctionDefinitionContext {
	var p = new(SubpartitionFunctionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_subpartitionFunctionDefinition

	return p
}

func (s *SubpartitionFunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubpartitionFunctionDefinitionContext) CopyAll(ctx *SubpartitionFunctionDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SubpartitionFunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubpartitionFunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubPartitionFunctionHashContext struct {
	SubpartitionFunctionDefinitionContext
}

func NewSubPartitionFunctionHashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubPartitionFunctionHashContext {
	var p = new(SubPartitionFunctionHashContext)

	InitEmptySubpartitionFunctionDefinitionContext(&p.SubpartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SubpartitionFunctionDefinitionContext))

	return p
}

func (s *SubPartitionFunctionHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubPartitionFunctionHashContext) HASH() antlr.TerminalNode {
	return s.GetToken(StmtParserHASH, 0)
}

func (s *SubPartitionFunctionHashContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *SubPartitionFunctionHashContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SubPartitionFunctionHashContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *SubPartitionFunctionHashContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserLINEAR, 0)
}

func (s *SubPartitionFunctionHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSubPartitionFunctionHash(s)
	}
}

func (s *SubPartitionFunctionHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSubPartitionFunctionHash(s)
	}
}

type SubPartitionFunctionKeyContext struct {
	SubpartitionFunctionDefinitionContext
	algType antlr.Token
}

func NewSubPartitionFunctionKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubPartitionFunctionKeyContext {
	var p = new(SubPartitionFunctionKeyContext)

	InitEmptySubpartitionFunctionDefinitionContext(&p.SubpartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SubpartitionFunctionDefinitionContext))

	return p
}

func (s *SubPartitionFunctionKeyContext) GetAlgType() antlr.Token { return s.algType }

func (s *SubPartitionFunctionKeyContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *SubPartitionFunctionKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubPartitionFunctionKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY, 0)
}

func (s *SubPartitionFunctionKeyContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *SubPartitionFunctionKeyContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *SubPartitionFunctionKeyContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *SubPartitionFunctionKeyContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserLINEAR, 0)
}

func (s *SubPartitionFunctionKeyContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(StmtParserALGORITHM, 0)
}

func (s *SubPartitionFunctionKeyContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *SubPartitionFunctionKeyContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserONE_DECIMAL, 0)
}

func (s *SubPartitionFunctionKeyContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserTWO_DECIMAL, 0)
}

func (s *SubPartitionFunctionKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSubPartitionFunctionKey(s)
	}
}

func (s *SubPartitionFunctionKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSubPartitionFunctionKey(s)
	}
}

func (p *StmtParser) SubpartitionFunctionDefinition() (localctx ISubpartitionFunctionDefinitionContext) {
	localctx = NewSubpartitionFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, StmtParserRULE_subpartitionFunctionDefinition)
	var _la int

	p.SetState(723)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSubPartitionFunctionHashContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(703)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLINEAR {
			{
				p.SetState(702)
				p.Match(StmtParserLINEAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(705)
			p.Match(StmtParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(706)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(707)
			p.expression(0)
		}
		{
			p.SetState(708)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewSubPartitionFunctionKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(711)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLINEAR {
			{
				p.SetState(710)
				p.Match(StmtParserLINEAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(713)
			p.Match(StmtParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(717)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserALGORITHM {
			{
				p.SetState(714)
				p.Match(StmtParserALGORITHM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(715)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(716)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SubPartitionFunctionKeyContext).algType = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == StmtParserONE_DECIMAL || _la == StmtParserTWO_DECIMAL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SubPartitionFunctionKeyContext).algType = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(719)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(720)
			p.UidList()
		}
		{
			p.SetState(721)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefinitionContext is an interface to support dynamic dispatch.
type IPartitionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionDefinitionContext differentiates from other interfaces.
	IsPartitionDefinitionContext()
}

type PartitionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinitionContext() *PartitionDefinitionContext {
	var p = new(PartitionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_partitionDefinition
	return p
}

func InitEmptyPartitionDefinitionContext(p *PartitionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_partitionDefinition
}

func (*PartitionDefinitionContext) IsPartitionDefinitionContext() {}

func NewPartitionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinitionContext {
	var p = new(PartitionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_partitionDefinition

	return p
}

func (s *PartitionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinitionContext) CopyAll(ctx *PartitionDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PartitionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PartitionComparisonContext struct {
	PartitionDefinitionContext
}

func NewPartitionComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionComparisonContext {
	var p = new(PartitionComparisonContext)

	InitEmptyPartitionDefinitionContext(&p.PartitionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionComparisonContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTITION, 0)
}

func (s *PartitionComparisonContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionComparisonContext) VALUES() antlr.TerminalNode {
	return s.GetToken(StmtParserVALUES, 0)
}

func (s *PartitionComparisonContext) LESS() antlr.TerminalNode {
	return s.GetToken(StmtParserLESS, 0)
}

func (s *PartitionComparisonContext) THAN() antlr.TerminalNode {
	return s.GetToken(StmtParserTHAN, 0)
}

func (s *PartitionComparisonContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(StmtParserLR_BRACKET)
}

func (s *PartitionComparisonContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, i)
}

func (s *PartitionComparisonContext) AllPartitionDefinerAtom() []IPartitionDefinerAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerAtomContext); ok {
			tst[i] = t.(IPartitionDefinerAtomContext)
			i++
		}
	}

	return tst
}

func (s *PartitionComparisonContext) PartitionDefinerAtom(i int) IPartitionDefinerAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerAtomContext)
}

func (s *PartitionComparisonContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(StmtParserRR_BRACKET)
}

func (s *PartitionComparisonContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, i)
}

func (s *PartitionComparisonContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *PartitionComparisonContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *PartitionComparisonContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionComparisonContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionComparisonContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionComparisonContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionComparison(s)
	}
}

func (s *PartitionComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionComparison(s)
	}
}

type PartitionListAtomContext struct {
	PartitionDefinitionContext
}

func NewPartitionListAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionListAtomContext {
	var p = new(PartitionListAtomContext)

	InitEmptyPartitionDefinitionContext(&p.PartitionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionListAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionListAtomContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTITION, 0)
}

func (s *PartitionListAtomContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionListAtomContext) VALUES() antlr.TerminalNode {
	return s.GetToken(StmtParserVALUES, 0)
}

func (s *PartitionListAtomContext) IN() antlr.TerminalNode {
	return s.GetToken(StmtParserIN, 0)
}

func (s *PartitionListAtomContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(StmtParserLR_BRACKET)
}

func (s *PartitionListAtomContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, i)
}

func (s *PartitionListAtomContext) AllPartitionDefinerAtom() []IPartitionDefinerAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerAtomContext); ok {
			tst[i] = t.(IPartitionDefinerAtomContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListAtomContext) PartitionDefinerAtom(i int) IPartitionDefinerAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerAtomContext)
}

func (s *PartitionListAtomContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(StmtParserRR_BRACKET)
}

func (s *PartitionListAtomContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, i)
}

func (s *PartitionListAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *PartitionListAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *PartitionListAtomContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListAtomContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionListAtomContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListAtomContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionListAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionListAtom(s)
	}
}

func (s *PartitionListAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionListAtom(s)
	}
}

type PartitionListVectorContext struct {
	PartitionDefinitionContext
}

func NewPartitionListVectorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionListVectorContext {
	var p = new(PartitionListVectorContext)

	InitEmptyPartitionDefinitionContext(&p.PartitionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionListVectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionListVectorContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTITION, 0)
}

func (s *PartitionListVectorContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionListVectorContext) VALUES() antlr.TerminalNode {
	return s.GetToken(StmtParserVALUES, 0)
}

func (s *PartitionListVectorContext) IN() antlr.TerminalNode {
	return s.GetToken(StmtParserIN, 0)
}

func (s *PartitionListVectorContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(StmtParserLR_BRACKET)
}

func (s *PartitionListVectorContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, i)
}

func (s *PartitionListVectorContext) AllPartitionDefinerVector() []IPartitionDefinerVectorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerVectorContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerVectorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerVectorContext); ok {
			tst[i] = t.(IPartitionDefinerVectorContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListVectorContext) PartitionDefinerVector(i int) IPartitionDefinerVectorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerVectorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerVectorContext)
}

func (s *PartitionListVectorContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(StmtParserRR_BRACKET)
}

func (s *PartitionListVectorContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, i)
}

func (s *PartitionListVectorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *PartitionListVectorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *PartitionListVectorContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListVectorContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionListVectorContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListVectorContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionListVectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionListVector(s)
	}
}

func (s *PartitionListVectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionListVector(s)
	}
}

type PartitionSimpleContext struct {
	PartitionDefinitionContext
}

func NewPartitionSimpleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionSimpleContext {
	var p = new(PartitionSimpleContext)

	InitEmptyPartitionDefinitionContext(&p.PartitionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionSimpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSimpleContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTITION, 0)
}

func (s *PartitionSimpleContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionSimpleContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionSimpleContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionSimpleContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *PartitionSimpleContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionSimpleContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionSimpleContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *PartitionSimpleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *PartitionSimpleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *PartitionSimpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionSimple(s)
	}
}

func (s *PartitionSimpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionSimple(s)
	}
}

func (p *StmtParser) PartitionDefinition() (localctx IPartitionDefinitionContext) {
	localctx = NewPartitionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, StmtParserRULE_partitionDefinition)
	var _la int

	p.SetState(871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPartitionComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(725)
			p.Match(StmtParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(726)
			p.Uid()
		}
		{
			p.SetState(727)
			p.Match(StmtParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(728)
			p.Match(StmtParserLESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(729)
			p.Match(StmtParserTHAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(730)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(731)
			p.PartitionDefinerAtom()
		}
		p.SetState(736)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserCOMMA {
			{
				p.SetState(732)
				p.Match(StmtParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(733)
				p.PartitionDefinerAtom()
			}

			p.SetState(738)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(739)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(743)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserDEFAULT || _la == StmtParserINDEX || ((int64((_la-359)) & ^0x3f) == 0 && ((int64(1)<<(_la-359))&549756862465) != 0) || ((int64((_la-487)) & ^0x3f) == 0 && ((int64(1)<<(_la-487))&268436481) != 0) || _la == StmtParserSTORAGE || _la == StmtParserTABLESPACE {
			{
				p.SetState(740)
				p.PartitionOption()
			}

			p.SetState(745)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(757)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(746)
				p.Match(StmtParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(747)
				p.SubpartitionDefinition()
			}
			p.SetState(752)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StmtParserCOMMA {
				{
					p.SetState(748)
					p.Match(StmtParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(749)
					p.SubpartitionDefinition()
				}

				p.SetState(754)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(755)
				p.Match(StmtParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		localctx = NewPartitionComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(759)
			p.Match(StmtParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(760)
			p.Uid()
		}
		{
			p.SetState(761)
			p.Match(StmtParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(762)
			p.Match(StmtParserLESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(763)
			p.Match(StmtParserTHAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(764)
			p.PartitionDefinerAtom()
		}
		p.SetState(768)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserDEFAULT || _la == StmtParserINDEX || ((int64((_la-359)) & ^0x3f) == 0 && ((int64(1)<<(_la-359))&549756862465) != 0) || ((int64((_la-487)) & ^0x3f) == 0 && ((int64(1)<<(_la-487))&268436481) != 0) || _la == StmtParserSTORAGE || _la == StmtParserTABLESPACE {
			{
				p.SetState(765)
				p.PartitionOption()
			}

			p.SetState(770)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(782)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(771)
				p.Match(StmtParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(772)
				p.SubpartitionDefinition()
			}
			p.SetState(777)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StmtParserCOMMA {
				{
					p.SetState(773)
					p.Match(StmtParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(774)
					p.SubpartitionDefinition()
				}

				p.SetState(779)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(780)
				p.Match(StmtParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		localctx = NewPartitionListAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(784)
			p.Match(StmtParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(785)
			p.Uid()
		}
		{
			p.SetState(786)
			p.Match(StmtParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(787)
			p.Match(StmtParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(788)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(789)
			p.PartitionDefinerAtom()
		}
		p.SetState(794)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserCOMMA {
			{
				p.SetState(790)
				p.Match(StmtParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(791)
				p.PartitionDefinerAtom()
			}

			p.SetState(796)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(797)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(801)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserDEFAULT || _la == StmtParserINDEX || ((int64((_la-359)) & ^0x3f) == 0 && ((int64(1)<<(_la-359))&549756862465) != 0) || ((int64((_la-487)) & ^0x3f) == 0 && ((int64(1)<<(_la-487))&268436481) != 0) || _la == StmtParserSTORAGE || _la == StmtParserTABLESPACE {
			{
				p.SetState(798)
				p.PartitionOption()
			}

			p.SetState(803)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(815)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(804)
				p.Match(StmtParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(805)
				p.SubpartitionDefinition()
			}
			p.SetState(810)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StmtParserCOMMA {
				{
					p.SetState(806)
					p.Match(StmtParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(807)
					p.SubpartitionDefinition()
				}

				p.SetState(812)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(813)
				p.Match(StmtParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		localctx = NewPartitionListVectorContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(817)
			p.Match(StmtParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(818)
			p.Uid()
		}
		{
			p.SetState(819)
			p.Match(StmtParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(820)
			p.Match(StmtParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(821)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(822)
			p.PartitionDefinerVector()
		}
		p.SetState(827)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserCOMMA {
			{
				p.SetState(823)
				p.Match(StmtParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(824)
				p.PartitionDefinerVector()
			}

			p.SetState(829)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(830)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(834)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserDEFAULT || _la == StmtParserINDEX || ((int64((_la-359)) & ^0x3f) == 0 && ((int64(1)<<(_la-359))&549756862465) != 0) || ((int64((_la-487)) & ^0x3f) == 0 && ((int64(1)<<(_la-487))&268436481) != 0) || _la == StmtParserSTORAGE || _la == StmtParserTABLESPACE {
			{
				p.SetState(831)
				p.PartitionOption()
			}

			p.SetState(836)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(848)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(837)
				p.Match(StmtParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(838)
				p.SubpartitionDefinition()
			}
			p.SetState(843)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StmtParserCOMMA {
				{
					p.SetState(839)
					p.Match(StmtParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(840)
					p.SubpartitionDefinition()
				}

				p.SetState(845)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(846)
				p.Match(StmtParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		localctx = NewPartitionSimpleContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(850)
			p.Match(StmtParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(851)
			p.Uid()
		}
		p.SetState(855)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserDEFAULT || _la == StmtParserINDEX || ((int64((_la-359)) & ^0x3f) == 0 && ((int64(1)<<(_la-359))&549756862465) != 0) || ((int64((_la-487)) & ^0x3f) == 0 && ((int64(1)<<(_la-487))&268436481) != 0) || _la == StmtParserSTORAGE || _la == StmtParserTABLESPACE {
			{
				p.SetState(852)
				p.PartitionOption()
			}

			p.SetState(857)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(869)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(858)
				p.Match(StmtParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(859)
				p.SubpartitionDefinition()
			}
			p.SetState(864)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StmtParserCOMMA {
				{
					p.SetState(860)
					p.Match(StmtParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(861)
					p.SubpartitionDefinition()
				}

				p.SetState(866)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(867)
				p.Match(StmtParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefinerAtomContext is an interface to support dynamic dispatch.
type IPartitionDefinerAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	Expression() IExpressionContext
	MAXVALUE() antlr.TerminalNode

	// IsPartitionDefinerAtomContext differentiates from other interfaces.
	IsPartitionDefinerAtomContext()
}

type PartitionDefinerAtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinerAtomContext() *PartitionDefinerAtomContext {
	var p = new(PartitionDefinerAtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_partitionDefinerAtom
	return p
}

func InitEmptyPartitionDefinerAtomContext(p *PartitionDefinerAtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_partitionDefinerAtom
}

func (*PartitionDefinerAtomContext) IsPartitionDefinerAtomContext() {}

func NewPartitionDefinerAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinerAtomContext {
	var p = new(PartitionDefinerAtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_partitionDefinerAtom

	return p
}

func (s *PartitionDefinerAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinerAtomContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PartitionDefinerAtomContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionDefinerAtomContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserMAXVALUE, 0)
}

func (s *PartitionDefinerAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinerAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinerAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionDefinerAtom(s)
	}
}

func (s *PartitionDefinerAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionDefinerAtom(s)
	}
}

func (p *StmtParser) PartitionDefinerAtom() (localctx IPartitionDefinerAtomContext) {
	localctx = NewPartitionDefinerAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, StmtParserRULE_partitionDefinerAtom)
	p.SetState(876)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(873)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(874)
			p.expression(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(875)
			p.Match(StmtParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefinerVectorContext is an interface to support dynamic dispatch.
type IPartitionDefinerVectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllPartitionDefinerAtom() []IPartitionDefinerAtomContext
	PartitionDefinerAtom(i int) IPartitionDefinerAtomContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionDefinerVectorContext differentiates from other interfaces.
	IsPartitionDefinerVectorContext()
}

type PartitionDefinerVectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinerVectorContext() *PartitionDefinerVectorContext {
	var p = new(PartitionDefinerVectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_partitionDefinerVector
	return p
}

func InitEmptyPartitionDefinerVectorContext(p *PartitionDefinerVectorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_partitionDefinerVector
}

func (*PartitionDefinerVectorContext) IsPartitionDefinerVectorContext() {}

func NewPartitionDefinerVectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinerVectorContext {
	var p = new(PartitionDefinerVectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_partitionDefinerVector

	return p
}

func (s *PartitionDefinerVectorContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinerVectorContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *PartitionDefinerVectorContext) AllPartitionDefinerAtom() []IPartitionDefinerAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerAtomContext); ok {
			tst[i] = t.(IPartitionDefinerAtomContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinerVectorContext) PartitionDefinerAtom(i int) IPartitionDefinerAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerAtomContext)
}

func (s *PartitionDefinerVectorContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *PartitionDefinerVectorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *PartitionDefinerVectorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *PartitionDefinerVectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinerVectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinerVectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionDefinerVector(s)
	}
}

func (s *PartitionDefinerVectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionDefinerVector(s)
	}
}

func (p *StmtParser) PartitionDefinerVector() (localctx IPartitionDefinerVectorContext) {
	localctx = NewPartitionDefinerVectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, StmtParserRULE_partitionDefinerVector)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(878)
		p.Match(StmtParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(879)
		p.PartitionDefinerAtom()
	}
	p.SetState(882)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == StmtParserCOMMA {
		{
			p.SetState(880)
			p.Match(StmtParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(881)
			p.PartitionDefinerAtom()
		}

		p.SetState(884)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(886)
		p.Match(StmtParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubpartitionDefinitionContext is an interface to support dynamic dispatch.
type ISubpartitionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBPARTITION() antlr.TerminalNode
	Uid() IUidContext
	AllPartitionOption() []IPartitionOptionContext
	PartitionOption(i int) IPartitionOptionContext

	// IsSubpartitionDefinitionContext differentiates from other interfaces.
	IsSubpartitionDefinitionContext()
}

type SubpartitionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubpartitionDefinitionContext() *SubpartitionDefinitionContext {
	var p = new(SubpartitionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_subpartitionDefinition
	return p
}

func InitEmptySubpartitionDefinitionContext(p *SubpartitionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_subpartitionDefinition
}

func (*SubpartitionDefinitionContext) IsSubpartitionDefinitionContext() {}

func NewSubpartitionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubpartitionDefinitionContext {
	var p = new(SubpartitionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_subpartitionDefinition

	return p
}

func (s *SubpartitionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubpartitionDefinitionContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBPARTITION, 0)
}

func (s *SubpartitionDefinitionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SubpartitionDefinitionContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *SubpartitionDefinitionContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *SubpartitionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubpartitionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubpartitionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSubpartitionDefinition(s)
	}
}

func (s *SubpartitionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSubpartitionDefinition(s)
	}
}

func (p *StmtParser) SubpartitionDefinition() (localctx ISubpartitionDefinitionContext) {
	localctx = NewSubpartitionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, StmtParserRULE_subpartitionDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(888)
		p.Match(StmtParserSUBPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(889)
		p.Uid()
	}
	p.SetState(893)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StmtParserDEFAULT || _la == StmtParserINDEX || ((int64((_la-359)) & ^0x3f) == 0 && ((int64(1)<<(_la-359))&549756862465) != 0) || ((int64((_la-487)) & ^0x3f) == 0 && ((int64(1)<<(_la-487))&268436481) != 0) || _la == StmtParserSTORAGE || _la == StmtParserTABLESPACE {
		{
			p.SetState(890)
			p.PartitionOption()
		}

		p.SetState(895)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionOptionContext is an interface to support dynamic dispatch.
type IPartitionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionOptionContext differentiates from other interfaces.
	IsPartitionOptionContext()
}

type PartitionOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionOptionContext() *PartitionOptionContext {
	var p = new(PartitionOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_partitionOption
	return p
}

func InitEmptyPartitionOptionContext(p *PartitionOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_partitionOption
}

func (*PartitionOptionContext) IsPartitionOptionContext() {}

func NewPartitionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionOptionContext {
	var p = new(PartitionOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_partitionOption

	return p
}

func (s *PartitionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionOptionContext) CopyAll(ctx *PartitionOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PartitionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PartitionOptionCommentContext struct {
	PartitionOptionContext
	comment antlr.Token
}

func NewPartitionOptionCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionCommentContext {
	var p = new(PartitionOptionCommentContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionCommentContext) GetComment() antlr.Token { return s.comment }

func (s *PartitionOptionCommentContext) SetComment(v antlr.Token) { s.comment = v }

func (s *PartitionOptionCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMENT, 0)
}

func (s *PartitionOptionCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *PartitionOptionCommentContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionOptionComment(s)
	}
}

func (s *PartitionOptionCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionOptionComment(s)
	}
}

type PartitionOptionNodeGroupContext struct {
	PartitionOptionContext
	nodegroup IUidContext
}

func NewPartitionOptionNodeGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionNodeGroupContext {
	var p = new(PartitionOptionNodeGroupContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionNodeGroupContext) GetNodegroup() IUidContext { return s.nodegroup }

func (s *PartitionOptionNodeGroupContext) SetNodegroup(v IUidContext) { s.nodegroup = v }

func (s *PartitionOptionNodeGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionNodeGroupContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(StmtParserNODEGROUP, 0)
}

func (s *PartitionOptionNodeGroupContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionOptionNodeGroupContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionNodeGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionOptionNodeGroup(s)
	}
}

func (s *PartitionOptionNodeGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionOptionNodeGroup(s)
	}
}

type PartitionOptionIndexDirectoryContext struct {
	PartitionOptionContext
	indexDirectory antlr.Token
}

func NewPartitionOptionIndexDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionIndexDirectoryContext {
	var p = new(PartitionOptionIndexDirectoryContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionIndexDirectoryContext) GetIndexDirectory() antlr.Token {
	return s.indexDirectory
}

func (s *PartitionOptionIndexDirectoryContext) SetIndexDirectory(v antlr.Token) { s.indexDirectory = v }

func (s *PartitionOptionIndexDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionIndexDirectoryContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StmtParserINDEX, 0)
}

func (s *PartitionOptionIndexDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(StmtParserDIRECTORY, 0)
}

func (s *PartitionOptionIndexDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *PartitionOptionIndexDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionIndexDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionOptionIndexDirectory(s)
	}
}

func (s *PartitionOptionIndexDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionOptionIndexDirectory(s)
	}
}

type PartitionOptionMaxRowsContext struct {
	PartitionOptionContext
	maxRows IDecimalLiteralContext
}

func NewPartitionOptionMaxRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionMaxRowsContext {
	var p = new(PartitionOptionMaxRowsContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionMaxRowsContext) GetMaxRows() IDecimalLiteralContext { return s.maxRows }

func (s *PartitionOptionMaxRowsContext) SetMaxRows(v IDecimalLiteralContext) { s.maxRows = v }

func (s *PartitionOptionMaxRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionMaxRowsContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(StmtParserMAX_ROWS, 0)
}

func (s *PartitionOptionMaxRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PartitionOptionMaxRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionMaxRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionOptionMaxRows(s)
	}
}

func (s *PartitionOptionMaxRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionOptionMaxRows(s)
	}
}

type PartitionOptionTablespaceContext struct {
	PartitionOptionContext
	tablespace IUidContext
}

func NewPartitionOptionTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionTablespaceContext {
	var p = new(PartitionOptionTablespaceContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionTablespaceContext) GetTablespace() IUidContext { return s.tablespace }

func (s *PartitionOptionTablespaceContext) SetTablespace(v IUidContext) { s.tablespace = v }

func (s *PartitionOptionTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(StmtParserTABLESPACE, 0)
}

func (s *PartitionOptionTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionOptionTablespaceContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionOptionTablespace(s)
	}
}

func (s *PartitionOptionTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionOptionTablespace(s)
	}
}

type PartitionOptionEngineContext struct {
	PartitionOptionContext
}

func NewPartitionOptionEngineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionEngineContext {
	var p = new(PartitionOptionEngineContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionEngineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionEngineContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(StmtParserENGINE, 0)
}

func (s *PartitionOptionEngineContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *PartitionOptionEngineContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *PartitionOptionEngineContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StmtParserSTORAGE, 0)
}

func (s *PartitionOptionEngineContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionEngineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionOptionEngine(s)
	}
}

func (s *PartitionOptionEngineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionOptionEngine(s)
	}
}

type PartitionOptionMinRowsContext struct {
	PartitionOptionContext
	minRows IDecimalLiteralContext
}

func NewPartitionOptionMinRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionMinRowsContext {
	var p = new(PartitionOptionMinRowsContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionMinRowsContext) GetMinRows() IDecimalLiteralContext { return s.minRows }

func (s *PartitionOptionMinRowsContext) SetMinRows(v IDecimalLiteralContext) { s.minRows = v }

func (s *PartitionOptionMinRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionMinRowsContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(StmtParserMIN_ROWS, 0)
}

func (s *PartitionOptionMinRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PartitionOptionMinRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionMinRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionOptionMinRows(s)
	}
}

func (s *PartitionOptionMinRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionOptionMinRows(s)
	}
}

type PartitionOptionDataDirectoryContext struct {
	PartitionOptionContext
	dataDirectory antlr.Token
}

func NewPartitionOptionDataDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionDataDirectoryContext {
	var p = new(PartitionOptionDataDirectoryContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionDataDirectoryContext) GetDataDirectory() antlr.Token { return s.dataDirectory }

func (s *PartitionOptionDataDirectoryContext) SetDataDirectory(v antlr.Token) { s.dataDirectory = v }

func (s *PartitionOptionDataDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionDataDirectoryContext) DATA() antlr.TerminalNode {
	return s.GetToken(StmtParserDATA, 0)
}

func (s *PartitionOptionDataDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(StmtParserDIRECTORY, 0)
}

func (s *PartitionOptionDataDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *PartitionOptionDataDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionDataDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionOptionDataDirectory(s)
	}
}

func (s *PartitionOptionDataDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionOptionDataDirectory(s)
	}
}

func (p *StmtParser) PartitionOption() (localctx IPartitionOptionContext) {
	localctx = NewPartitionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, StmtParserRULE_partitionOption)
	var _la int

	p.SetState(944)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StmtParserDEFAULT, StmtParserENGINE, StmtParserSTORAGE:
		localctx = NewPartitionOptionEngineContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(897)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserDEFAULT {
			{
				p.SetState(896)
				p.Match(StmtParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(900)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserSTORAGE {
			{
				p.SetState(899)
				p.Match(StmtParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(902)
			p.Match(StmtParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(903)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(906)
			p.EngineName()
		}

	case StmtParserCOMMENT:
		localctx = NewPartitionOptionCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(907)
			p.Match(StmtParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(909)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(908)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(911)

			var _m = p.Match(StmtParserSTRING_LITERAL)

			localctx.(*PartitionOptionCommentContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserDATA:
		localctx = NewPartitionOptionDataDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(912)
			p.Match(StmtParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(913)
			p.Match(StmtParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(915)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(914)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(917)

			var _m = p.Match(StmtParserSTRING_LITERAL)

			localctx.(*PartitionOptionDataDirectoryContext).dataDirectory = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserINDEX:
		localctx = NewPartitionOptionIndexDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(918)
			p.Match(StmtParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(919)
			p.Match(StmtParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(921)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(920)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(923)

			var _m = p.Match(StmtParserSTRING_LITERAL)

			localctx.(*PartitionOptionIndexDirectoryContext).indexDirectory = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserMAX_ROWS:
		localctx = NewPartitionOptionMaxRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(924)
			p.Match(StmtParserMAX_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(926)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(925)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(928)

			var _x = p.DecimalLiteral()

			localctx.(*PartitionOptionMaxRowsContext).maxRows = _x
		}

	case StmtParserMIN_ROWS:
		localctx = NewPartitionOptionMinRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(929)
			p.Match(StmtParserMIN_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(931)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(930)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(933)

			var _x = p.DecimalLiteral()

			localctx.(*PartitionOptionMinRowsContext).minRows = _x
		}

	case StmtParserTABLESPACE:
		localctx = NewPartitionOptionTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(934)
			p.Match(StmtParserTABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(936)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(935)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(938)

			var _x = p.Uid()

			localctx.(*PartitionOptionTablespaceContext).tablespace = _x
		}

	case StmtParserNODEGROUP:
		localctx = NewPartitionOptionNodeGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(939)
			p.Match(StmtParserNODEGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(941)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(940)
				p.Match(StmtParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(943)

			var _x = p.Uid()

			localctx.(*PartitionOptionNodeGroupContext).nodegroup = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullIdContext is an interface to support dynamic dispatch.
type IFullIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUid() []IUidContext
	Uid(i int) IUidContext
	DOT_ID() antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsFullIdContext differentiates from other interfaces.
	IsFullIdContext()
}

type FullIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullIdContext() *FullIdContext {
	var p = new(FullIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_fullId
	return p
}

func InitEmptyFullIdContext(p *FullIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_fullId
}

func (*FullIdContext) IsFullIdContext() {}

func NewFullIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullIdContext {
	var p = new(FullIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_fullId

	return p
}

func (s *FullIdContext) GetParser() antlr.Parser { return s.parser }

func (s *FullIdContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *FullIdContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FullIdContext) DOT_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserDOT_ID, 0)
}

func (s *FullIdContext) DOT() antlr.TerminalNode {
	return s.GetToken(StmtParserDOT, 0)
}

func (s *FullIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterFullId(s)
	}
}

func (s *FullIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitFullId(s)
	}
}

func (p *StmtParser) FullId() (localctx IFullIdContext) {
	localctx = NewFullIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, StmtParserRULE_fullId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(946)
		p.Uid()
	}
	p.SetState(950)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StmtParserDOT_ID:
		{
			p.SetState(947)
			p.Match(StmtParserDOT_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserDOT:
		{
			p.SetState(948)
			p.Match(StmtParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(949)
			p.Uid()
		}

	case StmtParserAS, StmtParserCHECK, StmtParserCOLLATE, StmtParserCONSTRAINT, StmtParserDEFAULT, StmtParserGENERATED, StmtParserKEY, StmtParserMATCH, StmtParserNOT, StmtParserNULL_LITERAL, StmtParserON, StmtParserPRIMARY, StmtParserREFERENCES, StmtParserUNIQUE, StmtParserSERIAL, StmtParserAUTO_INCREMENT, StmtParserCOLUMN_FORMAT, StmtParserCOMMENT, StmtParserINVISIBLE, StmtParserSTORAGE, StmtParserVISIBLE, StmtParserLR_BRACKET, StmtParserRR_BRACKET, StmtParserCOMMA, StmtParserNULL_SPEC_LITERAL:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FullId() IFullIdContext

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_tableName
	return p
}

func InitEmptyTableNameContext(p *TableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_tableName
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (p *StmtParser) TableName() (localctx ITableNameContext) {
	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, StmtParserRULE_tableName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(952)
		p.FullId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullColumnNameContext is an interface to support dynamic dispatch.
type IFullColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	AllDottedId() []IDottedIdContext
	DottedId(i int) IDottedIdContext

	// IsFullColumnNameContext differentiates from other interfaces.
	IsFullColumnNameContext()
}

type FullColumnNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullColumnNameContext() *FullColumnNameContext {
	var p = new(FullColumnNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_fullColumnName
	return p
}

func InitEmptyFullColumnNameContext(p *FullColumnNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_fullColumnName
}

func (*FullColumnNameContext) IsFullColumnNameContext() {}

func NewFullColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullColumnNameContext {
	var p = new(FullColumnNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_fullColumnName

	return p
}

func (s *FullColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FullColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FullColumnNameContext) AllDottedId() []IDottedIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDottedIdContext); ok {
			len++
		}
	}

	tst := make([]IDottedIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDottedIdContext); ok {
			tst[i] = t.(IDottedIdContext)
			i++
		}
	}

	return tst
}

func (s *FullColumnNameContext) DottedId(i int) IDottedIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDottedIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDottedIdContext)
}

func (s *FullColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterFullColumnName(s)
	}
}

func (s *FullColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitFullColumnName(s)
	}
}

func (p *StmtParser) FullColumnName() (localctx IFullColumnNameContext) {
	localctx = NewFullColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, StmtParserRULE_fullColumnName)
	p.SetState(966)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(954)
			p.Uid()
		}
		p.SetState(959)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 140, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(955)
				p.DottedId()
			}
			p.SetState(957)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(956)
					p.DottedId()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(961)
		p.MatchWildcard()

		{
			p.SetState(962)
			p.DottedId()
		}
		p.SetState(964)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(963)
				p.DottedId()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexColumnNameContext is an interface to support dynamic dispatch.
type IIndexColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSortType returns the sortType token.
	GetSortType() antlr.Token

	// SetSortType sets the sortType token.
	SetSortType(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	Uid() IUidContext
	STRING_LITERAL() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	RR_BRACKET() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsIndexColumnNameContext differentiates from other interfaces.
	IsIndexColumnNameContext()
}

type IndexColumnNameContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	sortType antlr.Token
}

func NewEmptyIndexColumnNameContext() *IndexColumnNameContext {
	var p = new(IndexColumnNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_indexColumnName
	return p
}

func InitEmptyIndexColumnNameContext(p *IndexColumnNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_indexColumnName
}

func (*IndexColumnNameContext) IsIndexColumnNameContext() {}

func NewIndexColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnNameContext {
	var p = new(IndexColumnNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_indexColumnName

	return p
}

func (s *IndexColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnNameContext) GetSortType() antlr.Token { return s.sortType }

func (s *IndexColumnNameContext) SetSortType(v antlr.Token) { s.sortType = v }

func (s *IndexColumnNameContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *IndexColumnNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *IndexColumnNameContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *IndexColumnNameContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *IndexColumnNameContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *IndexColumnNameContext) ASC() antlr.TerminalNode {
	return s.GetToken(StmtParserASC, 0)
}

func (s *IndexColumnNameContext) DESC() antlr.TerminalNode {
	return s.GetToken(StmtParserDESC, 0)
}

func (s *IndexColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIndexColumnName(s)
	}
}

func (s *IndexColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIndexColumnName(s)
	}
}

func (p *StmtParser) IndexColumnName() (localctx IIndexColumnNameContext) {
	localctx = NewIndexColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, StmtParserRULE_indexColumnName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(979)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext()) {
	case 1:
		p.SetState(970)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(968)
				p.Uid()
			}

		case 2:
			{
				p.SetState(969)
				p.Match(StmtParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(976)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(972)
				p.Match(StmtParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(973)
				p.DecimalLiteral()
			}
			{
				p.SetState(974)
				p.Match(StmtParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		{
			p.SetState(978)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(982)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserASC || _la == StmtParserDESC {
		{
			p.SetState(981)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IndexColumnNameContext).sortType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserASC || _la == StmtParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IndexColumnNameContext).sortType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMysqlVariableContext is an interface to support dynamic dispatch.
type IMysqlVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL_ID() antlr.TerminalNode
	GLOBAL_ID() antlr.TerminalNode

	// IsMysqlVariableContext differentiates from other interfaces.
	IsMysqlVariableContext()
}

type MysqlVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMysqlVariableContext() *MysqlVariableContext {
	var p = new(MysqlVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_mysqlVariable
	return p
}

func InitEmptyMysqlVariableContext(p *MysqlVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_mysqlVariable
}

func (*MysqlVariableContext) IsMysqlVariableContext() {}

func NewMysqlVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MysqlVariableContext {
	var p = new(MysqlVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_mysqlVariable

	return p
}

func (s *MysqlVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *MysqlVariableContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserLOCAL_ID, 0)
}

func (s *MysqlVariableContext) GLOBAL_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserGLOBAL_ID, 0)
}

func (s *MysqlVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MysqlVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterMysqlVariable(s)
	}
}

func (s *MysqlVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitMysqlVariable(s)
	}
}

func (p *StmtParser) MysqlVariable() (localctx IMysqlVariableContext) {
	localctx = NewMysqlVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, StmtParserRULE_mysqlVariable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(984)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserLOCAL_ID || _la == StmtParserGLOBAL_ID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetNameContext is an interface to support dynamic dispatch.
type ICharsetNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINARY() antlr.TerminalNode
	CharsetNameBase() ICharsetNameBaseContext
	STRING_LITERAL() antlr.TerminalNode
	CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode

	// IsCharsetNameContext differentiates from other interfaces.
	IsCharsetNameContext()
}

type CharsetNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameContext() *CharsetNameContext {
	var p = new(CharsetNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_charsetName
	return p
}

func InitEmptyCharsetNameContext(p *CharsetNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_charsetName
}

func (*CharsetNameContext) IsCharsetNameContext() {}

func NewCharsetNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameContext {
	var p = new(CharsetNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_charsetName

	return p
}

func (s *CharsetNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameContext) BINARY() antlr.TerminalNode {
	return s.GetToken(StmtParserBINARY, 0)
}

func (s *CharsetNameContext) CharsetNameBase() ICharsetNameBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameBaseContext)
}

func (s *CharsetNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *CharsetNameContext) CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode {
	return s.GetToken(StmtParserCHARSET_REVERSE_QOUTE_STRING, 0)
}

func (s *CharsetNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCharsetName(s)
	}
}

func (s *CharsetNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCharsetName(s)
	}
}

func (p *StmtParser) CharsetName() (localctx ICharsetNameContext) {
	localctx = NewCharsetNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, StmtParserRULE_charsetName)
	p.SetState(990)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(986)
			p.Match(StmtParserBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(987)
			p.CharsetNameBase()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(988)
			p.Match(StmtParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(989)
			p.Match(StmtParserCHARSET_REVERSE_QOUTE_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollationNameContext is an interface to support dynamic dispatch.
type ICollationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	STRING_LITERAL() antlr.TerminalNode

	// IsCollationNameContext differentiates from other interfaces.
	IsCollationNameContext()
}

type CollationNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollationNameContext() *CollationNameContext {
	var p = new(CollationNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_collationName
	return p
}

func InitEmptyCollationNameContext(p *CollationNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_collationName
}

func (*CollationNameContext) IsCollationNameContext() {}

func NewCollationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollationNameContext {
	var p = new(CollationNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_collationName

	return p
}

func (s *CollationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CollationNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CollationNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *CollationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCollationName(s)
	}
}

func (s *CollationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCollationName(s)
	}
}

func (p *StmtParser) CollationName() (localctx ICollationNameContext) {
	localctx = NewCollationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, StmtParserRULE_collationName)
	p.SetState(994)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(992)
			p.Uid()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(993)
			p.Match(StmtParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEngineNameContext is an interface to support dynamic dispatch.
type IEngineNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARCHIVE() antlr.TerminalNode
	BLACKHOLE() antlr.TerminalNode
	CSV() antlr.TerminalNode
	FEDERATED() antlr.TerminalNode
	INNODB() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	MRG_MYISAM() antlr.TerminalNode
	MYISAM() antlr.TerminalNode
	NDB() antlr.TerminalNode
	NDBCLUSTER() antlr.TerminalNode
	PERFORMANCE_SCHEMA() antlr.TerminalNode
	TOKUDB() antlr.TerminalNode
	ID() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	REVERSE_QUOTE_ID() antlr.TerminalNode
	CONNECT() antlr.TerminalNode

	// IsEngineNameContext differentiates from other interfaces.
	IsEngineNameContext()
}

type EngineNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineNameContext() *EngineNameContext {
	var p = new(EngineNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_engineName
	return p
}

func InitEmptyEngineNameContext(p *EngineNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_engineName
}

func (*EngineNameContext) IsEngineNameContext() {}

func NewEngineNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineNameContext {
	var p = new(EngineNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_engineName

	return p
}

func (s *EngineNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineNameContext) ARCHIVE() antlr.TerminalNode {
	return s.GetToken(StmtParserARCHIVE, 0)
}

func (s *EngineNameContext) BLACKHOLE() antlr.TerminalNode {
	return s.GetToken(StmtParserBLACKHOLE, 0)
}

func (s *EngineNameContext) CSV() antlr.TerminalNode {
	return s.GetToken(StmtParserCSV, 0)
}

func (s *EngineNameContext) FEDERATED() antlr.TerminalNode {
	return s.GetToken(StmtParserFEDERATED, 0)
}

func (s *EngineNameContext) INNODB() antlr.TerminalNode {
	return s.GetToken(StmtParserINNODB, 0)
}

func (s *EngineNameContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(StmtParserMEMORY, 0)
}

func (s *EngineNameContext) MRG_MYISAM() antlr.TerminalNode {
	return s.GetToken(StmtParserMRG_MYISAM, 0)
}

func (s *EngineNameContext) MYISAM() antlr.TerminalNode {
	return s.GetToken(StmtParserMYISAM, 0)
}

func (s *EngineNameContext) NDB() antlr.TerminalNode {
	return s.GetToken(StmtParserNDB, 0)
}

func (s *EngineNameContext) NDBCLUSTER() antlr.TerminalNode {
	return s.GetToken(StmtParserNDBCLUSTER, 0)
}

func (s *EngineNameContext) PERFORMANCE_SCHEMA() antlr.TerminalNode {
	return s.GetToken(StmtParserPERFORMANCE_SCHEMA, 0)
}

func (s *EngineNameContext) TOKUDB() antlr.TerminalNode {
	return s.GetToken(StmtParserTOKUDB, 0)
}

func (s *EngineNameContext) ID() antlr.TerminalNode {
	return s.GetToken(StmtParserID, 0)
}

func (s *EngineNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *EngineNameContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserREVERSE_QUOTE_ID, 0)
}

func (s *EngineNameContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONNECT, 0)
}

func (s *EngineNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EngineNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterEngineName(s)
	}
}

func (s *EngineNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitEngineName(s)
	}
}

func (p *StmtParser) EngineName() (localctx IEngineNameContext) {
	localctx = NewEngineNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, StmtParserRULE_engineName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(996)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserCONNECT || ((int64((_la-767)) & ^0x3f) == 0 && ((int64(1)<<(_la-767))&4095) != 0) || ((int64((_la-1138)) & ^0x3f) == 0 && ((int64(1)<<(_la-1138))&769) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUidContext is an interface to support dynamic dispatch.
type IUidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleId() ISimpleIdContext
	REVERSE_QUOTE_ID() antlr.TerminalNode
	CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode

	// IsUidContext differentiates from other interfaces.
	IsUidContext()
}

type UidContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUidContext() *UidContext {
	var p = new(UidContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_uid
	return p
}

func InitEmptyUidContext(p *UidContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_uid
}

func (*UidContext) IsUidContext() {}

func NewUidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UidContext {
	var p = new(UidContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_uid

	return p
}

func (s *UidContext) GetParser() antlr.Parser { return s.parser }

func (s *UidContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *UidContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserREVERSE_QUOTE_ID, 0)
}

func (s *UidContext) CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode {
	return s.GetToken(StmtParserCHARSET_REVERSE_QOUTE_STRING, 0)
}

func (s *UidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterUid(s)
	}
}

func (s *UidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitUid(s)
	}
}

func (p *StmtParser) Uid() (localctx IUidContext) {
	localctx = NewUidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, StmtParserRULE_uid)
	p.SetState(1001)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 149, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(998)
			p.SimpleId()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(999)
			p.Match(StmtParserREVERSE_QUOTE_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1000)
			p.Match(StmtParserCHARSET_REVERSE_QOUTE_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleIdContext is an interface to support dynamic dispatch.
type ISimpleIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	CharsetNameBase() ICharsetNameBaseContext
	TransactionLevelBase() ITransactionLevelBaseContext
	EngineName() IEngineNameContext
	PrivilegesBase() IPrivilegesBaseContext
	IntervalTypeBase() IIntervalTypeBaseContext
	DataTypeBase() IDataTypeBaseContext
	KeywordsCanBeId() IKeywordsCanBeIdContext
	ScalarFunctionName() IScalarFunctionNameContext

	// IsSimpleIdContext differentiates from other interfaces.
	IsSimpleIdContext()
}

type SimpleIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleIdContext() *SimpleIdContext {
	var p = new(SimpleIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_simpleId
	return p
}

func InitEmptySimpleIdContext(p *SimpleIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_simpleId
}

func (*SimpleIdContext) IsSimpleIdContext() {}

func NewSimpleIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleIdContext {
	var p = new(SimpleIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_simpleId

	return p
}

func (s *SimpleIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleIdContext) ID() antlr.TerminalNode {
	return s.GetToken(StmtParserID, 0)
}

func (s *SimpleIdContext) CharsetNameBase() ICharsetNameBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameBaseContext)
}

func (s *SimpleIdContext) TransactionLevelBase() ITransactionLevelBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionLevelBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionLevelBaseContext)
}

func (s *SimpleIdContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *SimpleIdContext) PrivilegesBase() IPrivilegesBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegesBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegesBaseContext)
}

func (s *SimpleIdContext) IntervalTypeBase() IIntervalTypeBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeBaseContext)
}

func (s *SimpleIdContext) DataTypeBase() IDataTypeBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeBaseContext)
}

func (s *SimpleIdContext) KeywordsCanBeId() IKeywordsCanBeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsCanBeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsCanBeIdContext)
}

func (s *SimpleIdContext) ScalarFunctionName() IScalarFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarFunctionNameContext)
}

func (s *SimpleIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSimpleId(s)
	}
}

func (s *SimpleIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSimpleId(s)
	}
}

func (p *StmtParser) SimpleId() (localctx ISimpleIdContext) {
	localctx = NewSimpleIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, StmtParserRULE_simpleId)
	p.SetState(1012)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1003)
			p.Match(StmtParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1004)
			p.CharsetNameBase()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1005)
			p.TransactionLevelBase()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1006)
			p.EngineName()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1007)
			p.PrivilegesBase()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1008)
			p.IntervalTypeBase()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1009)
			p.DataTypeBase()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1010)
			p.KeywordsCanBeId()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1011)
			p.ScalarFunctionName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDottedIdContext is an interface to support dynamic dispatch.
type IDottedIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT_ID() antlr.TerminalNode
	DOT() antlr.TerminalNode
	Uid() IUidContext

	// IsDottedIdContext differentiates from other interfaces.
	IsDottedIdContext()
}

type DottedIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDottedIdContext() *DottedIdContext {
	var p = new(DottedIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_dottedId
	return p
}

func InitEmptyDottedIdContext(p *DottedIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_dottedId
}

func (*DottedIdContext) IsDottedIdContext() {}

func NewDottedIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DottedIdContext {
	var p = new(DottedIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_dottedId

	return p
}

func (s *DottedIdContext) GetParser() antlr.Parser { return s.parser }

func (s *DottedIdContext) DOT_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserDOT_ID, 0)
}

func (s *DottedIdContext) DOT() antlr.TerminalNode {
	return s.GetToken(StmtParserDOT, 0)
}

func (s *DottedIdContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DottedIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DottedIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DottedIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterDottedId(s)
	}
}

func (s *DottedIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitDottedId(s)
	}
}

func (p *StmtParser) DottedId() (localctx IDottedIdContext) {
	localctx = NewDottedIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, StmtParserRULE_dottedId)
	p.SetState(1017)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StmtParserDOT_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1014)
			p.Match(StmtParserDOT_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1015)
			p.Match(StmtParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1016)
			p.Uid()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecimalLiteralContext is an interface to support dynamic dispatch.
type IDecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECIMAL_LITERAL() antlr.TerminalNode
	ZERO_DECIMAL() antlr.TerminalNode
	ONE_DECIMAL() antlr.TerminalNode
	TWO_DECIMAL() antlr.TerminalNode
	REAL_LITERAL() antlr.TerminalNode

	// IsDecimalLiteralContext differentiates from other interfaces.
	IsDecimalLiteralContext()
}

type DecimalLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalLiteralContext() *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_decimalLiteral
	return p
}

func InitEmptyDecimalLiteralContext(p *DecimalLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_decimalLiteral
}

func (*DecimalLiteralContext) IsDecimalLiteralContext() {}

func NewDecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_decimalLiteral

	return p
}

func (s *DecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserDECIMAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserZERO_DECIMAL, 0)
}

func (s *DecimalLiteralContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserONE_DECIMAL, 0)
}

func (s *DecimalLiteralContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserTWO_DECIMAL, 0)
}

func (s *DecimalLiteralContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserREAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

func (p *StmtParser) DecimalLiteral() (localctx IDecimalLiteralContext) {
	localctx = NewDecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, StmtParserRULE_decimalLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1019)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-1128)) & ^0x3f) == 0 && ((int64(1)<<(_la-1128))&10247) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileSizeLiteralContext is an interface to support dynamic dispatch.
type IFileSizeLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILESIZE_LITERAL() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext

	// IsFileSizeLiteralContext differentiates from other interfaces.
	IsFileSizeLiteralContext()
}

type FileSizeLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileSizeLiteralContext() *FileSizeLiteralContext {
	var p = new(FileSizeLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_fileSizeLiteral
	return p
}

func InitEmptyFileSizeLiteralContext(p *FileSizeLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_fileSizeLiteral
}

func (*FileSizeLiteralContext) IsFileSizeLiteralContext() {}

func NewFileSizeLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileSizeLiteralContext {
	var p = new(FileSizeLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_fileSizeLiteral

	return p
}

func (s *FileSizeLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FileSizeLiteralContext) FILESIZE_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserFILESIZE_LITERAL, 0)
}

func (s *FileSizeLiteralContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *FileSizeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileSizeLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileSizeLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterFileSizeLiteral(s)
	}
}

func (s *FileSizeLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitFileSizeLiteral(s)
	}
}

func (p *StmtParser) FileSizeLiteral() (localctx IFileSizeLiteralContext) {
	localctx = NewFileSizeLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, StmtParserRULE_fileSizeLiteral)
	p.SetState(1023)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StmtParserFILESIZE_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1021)
			p.Match(StmtParserFILESIZE_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserZERO_DECIMAL, StmtParserONE_DECIMAL, StmtParserTWO_DECIMAL, StmtParserDECIMAL_LITERAL, StmtParserREAL_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1022)
			p.DecimalLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	START_NATIONAL_STRING_LITERAL() antlr.TerminalNode
	STRING_CHARSET_NAME() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	CollationName() ICollationNameContext

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(StmtParserSTRING_LITERAL)
}

func (s *StringLiteralContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, i)
}

func (s *StringLiteralContext) START_NATIONAL_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTART_NATIONAL_STRING_LITERAL, 0)
}

func (s *StringLiteralContext) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_CHARSET_NAME, 0)
}

func (s *StringLiteralContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLLATE, 0)
}

func (s *StringLiteralContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *StmtParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, StmtParserRULE_stringLiteral)
	var _la int

	var _alt int

	p.SetState(1048)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1030)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StmtParserSTRING_LITERAL, StmtParserSTRING_CHARSET_NAME:
			p.SetState(1026)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StmtParserSTRING_CHARSET_NAME {
				{
					p.SetState(1025)
					p.Match(StmtParserSTRING_CHARSET_NAME)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1028)
				p.Match(StmtParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case StmtParserSTART_NATIONAL_STRING_LITERAL:
			{
				p.SetState(1029)
				p.Match(StmtParserSTART_NATIONAL_STRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(1033)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1032)
					p.Match(StmtParserSTRING_LITERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(1035)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1042)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StmtParserSTRING_LITERAL, StmtParserSTRING_CHARSET_NAME:
			p.SetState(1038)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StmtParserSTRING_CHARSET_NAME {
				{
					p.SetState(1037)
					p.Match(StmtParserSTRING_CHARSET_NAME)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1040)
				p.Match(StmtParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case StmtParserSTART_NATIONAL_STRING_LITERAL:
			{
				p.SetState(1041)
				p.Match(StmtParserSTART_NATIONAL_STRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(1046)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1044)
				p.Match(StmtParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1045)
				p.CollationName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_booleanLiteral
	return p
}

func InitEmptyBooleanLiteralContext(p *BooleanLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_booleanLiteral
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(StmtParserTRUE, 0)
}

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(StmtParserFALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *StmtParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, StmtParserRULE_booleanLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1050)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserFALSE || _la == StmtParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHexadecimalLiteralContext is an interface to support dynamic dispatch.
type IHexadecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HEXADECIMAL_LITERAL() antlr.TerminalNode
	STRING_CHARSET_NAME() antlr.TerminalNode

	// IsHexadecimalLiteralContext differentiates from other interfaces.
	IsHexadecimalLiteralContext()
}

type HexadecimalLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexadecimalLiteralContext() *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_hexadecimalLiteral
	return p
}

func InitEmptyHexadecimalLiteralContext(p *HexadecimalLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_hexadecimalLiteral
}

func (*HexadecimalLiteralContext) IsHexadecimalLiteralContext() {}

func NewHexadecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_hexadecimalLiteral

	return p
}

func (s *HexadecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *HexadecimalLiteralContext) HEXADECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserHEXADECIMAL_LITERAL, 0)
}

func (s *HexadecimalLiteralContext) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_CHARSET_NAME, 0)
}

func (s *HexadecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexadecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexadecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterHexadecimalLiteral(s)
	}
}

func (s *HexadecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitHexadecimalLiteral(s)
	}
}

func (p *StmtParser) HexadecimalLiteral() (localctx IHexadecimalLiteralContext) {
	localctx = NewHexadecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, StmtParserRULE_hexadecimalLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1053)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserSTRING_CHARSET_NAME {
		{
			p.SetState(1052)
			p.Match(StmtParserSTRING_CHARSET_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1055)
		p.Match(StmtParserHEXADECIMAL_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullNotnullContext is an interface to support dynamic dispatch.
type INullNotnullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL_LITERAL() antlr.TerminalNode
	NULL_SPEC_LITERAL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsNullNotnullContext differentiates from other interfaces.
	IsNullNotnullContext()
}

type NullNotnullContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullNotnullContext() *NullNotnullContext {
	var p = new(NullNotnullContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_nullNotnull
	return p
}

func InitEmptyNullNotnullContext(p *NullNotnullContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_nullNotnull
}

func (*NullNotnullContext) IsNullNotnullContext() {}

func NewNullNotnullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullNotnullContext {
	var p = new(NullNotnullContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_nullNotnull

	return p
}

func (s *NullNotnullContext) GetParser() antlr.Parser { return s.parser }

func (s *NullNotnullContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNULL_LITERAL, 0)
}

func (s *NullNotnullContext) NULL_SPEC_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNULL_SPEC_LITERAL, 0)
}

func (s *NullNotnullContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *NullNotnullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullNotnullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullNotnullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterNullNotnull(s)
	}
}

func (s *NullNotnullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitNullNotnull(s)
	}
}

func (p *StmtParser) NullNotnull() (localctx INullNotnullContext) {
	localctx = NewNullNotnullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, StmtParserRULE_nullNotnull)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1058)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserNOT {
		{
			p.SetState(1057)
			p.Match(StmtParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1060)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserNULL_LITERAL || _la == StmtParserNULL_SPEC_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNullLiteral returns the nullLiteral token.
	GetNullLiteral() antlr.Token

	// SetNullLiteral sets the nullLiteral token.
	SetNullLiteral(antlr.Token)

	// Getter signatures
	StringLiteral() IStringLiteralContext
	DecimalLiteral() IDecimalLiteralContext
	MINUS() antlr.TerminalNode
	HexadecimalLiteral() IHexadecimalLiteralContext
	BooleanLiteral() IBooleanLiteralContext
	REAL_LITERAL() antlr.TerminalNode
	BIT_STRING() antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	NULL_SPEC_LITERAL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	nullLiteral antlr.Token
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) GetNullLiteral() antlr.Token { return s.nullLiteral }

func (s *ConstantContext) SetNullLiteral(v antlr.Token) { s.nullLiteral = v }

func (s *ConstantContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ConstantContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ConstantContext) MINUS() antlr.TerminalNode {
	return s.GetToken(StmtParserMINUS, 0)
}

func (s *ConstantContext) HexadecimalLiteral() IHexadecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexadecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexadecimalLiteralContext)
}

func (s *ConstantContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *ConstantContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserREAL_LITERAL, 0)
}

func (s *ConstantContext) BIT_STRING() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_STRING, 0)
}

func (s *ConstantContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNULL_LITERAL, 0)
}

func (s *ConstantContext) NULL_SPEC_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNULL_SPEC_LITERAL, 0)
}

func (s *ConstantContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (p *StmtParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, StmtParserRULE_constant)
	var _la int

	p.SetState(1074)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1062)
			p.StringLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1063)
			p.DecimalLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1064)
			p.Match(StmtParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1065)
			p.DecimalLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1066)
			p.HexadecimalLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1067)
			p.BooleanLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1068)
			p.Match(StmtParserREAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1069)
			p.Match(StmtParserBIT_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(1071)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserNOT {
			{
				p.SetState(1070)
				p.Match(StmtParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1073)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConstantContext).nullLiteral = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserNULL_LITERAL || _la == StmtParserNULL_SPEC_LITERAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConstantContext).nullLiteral = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_dataType
	return p
}

func InitEmptyDataTypeContext(p *DataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_dataType
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) CopyAll(ctx *DataTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SpatialDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewSpatialDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpatialDataTypeContext {
	var p = new(SpatialDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *SpatialDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *SpatialDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *SpatialDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpatialDataTypeContext) GEOMETRYCOLLECTION() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMETRYCOLLECTION, 0)
}

func (s *SpatialDataTypeContext) GEOMCOLLECTION() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMCOLLECTION, 0)
}

func (s *SpatialDataTypeContext) LINESTRING() antlr.TerminalNode {
	return s.GetToken(StmtParserLINESTRING, 0)
}

func (s *SpatialDataTypeContext) MULTILINESTRING() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTILINESTRING, 0)
}

func (s *SpatialDataTypeContext) MULTIPOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTIPOINT, 0)
}

func (s *SpatialDataTypeContext) MULTIPOLYGON() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTIPOLYGON, 0)
}

func (s *SpatialDataTypeContext) POINT() antlr.TerminalNode {
	return s.GetToken(StmtParserPOINT, 0)
}

func (s *SpatialDataTypeContext) POLYGON() antlr.TerminalNode {
	return s.GetToken(StmtParserPOLYGON, 0)
}

func (s *SpatialDataTypeContext) GEOMETRY() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMETRY, 0)
}

func (s *SpatialDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSpatialDataType(s)
	}
}

func (s *SpatialDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSpatialDataType(s)
	}
}

type FloatDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewFloatDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FloatDataTypeContext {
	var p = new(FloatDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *FloatDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *FloatDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *FloatDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatDataTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserDECIMAL, 0)
}

func (s *FloatDataTypeContext) DEC() antlr.TerminalNode {
	return s.GetToken(StmtParserDEC, 0)
}

func (s *FloatDataTypeContext) FIXED() antlr.TerminalNode {
	return s.GetToken(StmtParserFIXED, 0)
}

func (s *FloatDataTypeContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(StmtParserNUMERIC, 0)
}

func (s *FloatDataTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(StmtParserFLOAT, 0)
}

func (s *FloatDataTypeContext) FLOAT4() antlr.TerminalNode {
	return s.GetToken(StmtParserFLOAT4, 0)
}

func (s *FloatDataTypeContext) FLOAT8() antlr.TerminalNode {
	return s.GetToken(StmtParserFLOAT8, 0)
}

func (s *FloatDataTypeContext) LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoOptionalDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoOptionalDimensionContext)
}

func (s *FloatDataTypeContext) AllSIGNED() []antlr.TerminalNode {
	return s.GetTokens(StmtParserSIGNED)
}

func (s *FloatDataTypeContext) SIGNED(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserSIGNED, i)
}

func (s *FloatDataTypeContext) AllUNSIGNED() []antlr.TerminalNode {
	return s.GetTokens(StmtParserUNSIGNED)
}

func (s *FloatDataTypeContext) UNSIGNED(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserUNSIGNED, i)
}

func (s *FloatDataTypeContext) AllZEROFILL() []antlr.TerminalNode {
	return s.GetTokens(StmtParserZEROFILL)
}

func (s *FloatDataTypeContext) ZEROFILL(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserZEROFILL, i)
}

func (s *FloatDataTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(StmtParserDOUBLE, 0)
}

func (s *FloatDataTypeContext) PRECISION() antlr.TerminalNode {
	return s.GetToken(StmtParserPRECISION, 0)
}

func (s *FloatDataTypeContext) LengthTwoDimension() ILengthTwoDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoDimensionContext)
}

func (s *FloatDataTypeContext) REAL() antlr.TerminalNode {
	return s.GetToken(StmtParserREAL, 0)
}

func (s *FloatDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterFloatDataType(s)
	}
}

func (s *FloatDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitFloatDataType(s)
	}
}

type IntegerDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewIntegerDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerDataTypeContext {
	var p = new(IntegerDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *IntegerDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *IntegerDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *IntegerDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerDataTypeContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(StmtParserTINYINT, 0)
}

func (s *IntegerDataTypeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(StmtParserSMALLINT, 0)
}

func (s *IntegerDataTypeContext) MEDIUMINT() antlr.TerminalNode {
	return s.GetToken(StmtParserMEDIUMINT, 0)
}

func (s *IntegerDataTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(StmtParserINT, 0)
}

func (s *IntegerDataTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(StmtParserINTEGER, 0)
}

func (s *IntegerDataTypeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(StmtParserBIGINT, 0)
}

func (s *IntegerDataTypeContext) MIDDLEINT() antlr.TerminalNode {
	return s.GetToken(StmtParserMIDDLEINT, 0)
}

func (s *IntegerDataTypeContext) INT1() antlr.TerminalNode {
	return s.GetToken(StmtParserINT1, 0)
}

func (s *IntegerDataTypeContext) INT2() antlr.TerminalNode {
	return s.GetToken(StmtParserINT2, 0)
}

func (s *IntegerDataTypeContext) INT3() antlr.TerminalNode {
	return s.GetToken(StmtParserINT3, 0)
}

func (s *IntegerDataTypeContext) INT4() antlr.TerminalNode {
	return s.GetToken(StmtParserINT4, 0)
}

func (s *IntegerDataTypeContext) INT8() antlr.TerminalNode {
	return s.GetToken(StmtParserINT8, 0)
}

func (s *IntegerDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *IntegerDataTypeContext) AllSIGNED() []antlr.TerminalNode {
	return s.GetTokens(StmtParserSIGNED)
}

func (s *IntegerDataTypeContext) SIGNED(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserSIGNED, i)
}

func (s *IntegerDataTypeContext) AllUNSIGNED() []antlr.TerminalNode {
	return s.GetTokens(StmtParserUNSIGNED)
}

func (s *IntegerDataTypeContext) UNSIGNED(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserUNSIGNED, i)
}

func (s *IntegerDataTypeContext) AllZEROFILL() []antlr.TerminalNode {
	return s.GetTokens(StmtParserZEROFILL)
}

func (s *IntegerDataTypeContext) ZEROFILL(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserZEROFILL, i)
}

func (s *IntegerDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIntegerDataType(s)
	}
}

func (s *IntegerDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIntegerDataType(s)
	}
}

type SpecialDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewSpecialDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialDataTypeContext {
	var p = new(SpecialDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *SpecialDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *SpecialDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *SpecialDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialDataTypeContext) BOOL() antlr.TerminalNode {
	return s.GetToken(StmtParserBOOL, 0)
}

func (s *SpecialDataTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(StmtParserBOOLEAN, 0)
}

func (s *SpecialDataTypeContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSERIAL, 0)
}

func (s *SpecialDataTypeContext) BIT() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT, 0)
}

func (s *SpecialDataTypeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserYEAR, 0)
}

func (s *SpecialDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *SpecialDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSpecialDataType(s)
	}
}

func (s *SpecialDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSpecialDataType(s)
	}
}

type StringDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewStringDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringDataTypeContext {
	var p = new(StringDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *StringDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *StringDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *StringDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(StmtParserCHAR, 0)
}

func (s *StringDataTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(StmtParserCHARACTER, 0)
}

func (s *StringDataTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(StmtParserVARCHAR, 0)
}

func (s *StringDataTypeContext) TINYTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserTINYTEXT, 0)
}

func (s *StringDataTypeContext) TEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserTEXT, 0)
}

func (s *StringDataTypeContext) MEDIUMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserMEDIUMTEXT, 0)
}

func (s *StringDataTypeContext) LONGTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserLONGTEXT, 0)
}

func (s *StringDataTypeContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(StmtParserNCHAR, 0)
}

func (s *StringDataTypeContext) NVARCHAR() antlr.TerminalNode {
	return s.GetToken(StmtParserNVARCHAR, 0)
}

func (s *StringDataTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(StmtParserLONG, 0)
}

func (s *StringDataTypeContext) VARYING() antlr.TerminalNode {
	return s.GetToken(StmtParserVARYING, 0)
}

func (s *StringDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *StringDataTypeContext) AllBINARY() []antlr.TerminalNode {
	return s.GetTokens(StmtParserBINARY)
}

func (s *StringDataTypeContext) BINARY(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserBINARY, i)
}

func (s *StringDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *StringDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *StringDataTypeContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLLATE, 0)
}

func (s *StringDataTypeContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *StringDataTypeContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNATIONAL, 0)
}

func (s *StringDataTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(StmtParserVARBINARY, 0)
}

func (s *StringDataTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON, 0)
}

func (s *StringDataTypeContext) CollectionOptions() ICollectionOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollectionOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollectionOptionsContext)
}

func (s *StringDataTypeContext) ENUM() antlr.TerminalNode {
	return s.GetToken(StmtParserENUM, 0)
}

func (s *StringDataTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(StmtParserSET, 0)
}

func (s *StringDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterStringDataType(s)
	}
}

func (s *StringDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitStringDataType(s)
	}
}

type BinaryDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewBinaryDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryDataTypeContext {
	var p = new(BinaryDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *BinaryDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *BinaryDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *BinaryDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(StmtParserBINARY, 0)
}

func (s *BinaryDataTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(StmtParserVARBINARY, 0)
}

func (s *BinaryDataTypeContext) BLOB() antlr.TerminalNode {
	return s.GetToken(StmtParserBLOB, 0)
}

func (s *BinaryDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *BinaryDataTypeContext) TINYBLOB() antlr.TerminalNode {
	return s.GetToken(StmtParserTINYBLOB, 0)
}

func (s *BinaryDataTypeContext) MEDIUMBLOB() antlr.TerminalNode {
	return s.GetToken(StmtParserMEDIUMBLOB, 0)
}

func (s *BinaryDataTypeContext) LONGBLOB() antlr.TerminalNode {
	return s.GetToken(StmtParserLONGBLOB, 0)
}

func (s *BinaryDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterBinaryDataType(s)
	}
}

func (s *BinaryDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitBinaryDataType(s)
	}
}

type TimeDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewTimeDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeDataTypeContext {
	var p = new(TimeDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *TimeDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *TimeDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *TimeDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeDataTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(StmtParserTIME, 0)
}

func (s *TimeDataTypeContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserTIMESTAMP, 0)
}

func (s *TimeDataTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(StmtParserDATETIME, 0)
}

func (s *TimeDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *TimeDataTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(StmtParserDATE, 0)
}

func (s *TimeDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTimeDataType(s)
	}
}

func (s *TimeDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTimeDataType(s)
	}
}

func (p *StmtParser) DataType() (localctx IDataTypeContext) {
	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, StmtParserRULE_dataType)
	var _la int

	p.SetState(1211)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 194, p.GetParserRuleContext()) {
	case 1:
		localctx = NewIntegerDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1076)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IntegerDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-190)) & ^0x3f) == 0 && ((int64(1)<<(_la-190))&4095) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IntegerDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1078)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1077)
				p.LengthOneDimension()
			}

		}
		p.SetState(1083)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserUNSIGNED || _la == StmtParserZEROFILL || _la == StmtParserSIGNED {
			{
				p.SetState(1080)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StmtParserUNSIGNED || _la == StmtParserZEROFILL || _la == StmtParserSIGNED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(1085)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewFloatDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1086)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FloatDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-205)) & ^0x3f) == 0 && ((int64(1)<<(_la-205))&63) != 0) || _la == StmtParserFIXED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FloatDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1088)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1087)
				p.LengthTwoOptionalDimension()
			}

		}
		p.SetState(1093)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserUNSIGNED || _la == StmtParserZEROFILL || _la == StmtParserSIGNED {
			{
				p.SetState(1090)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StmtParserUNSIGNED || _la == StmtParserZEROFILL || _la == StmtParserSIGNED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(1095)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewFloatDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1096)

			var _m = p.Match(StmtParserDOUBLE)

			localctx.(*FloatDataTypeContext).typeName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1098)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserPRECISION {
			{
				p.SetState(1097)
				p.Match(StmtParserPRECISION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1101)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1100)
				p.LengthTwoDimension()
			}

		}
		p.SetState(1106)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserUNSIGNED || _la == StmtParserZEROFILL || _la == StmtParserSIGNED {
			{
				p.SetState(1103)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StmtParserUNSIGNED || _la == StmtParserZEROFILL || _la == StmtParserSIGNED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(1108)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 4:
		localctx = NewFloatDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1109)

			var _m = p.Match(StmtParserREAL)

			localctx.(*FloatDataTypeContext).typeName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1111)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1110)
				p.LengthTwoDimension()
			}

		}
		p.SetState(1116)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserUNSIGNED || _la == StmtParserZEROFILL || _la == StmtParserSIGNED {
			{
				p.SetState(1113)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StmtParserUNSIGNED || _la == StmtParserZEROFILL || _la == StmtParserSIGNED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(1118)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 5:
		localctx = NewTimeDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1119)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TimeDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-212)) & ^0x3f) == 0 && ((int64(1)<<(_la-212))&7) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TimeDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1121)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1120)
				p.LengthOneDimension()
			}

		}

	case 6:
		localctx = NewTimeDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1123)
			p.Match(StmtParserDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1124)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserCHARACTER || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&31239) != 0) || _la == StmtParserNCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserVARYING {
			{
				p.SetState(1125)
				p.Match(StmtParserVARYING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1129)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1128)
				p.LengthOneDimension()
			}

		}
		p.SetState(1132)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1131)
				p.Match(StmtParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1137)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCHARACTER || _la == StmtParserCHAR || _la == StmtParserCHARSET {
			{
				p.SetState(1134)
				p.CharSet()
			}
			{
				p.SetState(1135)
				p.CharsetName()
			}

		}
		p.SetState(1142)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1139)
				p.Match(StmtParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1140)
				p.CollationName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1141)
				p.Match(StmtParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1144)
			p.Match(StmtParserNATIONAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1145)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserCHARACTER || _la == StmtParserVARCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1147)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1146)
				p.LengthOneDimension()
			}

		}
		p.SetState(1150)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserBINARY {
			{
				p.SetState(1149)
				p.Match(StmtParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 9:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1152)
			p.Match(StmtParserNCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1153)

			var _m = p.Match(StmtParserVARCHAR)

			localctx.(*StringDataTypeContext).typeName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1155)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1154)
				p.LengthOneDimension()
			}

		}
		p.SetState(1158)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserBINARY {
			{
				p.SetState(1157)
				p.Match(StmtParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 10:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1160)
			p.Match(StmtParserNATIONAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1161)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserCHARACTER || _la == StmtParserCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1162)
			p.Match(StmtParserVARYING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1164)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1163)
				p.LengthOneDimension()
			}

		}
		p.SetState(1167)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserBINARY {
			{
				p.SetState(1166)
				p.Match(StmtParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 11:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1169)

			var _m = p.Match(StmtParserLONG)

			localctx.(*StringDataTypeContext).typeName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1171)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserVARCHAR {
			{
				p.SetState(1170)
				p.Match(StmtParserVARCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1174)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserBINARY {
			{
				p.SetState(1173)
				p.Match(StmtParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1179)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCHARACTER || _la == StmtParserCHAR || _la == StmtParserCHARSET {
			{
				p.SetState(1176)
				p.CharSet()
			}
			{
				p.SetState(1177)
				p.CharsetName()
			}

		}
		p.SetState(1183)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1181)
				p.Match(StmtParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1182)
				p.CollationName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 12:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		p.SetState(1188)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StmtParserLONG:
			{
				p.SetState(1185)
				p.Match(StmtParserLONG)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1186)
				p.Match(StmtParserVARBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case StmtParserJSON:
			{
				p.SetState(1187)
				p.Match(StmtParserJSON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 13:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1190)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserSET || _la == StmtParserENUM) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1191)
			p.CollectionOptions()
		}
		p.SetState(1193)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserBINARY {
			{
				p.SetState(1192)
				p.Match(StmtParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1198)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCHARACTER || _la == StmtParserCHAR || _la == StmtParserCHARSET {
			{
				p.SetState(1195)
				p.CharSet()
			}
			{
				p.SetState(1196)
				p.CharsetName()
			}

		}

	case 14:
		localctx = NewBinaryDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1200)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*BinaryDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-220)) & ^0x3f) == 0 && ((int64(1)<<(_la-220))&11) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*BinaryDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1202)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1201)
				p.LengthOneDimension()
			}

		}

	case 15:
		localctx = NewBinaryDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1204)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*BinaryDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-222)) & ^0x3f) == 0 && ((int64(1)<<(_la-222))&21) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*BinaryDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 16:
		localctx = NewSpecialDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1205)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SpecialDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserSERIAL || _la == StmtParserBOOL || _la == StmtParserBOOLEAN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SpecialDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 17:
		localctx = NewSpecialDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1206)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SpecialDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserYEAR || _la == StmtParserBIT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SpecialDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1208)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1207)
				p.LengthOneDimension()
			}

		}

	case 18:
		localctx = NewSpatialDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1210)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SpatialDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-783)) & ^0x3f) == 0 && ((int64(1)<<(_la-783))&511) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SpatialDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollectionOptionsContext is an interface to support dynamic dispatch.
type ICollectionOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCollectionOptionsContext differentiates from other interfaces.
	IsCollectionOptionsContext()
}

type CollectionOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectionOptionsContext() *CollectionOptionsContext {
	var p = new(CollectionOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_collectionOptions
	return p
}

func InitEmptyCollectionOptionsContext(p *CollectionOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_collectionOptions
}

func (*CollectionOptionsContext) IsCollectionOptionsContext() {}

func NewCollectionOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectionOptionsContext {
	var p = new(CollectionOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_collectionOptions

	return p
}

func (s *CollectionOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectionOptionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *CollectionOptionsContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(StmtParserSTRING_LITERAL)
}

func (s *CollectionOptionsContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, i)
}

func (s *CollectionOptionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *CollectionOptionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *CollectionOptionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *CollectionOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectionOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCollectionOptions(s)
	}
}

func (s *CollectionOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCollectionOptions(s)
	}
}

func (p *StmtParser) CollectionOptions() (localctx ICollectionOptionsContext) {
	localctx = NewCollectionOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, StmtParserRULE_collectionOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1213)
		p.Match(StmtParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1214)
		p.Match(StmtParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1219)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StmtParserCOMMA {
		{
			p.SetState(1215)
			p.Match(StmtParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1216)
			p.Match(StmtParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1221)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1222)
		p.Match(StmtParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConvertedDataTypeContext is an interface to support dynamic dispatch.
type IConvertedDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTypeName returns the typeName token.
	GetTypeName() antlr.Token

	// SetTypeName sets the typeName token.
	SetTypeName(antlr.Token)

	// Getter signatures
	CHAR() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	UNSIGNED() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	NCHAR() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	TIME() antlr.TerminalNode
	JSON() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	LengthOneDimension() ILengthOneDimensionContext
	CharSet() ICharSetContext
	CharsetName() ICharsetNameContext
	LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext

	// IsConvertedDataTypeContext differentiates from other interfaces.
	IsConvertedDataTypeContext()
}

type ConvertedDataTypeContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	typeName antlr.Token
}

func NewEmptyConvertedDataTypeContext() *ConvertedDataTypeContext {
	var p = new(ConvertedDataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_convertedDataType
	return p
}

func InitEmptyConvertedDataTypeContext(p *ConvertedDataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_convertedDataType
}

func (*ConvertedDataTypeContext) IsConvertedDataTypeContext() {}

func NewConvertedDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConvertedDataTypeContext {
	var p = new(ConvertedDataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_convertedDataType

	return p
}

func (s *ConvertedDataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ConvertedDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *ConvertedDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *ConvertedDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(StmtParserCHAR, 0)
}

func (s *ConvertedDataTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserDECIMAL, 0)
}

func (s *ConvertedDataTypeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(StmtParserSIGNED, 0)
}

func (s *ConvertedDataTypeContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(StmtParserUNSIGNED, 0)
}

func (s *ConvertedDataTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(StmtParserARRAY, 0)
}

func (s *ConvertedDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(StmtParserBINARY, 0)
}

func (s *ConvertedDataTypeContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(StmtParserNCHAR, 0)
}

func (s *ConvertedDataTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(StmtParserDATE, 0)
}

func (s *ConvertedDataTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(StmtParserDATETIME, 0)
}

func (s *ConvertedDataTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(StmtParserTIME, 0)
}

func (s *ConvertedDataTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON, 0)
}

func (s *ConvertedDataTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(StmtParserINT, 0)
}

func (s *ConvertedDataTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(StmtParserINTEGER, 0)
}

func (s *ConvertedDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *ConvertedDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *ConvertedDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *ConvertedDataTypeContext) LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoOptionalDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoOptionalDimensionContext)
}

func (s *ConvertedDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertedDataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConvertedDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterConvertedDataType(s)
	}
}

func (s *ConvertedDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitConvertedDataType(s)
	}
}

func (p *StmtParser) ConvertedDataType() (localctx IConvertedDataTypeContext) {
	localctx = NewConvertedDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, StmtParserRULE_convertedDataType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1246)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StmtParserBINARY, StmtParserNCHAR:
		{
			p.SetState(1224)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConvertedDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserBINARY || _la == StmtParserNCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConvertedDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1226)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1225)
				p.LengthOneDimension()
			}

		}

	case StmtParserCHAR:
		{
			p.SetState(1228)

			var _m = p.Match(StmtParserCHAR)

			localctx.(*ConvertedDataTypeContext).typeName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1229)
				p.LengthOneDimension()
			}

		}
		p.SetState(1235)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCHARACTER || _la == StmtParserCHAR || _la == StmtParserCHARSET {
			{
				p.SetState(1232)
				p.CharSet()
			}
			{
				p.SetState(1233)
				p.CharsetName()
			}

		}

	case StmtParserINT, StmtParserINTEGER, StmtParserDATE, StmtParserTIME, StmtParserDATETIME, StmtParserJSON:
		{
			p.SetState(1237)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConvertedDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&1441857) != 0) || _la == StmtParserJSON) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConvertedDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case StmtParserDECIMAL:
		{
			p.SetState(1238)

			var _m = p.Match(StmtParserDECIMAL)

			localctx.(*ConvertedDataTypeContext).typeName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1240)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1239)
				p.LengthTwoOptionalDimension()
			}

		}

	case StmtParserUNSIGNED, StmtParserSIGNED:
		{
			p.SetState(1242)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserUNSIGNED || _la == StmtParserSIGNED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1244)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserINTEGER {
			{
				p.SetState(1243)
				p.Match(StmtParserINTEGER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserARRAY {
		{
			p.SetState(1248)
			p.Match(StmtParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILengthOneDimensionContext is an interface to support dynamic dispatch.
type ILengthOneDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	RR_BRACKET() antlr.TerminalNode

	// IsLengthOneDimensionContext differentiates from other interfaces.
	IsLengthOneDimensionContext()
}

type LengthOneDimensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthOneDimensionContext() *LengthOneDimensionContext {
	var p = new(LengthOneDimensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_lengthOneDimension
	return p
}

func InitEmptyLengthOneDimensionContext(p *LengthOneDimensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_lengthOneDimension
}

func (*LengthOneDimensionContext) IsLengthOneDimensionContext() {}

func NewLengthOneDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthOneDimensionContext {
	var p = new(LengthOneDimensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_lengthOneDimension

	return p
}

func (s *LengthOneDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthOneDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *LengthOneDimensionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthOneDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *LengthOneDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthOneDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthOneDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterLengthOneDimension(s)
	}
}

func (s *LengthOneDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitLengthOneDimension(s)
	}
}

func (p *StmtParser) LengthOneDimension() (localctx ILengthOneDimensionContext) {
	localctx = NewLengthOneDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, StmtParserRULE_lengthOneDimension)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1251)
		p.Match(StmtParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1252)
		p.DecimalLiteral()
	}
	{
		p.SetState(1253)
		p.Match(StmtParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILengthTwoDimensionContext is an interface to support dynamic dispatch.
type ILengthTwoDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	COMMA() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode

	// IsLengthTwoDimensionContext differentiates from other interfaces.
	IsLengthTwoDimensionContext()
}

type LengthTwoDimensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthTwoDimensionContext() *LengthTwoDimensionContext {
	var p = new(LengthTwoDimensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_lengthTwoDimension
	return p
}

func InitEmptyLengthTwoDimensionContext(p *LengthTwoDimensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_lengthTwoDimension
}

func (*LengthTwoDimensionContext) IsLengthTwoDimensionContext() {}

func NewLengthTwoDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthTwoDimensionContext {
	var p = new(LengthTwoDimensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_lengthTwoDimension

	return p
}

func (s *LengthTwoDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthTwoDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *LengthTwoDimensionContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LengthTwoDimensionContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthTwoDimensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, 0)
}

func (s *LengthTwoDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *LengthTwoDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthTwoDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthTwoDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterLengthTwoDimension(s)
	}
}

func (s *LengthTwoDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitLengthTwoDimension(s)
	}
}

func (p *StmtParser) LengthTwoDimension() (localctx ILengthTwoDimensionContext) {
	localctx = NewLengthTwoDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, StmtParserRULE_lengthTwoDimension)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1255)
		p.Match(StmtParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1256)
		p.DecimalLiteral()
	}
	{
		p.SetState(1257)
		p.Match(StmtParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1258)
		p.DecimalLiteral()
	}
	{
		p.SetState(1259)
		p.Match(StmtParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILengthTwoOptionalDimensionContext is an interface to support dynamic dispatch.
type ILengthTwoOptionalDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	RR_BRACKET() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsLengthTwoOptionalDimensionContext differentiates from other interfaces.
	IsLengthTwoOptionalDimensionContext()
}

type LengthTwoOptionalDimensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthTwoOptionalDimensionContext() *LengthTwoOptionalDimensionContext {
	var p = new(LengthTwoOptionalDimensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_lengthTwoOptionalDimension
	return p
}

func InitEmptyLengthTwoOptionalDimensionContext(p *LengthTwoOptionalDimensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_lengthTwoOptionalDimension
}

func (*LengthTwoOptionalDimensionContext) IsLengthTwoOptionalDimensionContext() {}

func NewLengthTwoOptionalDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthTwoOptionalDimensionContext {
	var p = new(LengthTwoOptionalDimensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_lengthTwoOptionalDimension

	return p
}

func (s *LengthTwoOptionalDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthTwoOptionalDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *LengthTwoOptionalDimensionContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LengthTwoOptionalDimensionContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthTwoOptionalDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *LengthTwoOptionalDimensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, 0)
}

func (s *LengthTwoOptionalDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthTwoOptionalDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthTwoOptionalDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterLengthTwoOptionalDimension(s)
	}
}

func (s *LengthTwoOptionalDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitLengthTwoOptionalDimension(s)
	}
}

func (p *StmtParser) LengthTwoOptionalDimension() (localctx ILengthTwoOptionalDimensionContext) {
	localctx = NewLengthTwoOptionalDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, StmtParserRULE_lengthTwoOptionalDimension)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1261)
		p.Match(StmtParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1262)
		p.DecimalLiteral()
	}
	p.SetState(1265)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserCOMMA {
		{
			p.SetState(1263)
			p.Match(StmtParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1264)
			p.DecimalLiteral()
		}

	}
	{
		p.SetState(1267)
		p.Match(StmtParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUidListContext is an interface to support dynamic dispatch.
type IUidListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUid() []IUidContext
	Uid(i int) IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUidListContext differentiates from other interfaces.
	IsUidListContext()
}

type UidListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUidListContext() *UidListContext {
	var p = new(UidListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_uidList
	return p
}

func InitEmptyUidListContext(p *UidListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_uidList
}

func (*UidListContext) IsUidListContext() {}

func NewUidListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UidListContext {
	var p = new(UidListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_uidList

	return p
}

func (s *UidListContext) GetParser() antlr.Parser { return s.parser }

func (s *UidListContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *UidListContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UidListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *UidListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *UidListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UidListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UidListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterUidList(s)
	}
}

func (s *UidListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitUidList(s)
	}
}

func (p *StmtParser) UidList() (localctx IUidListContext) {
	localctx = NewUidListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, StmtParserRULE_uidList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1269)
		p.Uid()
	}
	p.SetState(1274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StmtParserCOMMA {
		{
			p.SetState(1270)
			p.Match(StmtParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1271)
			p.Uid()
		}

		p.SetState(1276)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablesContext is an interface to support dynamic dispatch.
type ITablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTablesContext differentiates from other interfaces.
	IsTablesContext()
}

type TablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablesContext() *TablesContext {
	var p = new(TablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_tables
	return p
}

func InitEmptyTablesContext(p *TablesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_tables
}

func (*TablesContext) IsTablesContext() {}

func NewTablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablesContext {
	var p = new(TablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_tables

	return p
}

func (s *TablesContext) GetParser() antlr.Parser { return s.parser }

func (s *TablesContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *TablesContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *TablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *TablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTables(s)
	}
}

func (s *TablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTables(s)
	}
}

func (p *StmtParser) Tables() (localctx ITablesContext) {
	localctx = NewTablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, StmtParserRULE_tables)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1277)
		p.TableName()
	}
	p.SetState(1282)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StmtParserCOMMA {
		{
			p.SetState(1278)
			p.Match(StmtParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1279)
			p.TableName()
		}

		p.SetState(1284)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexColumnNamesContext is an interface to support dynamic dispatch.
type IIndexColumnNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllIndexColumnName() []IIndexColumnNameContext
	IndexColumnName(i int) IIndexColumnNameContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIndexColumnNamesContext differentiates from other interfaces.
	IsIndexColumnNamesContext()
}

type IndexColumnNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexColumnNamesContext() *IndexColumnNamesContext {
	var p = new(IndexColumnNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_indexColumnNames
	return p
}

func InitEmptyIndexColumnNamesContext(p *IndexColumnNamesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_indexColumnNames
}

func (*IndexColumnNamesContext) IsIndexColumnNamesContext() {}

func NewIndexColumnNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnNamesContext {
	var p = new(IndexColumnNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_indexColumnNames

	return p
}

func (s *IndexColumnNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnNamesContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *IndexColumnNamesContext) AllIndexColumnName() []IIndexColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IIndexColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexColumnNameContext); ok {
			tst[i] = t.(IIndexColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *IndexColumnNamesContext) IndexColumnName(i int) IIndexColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNameContext)
}

func (s *IndexColumnNamesContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *IndexColumnNamesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *IndexColumnNamesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *IndexColumnNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexColumnNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIndexColumnNames(s)
	}
}

func (s *IndexColumnNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIndexColumnNames(s)
	}
}

func (p *StmtParser) IndexColumnNames() (localctx IIndexColumnNamesContext) {
	localctx = NewIndexColumnNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, StmtParserRULE_indexColumnNames)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1285)
		p.Match(StmtParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1286)
		p.IndexColumnName()
	}
	p.SetState(1291)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StmtParserCOMMA {
		{
			p.SetState(1287)
			p.Match(StmtParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1288)
			p.IndexColumnName()
		}

		p.SetState(1293)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1294)
		p.Match(StmtParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL_LITERAL() antlr.TerminalNode
	CAST() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	Expression() IExpressionContext
	AS() antlr.TerminalNode
	ConvertedDataType() IConvertedDataTypeContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	Constant() IConstantContext
	UnaryOperator() IUnaryOperatorContext
	AllCurrentTimestamp() []ICurrentTimestampContext
	CurrentTimestamp(i int) ICurrentTimestampContext
	ON() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	FullId() IFullIdContext
	LASTVAL() antlr.TerminalNode
	NEXTVAL() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	FOR() antlr.TerminalNode
	PREVIOUS() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	JSON_OBJECT() antlr.TerminalNode

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_defaultValue
	return p
}

func InitEmptyDefaultValueContext(p *DefaultValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_defaultValue
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNULL_LITERAL, 0)
}

func (s *DefaultValueContext) CAST() antlr.TerminalNode {
	return s.GetToken(StmtParserCAST, 0)
}

func (s *DefaultValueContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(StmtParserLR_BRACKET)
}

func (s *DefaultValueContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, i)
}

func (s *DefaultValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefaultValueContext) AS() antlr.TerminalNode {
	return s.GetToken(StmtParserAS, 0)
}

func (s *DefaultValueContext) ConvertedDataType() IConvertedDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConvertedDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConvertedDataTypeContext)
}

func (s *DefaultValueContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(StmtParserRR_BRACKET)
}

func (s *DefaultValueContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, i)
}

func (s *DefaultValueContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *DefaultValueContext) UnaryOperator() IUnaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryOperatorContext)
}

func (s *DefaultValueContext) AllCurrentTimestamp() []ICurrentTimestampContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICurrentTimestampContext); ok {
			len++
		}
	}

	tst := make([]ICurrentTimestampContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICurrentTimestampContext); ok {
			tst[i] = t.(ICurrentTimestampContext)
			i++
		}
	}

	return tst
}

func (s *DefaultValueContext) CurrentTimestamp(i int) ICurrentTimestampContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentTimestampContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentTimestampContext)
}

func (s *DefaultValueContext) ON() antlr.TerminalNode {
	return s.GetToken(StmtParserON, 0)
}

func (s *DefaultValueContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(StmtParserUPDATE, 0)
}

func (s *DefaultValueContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DefaultValueContext) LASTVAL() antlr.TerminalNode {
	return s.GetToken(StmtParserLASTVAL, 0)
}

func (s *DefaultValueContext) NEXTVAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNEXTVAL, 0)
}

func (s *DefaultValueContext) VALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserVALUE, 0)
}

func (s *DefaultValueContext) FOR() antlr.TerminalNode {
	return s.GetToken(StmtParserFOR, 0)
}

func (s *DefaultValueContext) PREVIOUS() antlr.TerminalNode {
	return s.GetToken(StmtParserPREVIOUS, 0)
}

func (s *DefaultValueContext) NEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserNEXT, 0)
}

func (s *DefaultValueContext) JSON_OBJECT() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_OBJECT, 0)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (p *StmtParser) DefaultValue() (localctx IDefaultValueContext) {
	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, StmtParserRULE_defaultValue)
	var _la int

	p.SetState(1336)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 209, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1296)
			p.Match(StmtParserNULL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1297)
			p.Match(StmtParserCAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1298)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1299)
			p.expression(0)
		}
		{
			p.SetState(1300)
			p.Match(StmtParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1301)
			p.ConvertedDataType()
		}
		{
			p.SetState(1302)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1305)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1304)
				p.UnaryOperator()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1307)
			p.Constant()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1308)
			p.CurrentTimestamp()
		}
		p.SetState(1312)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1309)
				p.Match(StmtParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1310)
				p.Match(StmtParserUPDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1311)
				p.CurrentTimestamp()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1314)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1315)
			p.expression(0)
		}
		{
			p.SetState(1316)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1318)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserLASTVAL || _la == StmtParserNEXTVAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1319)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1320)
			p.FullId()
		}
		{
			p.SetState(1321)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1323)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1324)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserNEXT || _la == StmtParserPREVIOUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1325)
			p.Match(StmtParserVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1326)
			p.Match(StmtParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1327)
			p.FullId()
		}
		{
			p.SetState(1328)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1330)
			p.expression(0)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1331)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1332)
			p.Match(StmtParserJSON_OBJECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1333)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1334)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1335)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICurrentTimestampContext is an interface to support dynamic dispatch.
type ICurrentTimestampContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOW() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode
	CURDATE() antlr.TerminalNode
	CURTIME() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext

	// IsCurrentTimestampContext differentiates from other interfaces.
	IsCurrentTimestampContext()
}

type CurrentTimestampContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCurrentTimestampContext() *CurrentTimestampContext {
	var p = new(CurrentTimestampContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_currentTimestamp
	return p
}

func InitEmptyCurrentTimestampContext(p *CurrentTimestampContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_currentTimestamp
}

func (*CurrentTimestampContext) IsCurrentTimestampContext() {}

func NewCurrentTimestampContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CurrentTimestampContext {
	var p = new(CurrentTimestampContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_currentTimestamp

	return p
}

func (s *CurrentTimestampContext) GetParser() antlr.Parser { return s.parser }

func (s *CurrentTimestampContext) NOW() antlr.TerminalNode {
	return s.GetToken(StmtParserNOW, 0)
}

func (s *CurrentTimestampContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *CurrentTimestampContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *CurrentTimestampContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserCURRENT_TIMESTAMP, 0)
}

func (s *CurrentTimestampContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(StmtParserLOCALTIME, 0)
}

func (s *CurrentTimestampContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserLOCALTIMESTAMP, 0)
}

func (s *CurrentTimestampContext) CURDATE() antlr.TerminalNode {
	return s.GetToken(StmtParserCURDATE, 0)
}

func (s *CurrentTimestampContext) CURTIME() antlr.TerminalNode {
	return s.GetToken(StmtParserCURTIME, 0)
}

func (s *CurrentTimestampContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *CurrentTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentTimestampContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CurrentTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCurrentTimestamp(s)
	}
}

func (s *CurrentTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCurrentTimestamp(s)
	}
}

func (p *StmtParser) CurrentTimestamp() (localctx ICurrentTimestampContext) {
	localctx = NewCurrentTimestampContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, StmtParserRULE_currentTimestamp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StmtParserCURRENT_TIMESTAMP, StmtParserLOCALTIME, StmtParserCURDATE, StmtParserCURTIME, StmtParserLOCALTIMESTAMP:
		{
			p.SetState(1338)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-306)) & ^0x3f) == 0 && ((int64(1)<<(_la-306))&143) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1344)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1339)
				p.Match(StmtParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1341)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-1128)) & ^0x3f) == 0 && ((int64(1)<<(_la-1128))&10247) != 0 {
				{
					p.SetState(1340)
					p.DecimalLiteral()
				}

			}
			{
				p.SetState(1343)
				p.Match(StmtParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case StmtParserNOW:
		{
			p.SetState(1346)
			p.Match(StmtParserNOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1347)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1349)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-1128)) & ^0x3f) == 0 && ((int64(1)<<(_la-1128))&10247) != 0 {
			{
				p.SetState(1348)
				p.DecimalLiteral()
			}

		}
		{
			p.SetState(1351)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfNotExistsContext is an interface to support dynamic dispatch.
type IIfNotExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsIfNotExistsContext differentiates from other interfaces.
	IsIfNotExistsContext()
}

type IfNotExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNotExistsContext() *IfNotExistsContext {
	var p = new(IfNotExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_ifNotExists
	return p
}

func InitEmptyIfNotExistsContext(p *IfNotExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_ifNotExists
}

func (*IfNotExistsContext) IsIfNotExistsContext() {}

func NewIfNotExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNotExistsContext {
	var p = new(IfNotExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_ifNotExists

	return p
}

func (s *IfNotExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNotExistsContext) IF() antlr.TerminalNode {
	return s.GetToken(StmtParserIF, 0)
}

func (s *IfNotExistsContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *IfNotExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StmtParserEXISTS, 0)
}

func (s *IfNotExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNotExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfNotExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIfNotExists(s)
	}
}

func (s *IfNotExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIfNotExists(s)
	}
}

func (p *StmtParser) IfNotExists() (localctx IIfNotExistsContext) {
	localctx = NewIfNotExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, StmtParserRULE_ifNotExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1354)
		p.Match(StmtParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1355)
		p.Match(StmtParserNOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1356)
		p.Match(StmtParserEXISTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScalarFunctionNameContext is an interface to support dynamic dispatch.
type IScalarFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionNameBase() IFunctionNameBaseContext
	ASCII() antlr.TerminalNode
	CURDATE() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	CURTIME() antlr.TerminalNode
	DATE_ADD() antlr.TerminalNode
	DATE_SUB() antlr.TerminalNode
	IF() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode
	MID() antlr.TerminalNode
	NOW() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	SUBSTR() antlr.TerminalNode
	SUBSTRING() antlr.TerminalNode
	SYSDATE() antlr.TerminalNode
	TRIM() antlr.TerminalNode
	UTC_DATE() antlr.TerminalNode
	UTC_TIME() antlr.TerminalNode
	UTC_TIMESTAMP() antlr.TerminalNode

	// IsScalarFunctionNameContext differentiates from other interfaces.
	IsScalarFunctionNameContext()
}

type ScalarFunctionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalarFunctionNameContext() *ScalarFunctionNameContext {
	var p = new(ScalarFunctionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_scalarFunctionName
	return p
}

func InitEmptyScalarFunctionNameContext(p *ScalarFunctionNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_scalarFunctionName
}

func (*ScalarFunctionNameContext) IsScalarFunctionNameContext() {}

func NewScalarFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalarFunctionNameContext {
	var p = new(ScalarFunctionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_scalarFunctionName

	return p
}

func (s *ScalarFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalarFunctionNameContext) FunctionNameBase() IFunctionNameBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameBaseContext)
}

func (s *ScalarFunctionNameContext) ASCII() antlr.TerminalNode {
	return s.GetToken(StmtParserASCII, 0)
}

func (s *ScalarFunctionNameContext) CURDATE() antlr.TerminalNode {
	return s.GetToken(StmtParserCURDATE, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(StmtParserCURRENT_DATE, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(StmtParserCURRENT_TIME, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserCURRENT_TIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) CURTIME() antlr.TerminalNode {
	return s.GetToken(StmtParserCURTIME, 0)
}

func (s *ScalarFunctionNameContext) DATE_ADD() antlr.TerminalNode {
	return s.GetToken(StmtParserDATE_ADD, 0)
}

func (s *ScalarFunctionNameContext) DATE_SUB() antlr.TerminalNode {
	return s.GetToken(StmtParserDATE_SUB, 0)
}

func (s *ScalarFunctionNameContext) IF() antlr.TerminalNode {
	return s.GetToken(StmtParserIF, 0)
}

func (s *ScalarFunctionNameContext) INSERT() antlr.TerminalNode {
	return s.GetToken(StmtParserINSERT, 0)
}

func (s *ScalarFunctionNameContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(StmtParserLOCALTIME, 0)
}

func (s *ScalarFunctionNameContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserLOCALTIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) MID() antlr.TerminalNode {
	return s.GetToken(StmtParserMID, 0)
}

func (s *ScalarFunctionNameContext) NOW() antlr.TerminalNode {
	return s.GetToken(StmtParserNOW, 0)
}

func (s *ScalarFunctionNameContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLACE, 0)
}

func (s *ScalarFunctionNameContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBSTR, 0)
}

func (s *ScalarFunctionNameContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBSTRING, 0)
}

func (s *ScalarFunctionNameContext) SYSDATE() antlr.TerminalNode {
	return s.GetToken(StmtParserSYSDATE, 0)
}

func (s *ScalarFunctionNameContext) TRIM() antlr.TerminalNode {
	return s.GetToken(StmtParserTRIM, 0)
}

func (s *ScalarFunctionNameContext) UTC_DATE() antlr.TerminalNode {
	return s.GetToken(StmtParserUTC_DATE, 0)
}

func (s *ScalarFunctionNameContext) UTC_TIME() antlr.TerminalNode {
	return s.GetToken(StmtParserUTC_TIME, 0)
}

func (s *ScalarFunctionNameContext) UTC_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserUTC_TIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalarFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterScalarFunctionName(s)
	}
}

func (s *ScalarFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitScalarFunctionName(s)
	}
}

func (p *StmtParser) ScalarFunctionName() (localctx IScalarFunctionNameContext) {
	localctx = NewScalarFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, StmtParserRULE_scalarFunctionName)
	p.SetState(1381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StmtParserDATABASE, StmtParserLEFT, StmtParserRIGHT, StmtParserSCHEMA, StmtParserDATE, StmtParserTIME, StmtParserTIMESTAMP, StmtParserYEAR, StmtParserJSON_ARRAY, StmtParserJSON_OBJECT, StmtParserJSON_QUOTE, StmtParserJSON_CONTAINS, StmtParserJSON_CONTAINS_PATH, StmtParserJSON_EXTRACT, StmtParserJSON_KEYS, StmtParserJSON_OVERLAPS, StmtParserJSON_SEARCH, StmtParserJSON_VALUE, StmtParserJSON_ARRAY_APPEND, StmtParserJSON_ARRAY_INSERT, StmtParserJSON_INSERT, StmtParserJSON_MERGE, StmtParserJSON_MERGE_PATCH, StmtParserJSON_MERGE_PRESERVE, StmtParserJSON_REMOVE, StmtParserJSON_REPLACE, StmtParserJSON_SET, StmtParserJSON_UNQUOTE, StmtParserJSON_DEPTH, StmtParserJSON_LENGTH, StmtParserJSON_TYPE, StmtParserJSON_VALID, StmtParserJSON_TABLE, StmtParserJSON_SCHEMA_VALID, StmtParserJSON_SCHEMA_VALIDATION_REPORT, StmtParserJSON_PRETTY, StmtParserJSON_STORAGE_FREE, StmtParserJSON_STORAGE_SIZE, StmtParserJSON_ARRAYAGG, StmtParserJSON_OBJECTAGG, StmtParserCOUNT, StmtParserCUME_DIST, StmtParserDENSE_RANK, StmtParserFIRST_VALUE, StmtParserLAG, StmtParserLAST_VALUE, StmtParserLEAD, StmtParserNTILE, StmtParserNTH_VALUE, StmtParserPERCENT_RANK, StmtParserRANK, StmtParserROW_NUMBER, StmtParserPOSITION, StmtParserINVISIBLE, StmtParserVISIBLE, StmtParserQUARTER, StmtParserMONTH, StmtParserDAY, StmtParserHOUR, StmtParserMINUTE, StmtParserWEEK, StmtParserSECOND, StmtParserMICROSECOND, StmtParserSESSION_VARIABLES_ADMIN, StmtParserGEOMETRYCOLLECTION, StmtParserLINESTRING, StmtParserMULTILINESTRING, StmtParserMULTIPOINT, StmtParserMULTIPOLYGON, StmtParserPOINT, StmtParserPOLYGON, StmtParserABS, StmtParserACOS, StmtParserADDDATE, StmtParserADDTIME, StmtParserAES_DECRYPT, StmtParserAES_ENCRYPT, StmtParserAREA, StmtParserASBINARY, StmtParserASIN, StmtParserASTEXT, StmtParserASWKB, StmtParserASWKT, StmtParserASYMMETRIC_DECRYPT, StmtParserASYMMETRIC_DERIVE, StmtParserASYMMETRIC_ENCRYPT, StmtParserASYMMETRIC_SIGN, StmtParserASYMMETRIC_VERIFY, StmtParserATAN, StmtParserATAN2, StmtParserBENCHMARK, StmtParserBIN, StmtParserBIT_COUNT, StmtParserBIT_LENGTH, StmtParserBUFFER, StmtParserCEIL, StmtParserCEILING, StmtParserCENTROID, StmtParserCHARACTER_LENGTH, StmtParserCHARSET, StmtParserCHAR_LENGTH, StmtParserCOERCIBILITY, StmtParserCOLLATION, StmtParserCOMPRESS, StmtParserCONCAT, StmtParserCONCAT_WS, StmtParserCONNECTION_ID, StmtParserCONV, StmtParserCONVERT_TZ, StmtParserCOS, StmtParserCOT, StmtParserCRC32, StmtParserCREATE_ASYMMETRIC_PRIV_KEY, StmtParserCREATE_ASYMMETRIC_PUB_KEY, StmtParserCREATE_DH_PARAMETERS, StmtParserCREATE_DIGEST, StmtParserCROSSES, StmtParserDATEDIFF, StmtParserDATE_FORMAT, StmtParserDAYNAME, StmtParserDAYOFMONTH, StmtParserDAYOFWEEK, StmtParserDAYOFYEAR, StmtParserDECODE, StmtParserDEGREES, StmtParserDES_DECRYPT, StmtParserDES_ENCRYPT, StmtParserDIMENSION, StmtParserDISJOINT, StmtParserELT, StmtParserENCODE, StmtParserENCRYPT, StmtParserENDPOINT, StmtParserENVELOPE, StmtParserEQUALS, StmtParserEXP, StmtParserEXPORT_SET, StmtParserEXTERIORRING, StmtParserEXTRACTVALUE, StmtParserFIELD, StmtParserFIND_IN_SET, StmtParserFLOOR, StmtParserFORMAT, StmtParserFOUND_ROWS, StmtParserFROM_BASE64, StmtParserFROM_DAYS, StmtParserFROM_UNIXTIME, StmtParserGEOMCOLLFROMTEXT, StmtParserGEOMCOLLFROMWKB, StmtParserGEOMETRYCOLLECTIONFROMTEXT, StmtParserGEOMETRYCOLLECTIONFROMWKB, StmtParserGEOMETRYFROMTEXT, StmtParserGEOMETRYFROMWKB, StmtParserGEOMETRYN, StmtParserGEOMETRYTYPE, StmtParserGEOMFROMTEXT, StmtParserGEOMFROMWKB, StmtParserGET_FORMAT, StmtParserGET_LOCK, StmtParserGLENGTH, StmtParserGREATEST, StmtParserGTID_SUBSET, StmtParserGTID_SUBTRACT, StmtParserHEX, StmtParserIFNULL, StmtParserINET6_ATON, StmtParserINET6_NTOA, StmtParserINET_ATON, StmtParserINET_NTOA, StmtParserINSTR, StmtParserINTERIORRINGN, StmtParserINTERSECTS, StmtParserISCLOSED, StmtParserISEMPTY, StmtParserISNULL, StmtParserISSIMPLE, StmtParserIS_FREE_LOCK, StmtParserIS_IPV4, StmtParserIS_IPV4_COMPAT, StmtParserIS_IPV4_MAPPED, StmtParserIS_IPV6, StmtParserIS_USED_LOCK, StmtParserLAST_INSERT_ID, StmtParserLCASE, StmtParserLEAST, StmtParserLENGTH, StmtParserLINEFROMTEXT, StmtParserLINEFROMWKB, StmtParserLINESTRINGFROMTEXT, StmtParserLINESTRINGFROMWKB, StmtParserLN, StmtParserLOAD_FILE, StmtParserLOCATE, StmtParserLOG, StmtParserLOG10, StmtParserLOG2, StmtParserLOWER, StmtParserLPAD, StmtParserLTRIM, StmtParserMAKEDATE, StmtParserMAKETIME, StmtParserMAKE_SET, StmtParserMASTER_POS_WAIT, StmtParserMBRCONTAINS, StmtParserMBRDISJOINT, StmtParserMBREQUAL, StmtParserMBRINTERSECTS, StmtParserMBROVERLAPS, StmtParserMBRTOUCHES, StmtParserMBRWITHIN, StmtParserMD5, StmtParserMLINEFROMTEXT, StmtParserMLINEFROMWKB, StmtParserMONTHNAME, StmtParserMPOINTFROMTEXT, StmtParserMPOINTFROMWKB, StmtParserMPOLYFROMTEXT, StmtParserMPOLYFROMWKB, StmtParserMULTILINESTRINGFROMTEXT, StmtParserMULTILINESTRINGFROMWKB, StmtParserMULTIPOINTFROMTEXT, StmtParserMULTIPOINTFROMWKB, StmtParserMULTIPOLYGONFROMTEXT, StmtParserMULTIPOLYGONFROMWKB, StmtParserNAME_CONST, StmtParserNULLIF, StmtParserNUMGEOMETRIES, StmtParserNUMINTERIORRINGS, StmtParserNUMPOINTS, StmtParserOCT, StmtParserOCTET_LENGTH, StmtParserORD, StmtParserOVERLAPS, StmtParserPERIOD_ADD, StmtParserPERIOD_DIFF, StmtParserPI, StmtParserPOINTFROMTEXT, StmtParserPOINTFROMWKB, StmtParserPOINTN, StmtParserPOLYFROMTEXT, StmtParserPOLYFROMWKB, StmtParserPOLYGONFROMTEXT, StmtParserPOLYGONFROMWKB, StmtParserPOW, StmtParserPOWER, StmtParserQUOTE, StmtParserRADIANS, StmtParserRAND, StmtParserRANDOM_BYTES, StmtParserRELEASE_LOCK, StmtParserREVERSE, StmtParserROUND, StmtParserROW_COUNT, StmtParserRPAD, StmtParserRTRIM, StmtParserSEC_TO_TIME, StmtParserSESSION_USER, StmtParserSHA, StmtParserSHA1, StmtParserSHA2, StmtParserSIGN, StmtParserSIN, StmtParserSLEEP, StmtParserSOUNDEX, StmtParserSQL_THREAD_WAIT_AFTER_GTIDS, StmtParserSQRT, StmtParserSRID, StmtParserSTARTPOINT, StmtParserSTRCMP, StmtParserSTR_TO_DATE, StmtParserST_AREA, StmtParserST_ASBINARY, StmtParserST_ASTEXT, StmtParserST_ASWKB, StmtParserST_ASWKT, StmtParserST_BUFFER, StmtParserST_CENTROID, StmtParserST_CONTAINS, StmtParserST_CROSSES, StmtParserST_DIFFERENCE, StmtParserST_DIMENSION, StmtParserST_DISJOINT, StmtParserST_DISTANCE, StmtParserST_ENDPOINT, StmtParserST_ENVELOPE, StmtParserST_EQUALS, StmtParserST_EXTERIORRING, StmtParserST_GEOMCOLLFROMTEXT, StmtParserST_GEOMCOLLFROMTXT, StmtParserST_GEOMCOLLFROMWKB, StmtParserST_GEOMETRYCOLLECTIONFROMTEXT, StmtParserST_GEOMETRYCOLLECTIONFROMWKB, StmtParserST_GEOMETRYFROMTEXT, StmtParserST_GEOMETRYFROMWKB, StmtParserST_GEOMETRYN, StmtParserST_GEOMETRYTYPE, StmtParserST_GEOMFROMTEXT, StmtParserST_GEOMFROMWKB, StmtParserST_INTERIORRINGN, StmtParserST_INTERSECTION, StmtParserST_INTERSECTS, StmtParserST_ISCLOSED, StmtParserST_ISEMPTY, StmtParserST_ISSIMPLE, StmtParserST_LINEFROMTEXT, StmtParserST_LINEFROMWKB, StmtParserST_LINESTRINGFROMTEXT, StmtParserST_LINESTRINGFROMWKB, StmtParserST_NUMGEOMETRIES, StmtParserST_NUMINTERIORRING, StmtParserST_NUMINTERIORRINGS, StmtParserST_NUMPOINTS, StmtParserST_OVERLAPS, StmtParserST_POINTFROMTEXT, StmtParserST_POINTFROMWKB, StmtParserST_POINTN, StmtParserST_POLYFROMTEXT, StmtParserST_POLYFROMWKB, StmtParserST_POLYGONFROMTEXT, StmtParserST_POLYGONFROMWKB, StmtParserST_SRID, StmtParserST_STARTPOINT, StmtParserST_SYMDIFFERENCE, StmtParserST_TOUCHES, StmtParserST_UNION, StmtParserST_WITHIN, StmtParserST_X, StmtParserST_Y, StmtParserSUBDATE, StmtParserSUBSTRING_INDEX, StmtParserSUBTIME, StmtParserSYSTEM_USER, StmtParserTAN, StmtParserTIMEDIFF, StmtParserTIMESTAMPADD, StmtParserTIMESTAMPDIFF, StmtParserTIME_FORMAT, StmtParserTIME_TO_SEC, StmtParserTOUCHES, StmtParserTO_BASE64, StmtParserTO_DAYS, StmtParserTO_SECONDS, StmtParserUCASE, StmtParserUNCOMPRESS, StmtParserUNCOMPRESSED_LENGTH, StmtParserUNHEX, StmtParserUNIX_TIMESTAMP, StmtParserUPDATEXML, StmtParserUPPER, StmtParserUUID, StmtParserUUID_SHORT, StmtParserVALIDATE_PASSWORD_STRENGTH, StmtParserVERSION, StmtParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, StmtParserWEEKDAY, StmtParserWEEKOFYEAR, StmtParserWEIGHT_STRING, StmtParserWITHIN, StmtParserYEARWEEK, StmtParserY_FUNCTION, StmtParserX_FUNCTION, StmtParserLASTVAL, StmtParserNEXTVAL, StmtParserSETVAL, StmtParserMOD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1358)
			p.FunctionNameBase()
		}

	case StmtParserASCII:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1359)
			p.Match(StmtParserASCII)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserCURDATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1360)
			p.Match(StmtParserCURDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserCURRENT_DATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1361)
			p.Match(StmtParserCURRENT_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserCURRENT_TIME:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1362)
			p.Match(StmtParserCURRENT_TIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserCURRENT_TIMESTAMP:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1363)
			p.Match(StmtParserCURRENT_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserCURTIME:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1364)
			p.Match(StmtParserCURTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserDATE_ADD:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1365)
			p.Match(StmtParserDATE_ADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserDATE_SUB:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1366)
			p.Match(StmtParserDATE_SUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserIF:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1367)
			p.Match(StmtParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserINSERT:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1368)
			p.Match(StmtParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserLOCALTIME:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1369)
			p.Match(StmtParserLOCALTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserLOCALTIMESTAMP:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1370)
			p.Match(StmtParserLOCALTIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserMID:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1371)
			p.Match(StmtParserMID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserNOW:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1372)
			p.Match(StmtParserNOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserREPLACE:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1373)
			p.Match(StmtParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserSUBSTR:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1374)
			p.Match(StmtParserSUBSTR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserSUBSTRING:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1375)
			p.Match(StmtParserSUBSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserSYSDATE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1376)
			p.Match(StmtParserSYSDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserTRIM:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1377)
			p.Match(StmtParserTRIM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserUTC_DATE:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1378)
			p.Match(StmtParserUTC_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserUTC_TIME:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1379)
			p.Match(StmtParserUTC_TIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserUTC_TIMESTAMP:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1380)
			p.Match(StmtParserUTC_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyAll(ctx *ExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IsExpressionContext struct {
	ExpressionContext
	testValue antlr.Token
}

func NewIsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsExpressionContext {
	var p = new(IsExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *IsExpressionContext) GetTestValue() antlr.Token { return s.testValue }

func (s *IsExpressionContext) SetTestValue(v antlr.Token) { s.testValue = v }

func (s *IsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsExpressionContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *IsExpressionContext) IS() antlr.TerminalNode {
	return s.GetToken(StmtParserIS, 0)
}

func (s *IsExpressionContext) TRUE() antlr.TerminalNode {
	return s.GetToken(StmtParserTRUE, 0)
}

func (s *IsExpressionContext) FALSE() antlr.TerminalNode {
	return s.GetToken(StmtParserFALSE, 0)
}

func (s *IsExpressionContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(StmtParserUNKNOWN, 0)
}

func (s *IsExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *IsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIsExpression(s)
	}
}

func (s *IsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIsExpression(s)
	}
}

type NotExpressionContext struct {
	ExpressionContext
	notOperator antlr.Token
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext {
	var p = new(NotExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *NotExpressionContext) GetNotOperator() antlr.Token { return s.notOperator }

func (s *NotExpressionContext) SetNotOperator(v antlr.Token) { s.notOperator = v }

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NotExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *NotExpressionContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEXCLAMATION_SYMBOL, 0)
}

func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

type LogicalExpressionContext struct {
	ExpressionContext
}

func NewLogicalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalExpressionContext) LogicalOperator() ILogicalOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOperatorContext)
}

func (s *LogicalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterLogicalExpression(s)
	}
}

func (s *LogicalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitLogicalExpression(s)
	}
}

type PredicateExpressionContext struct {
	ExpressionContext
}

func NewPredicateExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExpressionContext {
	var p = new(PredicateExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *PredicateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateExpressionContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicateExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPredicateExpression(s)
	}
}

func (s *PredicateExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPredicateExpression(s)
	}
}

func (p *StmtParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *StmtParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 114
	p.EnterRecursionRule(localctx, 114, StmtParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1394)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 216, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1384)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NotExpressionContext).notOperator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserNOT || _la == StmtParserEXCLAMATION_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NotExpressionContext).notOperator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1385)
			p.expression(4)
		}

	case 2:
		localctx = NewIsExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1386)
			p.predicate(0)
		}
		{
			p.SetState(1387)
			p.Match(StmtParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1389)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserNOT {
			{
				p.SetState(1388)
				p.Match(StmtParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1391)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IsExpressionContext).testValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserFALSE || _la == StmtParserTRUE || _la == StmtParserUNKNOWN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IsExpressionContext).testValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		localctx = NewPredicateExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1393)
			p.predicate(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 217, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_expression)
			p.SetState(1396)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				goto errorExit
			}
			{
				p.SetState(1397)
				p.LogicalOperator()
			}
			{
				p.SetState(1398)
				p.expression(4)
			}

		}
		p.SetState(1404)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 217, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) CopyAll(ctx *PredicateContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SoundsLikePredicateContext struct {
	PredicateContext
}

func NewSoundsLikePredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SoundsLikePredicateContext {
	var p = new(SoundsLikePredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *SoundsLikePredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoundsLikePredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *SoundsLikePredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *SoundsLikePredicateContext) SOUNDS() antlr.TerminalNode {
	return s.GetToken(StmtParserSOUNDS, 0)
}

func (s *SoundsLikePredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StmtParserLIKE, 0)
}

func (s *SoundsLikePredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSoundsLikePredicate(s)
	}
}

func (s *SoundsLikePredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSoundsLikePredicate(s)
	}
}

type ExpressionAtomPredicateContext struct {
	PredicateContext
}

func NewExpressionAtomPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpressionAtomPredicateContext {
	var p = new(ExpressionAtomPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *ExpressionAtomPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionAtomPredicateContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *ExpressionAtomPredicateContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserLOCAL_ID, 0)
}

func (s *ExpressionAtomPredicateContext) VAR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(StmtParserVAR_ASSIGN, 0)
}

func (s *ExpressionAtomPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterExpressionAtomPredicate(s)
	}
}

func (s *ExpressionAtomPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitExpressionAtomPredicate(s)
	}
}

type JsonMemberOfPredicateContext struct {
	PredicateContext
}

func NewJsonMemberOfPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonMemberOfPredicateContext {
	var p = new(JsonMemberOfPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *JsonMemberOfPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonMemberOfPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *JsonMemberOfPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *JsonMemberOfPredicateContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(StmtParserMEMBER, 0)
}

func (s *JsonMemberOfPredicateContext) OF() antlr.TerminalNode {
	return s.GetToken(StmtParserOF, 0)
}

func (s *JsonMemberOfPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *JsonMemberOfPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *JsonMemberOfPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterJsonMemberOfPredicate(s)
	}
}

func (s *JsonMemberOfPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitJsonMemberOfPredicate(s)
	}
}

type BinaryComparisonPredicateContext struct {
	PredicateContext
	left  IPredicateContext
	right IPredicateContext
}

func NewBinaryComparisonPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryComparisonPredicateContext {
	var p = new(BinaryComparisonPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *BinaryComparisonPredicateContext) GetLeft() IPredicateContext { return s.left }

func (s *BinaryComparisonPredicateContext) GetRight() IPredicateContext { return s.right }

func (s *BinaryComparisonPredicateContext) SetLeft(v IPredicateContext) { s.left = v }

func (s *BinaryComparisonPredicateContext) SetRight(v IPredicateContext) { s.right = v }

func (s *BinaryComparisonPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryComparisonPredicateContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *BinaryComparisonPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *BinaryComparisonPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BinaryComparisonPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterBinaryComparisonPredicate(s)
	}
}

func (s *BinaryComparisonPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitBinaryComparisonPredicate(s)
	}
}

type BetweenPredicateContext struct {
	PredicateContext
}

func NewBetweenPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenPredicateContext {
	var p = new(BetweenPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *BetweenPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *BetweenPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BetweenPredicateContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(StmtParserBETWEEN, 0)
}

func (s *BetweenPredicateContext) AND() antlr.TerminalNode {
	return s.GetToken(StmtParserAND, 0)
}

func (s *BetweenPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *BetweenPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterBetweenPredicate(s)
	}
}

func (s *BetweenPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitBetweenPredicate(s)
	}
}

type IsNullPredicateContext struct {
	PredicateContext
}

func NewIsNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsNullPredicateContext {
	var p = new(IsNullPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *IsNullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsNullPredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *IsNullPredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(StmtParserIS, 0)
}

func (s *IsNullPredicateContext) NullNotnull() INullNotnullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullNotnullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullNotnullContext)
}

func (s *IsNullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIsNullPredicate(s)
	}
}

func (s *IsNullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIsNullPredicate(s)
	}
}

type LikePredicateContext struct {
	PredicateContext
}

func NewLikePredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikePredicateContext {
	var p = new(LikePredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *LikePredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikePredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *LikePredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *LikePredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StmtParserLIKE, 0)
}

func (s *LikePredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *LikePredicateContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(StmtParserESCAPE, 0)
}

func (s *LikePredicateContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *LikePredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterLikePredicate(s)
	}
}

func (s *LikePredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitLikePredicate(s)
	}
}

type RegexpPredicateContext struct {
	PredicateContext
	regex antlr.Token
}

func NewRegexpPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegexpPredicateContext {
	var p = new(RegexpPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *RegexpPredicateContext) GetRegex() antlr.Token { return s.regex }

func (s *RegexpPredicateContext) SetRegex(v antlr.Token) { s.regex = v }

func (s *RegexpPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegexpPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *RegexpPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *RegexpPredicateContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(StmtParserREGEXP, 0)
}

func (s *RegexpPredicateContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(StmtParserRLIKE, 0)
}

func (s *RegexpPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *RegexpPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterRegexpPredicate(s)
	}
}

func (s *RegexpPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitRegexpPredicate(s)
	}
}

func (p *StmtParser) Predicate() (localctx IPredicateContext) {
	return p.predicate(0)
}

func (p *StmtParser) predicate(_p int) (localctx IPredicateContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPredicateContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 116
	p.EnterRecursionRule(localctx, 116, StmtParserRULE_predicate, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewExpressionAtomPredicateContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	p.SetState(1408)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 218, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1406)
			p.Match(StmtParserLOCAL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1407)
			p.Match(StmtParserVAR_ASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1410)
		p.expressionAtom(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1457)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1455)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 223, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBinaryComparisonPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				localctx.(*BinaryComparisonPredicateContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_predicate)
				p.SetState(1412)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(1413)
					p.ComparisonOperator()
				}
				{
					p.SetState(1414)

					var _x = p.predicate(8)

					localctx.(*BinaryComparisonPredicateContext).right = _x
				}

			case 2:
				localctx = NewBetweenPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_predicate)
				p.SetState(1416)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				p.SetState(1418)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == StmtParserNOT {
					{
						p.SetState(1417)
						p.Match(StmtParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(1420)
					p.Match(StmtParserBETWEEN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1421)
					p.predicate(0)
				}
				{
					p.SetState(1422)
					p.Match(StmtParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1423)
					p.predicate(7)
				}

			case 3:
				localctx = NewSoundsLikePredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_predicate)
				p.SetState(1425)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(1426)
					p.Match(StmtParserSOUNDS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1427)
					p.Match(StmtParserLIKE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1428)
					p.predicate(6)
				}

			case 4:
				localctx = NewRegexpPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_predicate)
				p.SetState(1429)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				p.SetState(1431)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == StmtParserNOT {
					{
						p.SetState(1430)
						p.Match(StmtParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(1433)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*RegexpPredicateContext).regex = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == StmtParserREGEXP || _la == StmtParserRLIKE) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*RegexpPredicateContext).regex = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1434)
					p.predicate(4)
				}

			case 5:
				localctx = NewIsNullPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_predicate)
				p.SetState(1435)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(1436)
					p.Match(StmtParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1437)
					p.NullNotnull()
				}

			case 6:
				localctx = NewLikePredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_predicate)
				p.SetState(1438)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				p.SetState(1440)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == StmtParserNOT {
					{
						p.SetState(1439)
						p.Match(StmtParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(1442)
					p.Match(StmtParserLIKE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1443)
					p.predicate(0)
				}
				p.SetState(1446)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 222, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1444)
						p.Match(StmtParserESCAPE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1445)
						p.Match(StmtParserSTRING_LITERAL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case 7:
				localctx = NewJsonMemberOfPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_predicate)
				p.SetState(1448)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(1449)
					p.Match(StmtParserMEMBER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1450)
					p.Match(StmtParserOF)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1451)
					p.Match(StmtParserLR_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1452)
					p.predicate(0)
				}
				{
					p.SetState(1453)
					p.Match(StmtParserRR_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1459)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionAtomContext is an interface to support dynamic dispatch.
type IExpressionAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionAtomContext differentiates from other interfaces.
	IsExpressionAtomContext()
}

type ExpressionAtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionAtomContext() *ExpressionAtomContext {
	var p = new(ExpressionAtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_expressionAtom
	return p
}

func InitEmptyExpressionAtomContext(p *ExpressionAtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_expressionAtom
}

func (*ExpressionAtomContext) IsExpressionAtomContext() {}

func NewExpressionAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionAtomContext {
	var p = new(ExpressionAtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_expressionAtom

	return p
}

func (s *ExpressionAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionAtomContext) CopyAll(ctx *ExpressionAtomContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type JsonExpressionAtomContext struct {
	ExpressionAtomContext
	left  IExpressionAtomContext
	right IExpressionAtomContext
}

func NewJsonExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonExpressionAtomContext {
	var p = new(JsonExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *JsonExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *JsonExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }

func (s *JsonExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *JsonExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *JsonExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonExpressionAtomContext) JsonOperator() IJsonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOperatorContext)
}

func (s *JsonExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			len++
		}
	}

	tst := make([]IExpressionAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionAtomContext); ok {
			tst[i] = t.(IExpressionAtomContext)
			i++
		}
	}

	return tst
}

func (s *JsonExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *JsonExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterJsonExpressionAtom(s)
	}
}

func (s *JsonExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitJsonExpressionAtom(s)
	}
}

type UnaryExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewUnaryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryExpressionAtomContext {
	var p = new(UnaryExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *UnaryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionAtomContext) UnaryOperator() IUnaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryOperatorContext)
}

func (s *UnaryExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *UnaryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterUnaryExpressionAtom(s)
	}
}

func (s *UnaryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitUnaryExpressionAtom(s)
	}
}

type CollateExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewCollateExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateExpressionAtomContext {
	var p = new(CollateExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *CollateExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *CollateExpressionAtomContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLLATE, 0)
}

func (s *CollateExpressionAtomContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *CollateExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCollateExpressionAtom(s)
	}
}

func (s *CollateExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCollateExpressionAtom(s)
	}
}

type ConstantExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewConstantExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstantExpressionAtomContext {
	var p = new(ConstantExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *ConstantExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantExpressionAtomContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterConstantExpressionAtom(s)
	}
}

func (s *ConstantExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitConstantExpressionAtom(s)
	}
}

type MysqlVariableExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewMysqlVariableExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MysqlVariableExpressionAtomContext {
	var p = new(MysqlVariableExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *MysqlVariableExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlVariableExpressionAtomContext) MysqlVariable() IMysqlVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMysqlVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMysqlVariableContext)
}

func (s *MysqlVariableExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterMysqlVariableExpressionAtom(s)
	}
}

func (s *MysqlVariableExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitMysqlVariableExpressionAtom(s)
	}
}

type BinaryExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewBinaryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryExpressionAtomContext {
	var p = new(BinaryExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *BinaryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryExpressionAtomContext) BINARY() antlr.TerminalNode {
	return s.GetToken(StmtParserBINARY, 0)
}

func (s *BinaryExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *BinaryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterBinaryExpressionAtom(s)
	}
}

func (s *BinaryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitBinaryExpressionAtom(s)
	}
}

type FullColumnNameExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewFullColumnNameExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FullColumnNameExpressionAtomContext {
	var p = new(FullColumnNameExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *FullColumnNameExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameExpressionAtomContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FullColumnNameExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterFullColumnNameExpressionAtom(s)
	}
}

func (s *FullColumnNameExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitFullColumnNameExpressionAtom(s)
	}
}

type BitExpressionAtomContext struct {
	ExpressionAtomContext
	left  IExpressionAtomContext
	right IExpressionAtomContext
}

func NewBitExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitExpressionAtomContext {
	var p = new(BitExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *BitExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *BitExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }

func (s *BitExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *BitExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *BitExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitExpressionAtomContext) BitOperator() IBitOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitOperatorContext)
}

func (s *BitExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			len++
		}
	}

	tst := make([]IExpressionAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionAtomContext); ok {
			tst[i] = t.(IExpressionAtomContext)
			i++
		}
	}

	return tst
}

func (s *BitExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *BitExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterBitExpressionAtom(s)
	}
}

func (s *BitExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitBitExpressionAtom(s)
	}
}

type NestedExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewNestedExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NestedExpressionAtomContext {
	var p = new(NestedExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *NestedExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *NestedExpressionAtomContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NestedExpressionAtomContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NestedExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *NestedExpressionAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *NestedExpressionAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *NestedExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterNestedExpressionAtom(s)
	}
}

func (s *NestedExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitNestedExpressionAtom(s)
	}
}

type NestedRowExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewNestedRowExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NestedRowExpressionAtomContext {
	var p = new(NestedRowExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *NestedRowExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedRowExpressionAtomContext) ROW() antlr.TerminalNode {
	return s.GetToken(StmtParserROW, 0)
}

func (s *NestedRowExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *NestedRowExpressionAtomContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NestedRowExpressionAtomContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NestedRowExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *NestedRowExpressionAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *NestedRowExpressionAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *NestedRowExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterNestedRowExpressionAtom(s)
	}
}

func (s *NestedRowExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitNestedRowExpressionAtom(s)
	}
}

type MathExpressionAtomContext struct {
	ExpressionAtomContext
	left  IExpressionAtomContext
	right IExpressionAtomContext
}

func NewMathExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MathExpressionAtomContext {
	var p = new(MathExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *MathExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *MathExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }

func (s *MathExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *MathExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *MathExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MathExpressionAtomContext) MathOperator() IMathOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMathOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMathOperatorContext)
}

func (s *MathExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			len++
		}
	}

	tst := make([]IExpressionAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionAtomContext); ok {
			tst[i] = t.(IExpressionAtomContext)
			i++
		}
	}

	return tst
}

func (s *MathExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *MathExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterMathExpressionAtom(s)
	}
}

func (s *MathExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitMathExpressionAtom(s)
	}
}

type IntervalExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewIntervalExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalExpressionAtomContext {
	var p = new(IntervalExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *IntervalExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalExpressionAtomContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(StmtParserINTERVAL, 0)
}

func (s *IntervalExpressionAtomContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalExpressionAtomContext) IntervalType() IIntervalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *IntervalExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIntervalExpressionAtom(s)
	}
}

func (s *IntervalExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIntervalExpressionAtom(s)
	}
}

func (p *StmtParser) ExpressionAtom() (localctx IExpressionAtomContext) {
	return p.expressionAtom(0)
}

func (p *StmtParser) expressionAtom(_p int) (localctx IExpressionAtomContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionAtomContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionAtomContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 118
	p.EnterRecursionRule(localctx, 118, StmtParserRULE_expressionAtom, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 227, p.GetParserRuleContext()) {
	case 1:
		localctx = NewConstantExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1461)
			p.Constant()
		}

	case 2:
		localctx = NewFullColumnNameExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1462)
			p.FullColumnName()
		}

	case 3:
		localctx = NewMysqlVariableExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1463)
			p.MysqlVariable()
		}

	case 4:
		localctx = NewUnaryExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1464)
			p.UnaryOperator()
		}
		{
			p.SetState(1465)
			p.expressionAtom(8)
		}

	case 5:
		localctx = NewBinaryExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1467)
			p.Match(StmtParserBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1468)
			p.expressionAtom(7)
		}

	case 6:
		localctx = NewNestedExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1469)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1470)
			p.expression(0)
		}
		p.SetState(1475)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserCOMMA {
			{
				p.SetState(1471)
				p.Match(StmtParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1472)
				p.expression(0)
			}

			p.SetState(1477)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1478)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewNestedRowExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1480)
			p.Match(StmtParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1481)
			p.Match(StmtParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1482)
			p.expression(0)
		}
		p.SetState(1485)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == StmtParserCOMMA {
			{
				p.SetState(1483)
				p.Match(StmtParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1484)
				p.expression(0)
			}

			p.SetState(1487)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1489)
			p.Match(StmtParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewIntervalExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1491)
			p.Match(StmtParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1492)
			p.expression(0)
		}
		{
			p.SetState(1493)
			p.IntervalType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1514)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 229, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1512)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 228, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBitExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*BitExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_expressionAtom)
				p.SetState(1497)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(1498)
					p.BitOperator()
				}
				{
					p.SetState(1499)

					var _x = p.expressionAtom(4)

					localctx.(*BitExpressionAtomContext).right = _x
				}

			case 2:
				localctx = NewMathExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*MathExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_expressionAtom)
				p.SetState(1501)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1502)
					p.MathOperator()
				}
				{
					p.SetState(1503)

					var _x = p.expressionAtom(3)

					localctx.(*MathExpressionAtomContext).right = _x
				}

			case 3:
				localctx = NewJsonExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*JsonExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_expressionAtom)
				p.SetState(1505)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(1506)
					p.JsonOperator()
				}
				{
					p.SetState(1507)

					var _x = p.expressionAtom(2)

					localctx.(*JsonExpressionAtomContext).right = _x
				}

			case 4:
				localctx = NewCollateExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_expressionAtom)
				p.SetState(1509)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(1510)
					p.Match(StmtParserCOLLATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1511)
					p.CollationName()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1516)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 229, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryOperatorContext is an interface to support dynamic dispatch.
type IUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCLAMATION_SYMBOL() antlr.TerminalNode
	BIT_NOT_OP() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsUnaryOperatorContext differentiates from other interfaces.
	IsUnaryOperatorContext()
}

type UnaryOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryOperatorContext() *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_unaryOperator
	return p
}

func InitEmptyUnaryOperatorContext(p *UnaryOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_unaryOperator
}

func (*UnaryOperatorContext) IsUnaryOperatorContext() {}

func NewUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_unaryOperator

	return p
}

func (s *UnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEXCLAMATION_SYMBOL, 0)
}

func (s *UnaryOperatorContext) BIT_NOT_OP() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_NOT_OP, 0)
}

func (s *UnaryOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(StmtParserPLUS, 0)
}

func (s *UnaryOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(StmtParserMINUS, 0)
}

func (s *UnaryOperatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *UnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterUnaryOperator(s)
	}
}

func (s *UnaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitUnaryOperator(s)
	}
}

func (p *StmtParser) UnaryOperator() (localctx IUnaryOperatorContext) {
	localctx = NewUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, StmtParserRULE_unaryOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1517)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserNOT || ((int64((_la-1110)) & ^0x3f) == 0 && ((int64(1)<<(_la-1110))&387) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL_SYMBOL() antlr.TerminalNode
	GREATER_SYMBOL() antlr.TerminalNode
	LESS_SYMBOL() antlr.TerminalNode
	EXCLAMATION_SYMBOL() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GREATER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserGREATER_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserLESS_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEXCLAMATION_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *StmtParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, StmtParserRULE_comparisonOperator)
	p.SetState(1533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 230, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1519)
			p.Match(StmtParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1520)
			p.Match(StmtParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1521)
			p.Match(StmtParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1522)
			p.Match(StmtParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1523)
			p.Match(StmtParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1524)
			p.Match(StmtParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1525)
			p.Match(StmtParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1526)
			p.Match(StmtParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1527)
			p.Match(StmtParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1528)
			p.Match(StmtParserEXCLAMATION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1529)
			p.Match(StmtParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1530)
			p.Match(StmtParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1531)
			p.Match(StmtParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1532)
			p.Match(StmtParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalOperatorContext is an interface to support dynamic dispatch.
type ILogicalOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AND() antlr.TerminalNode
	AllBIT_AND_OP() []antlr.TerminalNode
	BIT_AND_OP(i int) antlr.TerminalNode
	XOR() antlr.TerminalNode
	OR() antlr.TerminalNode
	AllBIT_OR_OP() []antlr.TerminalNode
	BIT_OR_OP(i int) antlr.TerminalNode

	// IsLogicalOperatorContext differentiates from other interfaces.
	IsLogicalOperatorContext()
}

type LogicalOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalOperatorContext() *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_logicalOperator
	return p
}

func InitEmptyLogicalOperatorContext(p *LogicalOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_logicalOperator
}

func (*LogicalOperatorContext) IsLogicalOperatorContext() {}

func NewLogicalOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_logicalOperator

	return p
}

func (s *LogicalOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOperatorContext) AND() antlr.TerminalNode {
	return s.GetToken(StmtParserAND, 0)
}

func (s *LogicalOperatorContext) AllBIT_AND_OP() []antlr.TerminalNode {
	return s.GetTokens(StmtParserBIT_AND_OP)
}

func (s *LogicalOperatorContext) BIT_AND_OP(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_AND_OP, i)
}

func (s *LogicalOperatorContext) XOR() antlr.TerminalNode {
	return s.GetToken(StmtParserXOR, 0)
}

func (s *LogicalOperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(StmtParserOR, 0)
}

func (s *LogicalOperatorContext) AllBIT_OR_OP() []antlr.TerminalNode {
	return s.GetTokens(StmtParserBIT_OR_OP)
}

func (s *LogicalOperatorContext) BIT_OR_OP(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_OR_OP, i)
}

func (s *LogicalOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterLogicalOperator(s)
	}
}

func (s *LogicalOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitLogicalOperator(s)
	}
}

func (p *StmtParser) LogicalOperator() (localctx ILogicalOperatorContext) {
	localctx = NewLogicalOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, StmtParserRULE_logicalOperator)
	p.SetState(1542)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StmtParserAND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1535)
			p.Match(StmtParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserBIT_AND_OP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1536)
			p.Match(StmtParserBIT_AND_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1537)
			p.Match(StmtParserBIT_AND_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserXOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1538)
			p.Match(StmtParserXOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserOR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1539)
			p.Match(StmtParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserBIT_OR_OP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1540)
			p.Match(StmtParserBIT_OR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1541)
			p.Match(StmtParserBIT_OR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitOperatorContext is an interface to support dynamic dispatch.
type IBitOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLESS_SYMBOL() []antlr.TerminalNode
	LESS_SYMBOL(i int) antlr.TerminalNode
	AllGREATER_SYMBOL() []antlr.TerminalNode
	GREATER_SYMBOL(i int) antlr.TerminalNode
	BIT_AND_OP() antlr.TerminalNode
	BIT_XOR_OP() antlr.TerminalNode
	BIT_OR_OP() antlr.TerminalNode

	// IsBitOperatorContext differentiates from other interfaces.
	IsBitOperatorContext()
}

type BitOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitOperatorContext() *BitOperatorContext {
	var p = new(BitOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_bitOperator
	return p
}

func InitEmptyBitOperatorContext(p *BitOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_bitOperator
}

func (*BitOperatorContext) IsBitOperatorContext() {}

func NewBitOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitOperatorContext {
	var p = new(BitOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_bitOperator

	return p
}

func (s *BitOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *BitOperatorContext) AllLESS_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(StmtParserLESS_SYMBOL)
}

func (s *BitOperatorContext) LESS_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserLESS_SYMBOL, i)
}

func (s *BitOperatorContext) AllGREATER_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(StmtParserGREATER_SYMBOL)
}

func (s *BitOperatorContext) GREATER_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserGREATER_SYMBOL, i)
}

func (s *BitOperatorContext) BIT_AND_OP() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_AND_OP, 0)
}

func (s *BitOperatorContext) BIT_XOR_OP() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_XOR_OP, 0)
}

func (s *BitOperatorContext) BIT_OR_OP() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_OR_OP, 0)
}

func (s *BitOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterBitOperator(s)
	}
}

func (s *BitOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitBitOperator(s)
	}
}

func (p *StmtParser) BitOperator() (localctx IBitOperatorContext) {
	localctx = NewBitOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, StmtParserRULE_bitOperator)
	p.SetState(1551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StmtParserLESS_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1544)
			p.Match(StmtParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1545)
			p.Match(StmtParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserGREATER_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1546)
			p.Match(StmtParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1547)
			p.Match(StmtParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserBIT_AND_OP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1548)
			p.Match(StmtParserBIT_AND_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserBIT_XOR_OP:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1549)
			p.Match(StmtParserBIT_XOR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StmtParserBIT_OR_OP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1550)
			p.Match(StmtParserBIT_OR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMathOperatorContext is an interface to support dynamic dispatch.
type IMathOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	DIVIDE() antlr.TerminalNode
	MODULE() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsMathOperatorContext differentiates from other interfaces.
	IsMathOperatorContext()
}

type MathOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMathOperatorContext() *MathOperatorContext {
	var p = new(MathOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_mathOperator
	return p
}

func InitEmptyMathOperatorContext(p *MathOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_mathOperator
}

func (*MathOperatorContext) IsMathOperatorContext() {}

func NewMathOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MathOperatorContext {
	var p = new(MathOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_mathOperator

	return p
}

func (s *MathOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MathOperatorContext) STAR() antlr.TerminalNode {
	return s.GetToken(StmtParserSTAR, 0)
}

func (s *MathOperatorContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(StmtParserDIVIDE, 0)
}

func (s *MathOperatorContext) MODULE() antlr.TerminalNode {
	return s.GetToken(StmtParserMODULE, 0)
}

func (s *MathOperatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(StmtParserDIV, 0)
}

func (s *MathOperatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(StmtParserMOD, 0)
}

func (s *MathOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(StmtParserPLUS, 0)
}

func (s *MathOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(StmtParserMINUS, 0)
}

func (s *MathOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MathOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MathOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterMathOperator(s)
	}
}

func (s *MathOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitMathOperator(s)
	}
}

func (p *StmtParser) MathOperator() (localctx IMathOperatorContext) {
	localctx = NewMathOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, StmtParserRULE_mathOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1553)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-1107)) & ^0x3f) == 0 && ((int64(1)<<(_la-1107))&127) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonOperatorContext is an interface to support dynamic dispatch.
type IJsonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS() antlr.TerminalNode
	AllGREATER_SYMBOL() []antlr.TerminalNode
	GREATER_SYMBOL(i int) antlr.TerminalNode

	// IsJsonOperatorContext differentiates from other interfaces.
	IsJsonOperatorContext()
}

type JsonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonOperatorContext() *JsonOperatorContext {
	var p = new(JsonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_jsonOperator
	return p
}

func InitEmptyJsonOperatorContext(p *JsonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_jsonOperator
}

func (*JsonOperatorContext) IsJsonOperatorContext() {}

func NewJsonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonOperatorContext {
	var p = new(JsonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_jsonOperator

	return p
}

func (s *JsonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(StmtParserMINUS, 0)
}

func (s *JsonOperatorContext) AllGREATER_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(StmtParserGREATER_SYMBOL)
}

func (s *JsonOperatorContext) GREATER_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserGREATER_SYMBOL, i)
}

func (s *JsonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterJsonOperator(s)
	}
}

func (s *JsonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitJsonOperator(s)
	}
}

func (p *StmtParser) JsonOperator() (localctx IJsonOperatorContext) {
	localctx = NewJsonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, StmtParserRULE_jsonOperator)
	p.SetState(1560)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 233, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1555)
			p.Match(StmtParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1556)
			p.Match(StmtParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1557)
			p.Match(StmtParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1558)
			p.Match(StmtParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1559)
			p.Match(StmtParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetNameBaseContext is an interface to support dynamic dispatch.
type ICharsetNameBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARMSCII8() antlr.TerminalNode
	ASCII() antlr.TerminalNode
	BIG5() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	CP1250() antlr.TerminalNode
	CP1251() antlr.TerminalNode
	CP1256() antlr.TerminalNode
	CP1257() antlr.TerminalNode
	CP850() antlr.TerminalNode
	CP852() antlr.TerminalNode
	CP866() antlr.TerminalNode
	CP932() antlr.TerminalNode
	DEC8() antlr.TerminalNode
	EUCJPMS() antlr.TerminalNode
	EUCKR() antlr.TerminalNode
	GB18030() antlr.TerminalNode
	GB2312() antlr.TerminalNode
	GBK() antlr.TerminalNode
	GEOSTD8() antlr.TerminalNode
	GREEK() antlr.TerminalNode
	HEBREW() antlr.TerminalNode
	HP8() antlr.TerminalNode
	KEYBCS2() antlr.TerminalNode
	KOI8R() antlr.TerminalNode
	KOI8U() antlr.TerminalNode
	LATIN1() antlr.TerminalNode
	LATIN2() antlr.TerminalNode
	LATIN5() antlr.TerminalNode
	LATIN7() antlr.TerminalNode
	MACCE() antlr.TerminalNode
	MACROMAN() antlr.TerminalNode
	SJIS() antlr.TerminalNode
	SWE7() antlr.TerminalNode
	TIS620() antlr.TerminalNode
	UCS2() antlr.TerminalNode
	UJIS() antlr.TerminalNode
	UTF16() antlr.TerminalNode
	UTF16LE() antlr.TerminalNode
	UTF32() antlr.TerminalNode
	UTF8() antlr.TerminalNode
	UTF8MB3() antlr.TerminalNode
	UTF8MB4() antlr.TerminalNode

	// IsCharsetNameBaseContext differentiates from other interfaces.
	IsCharsetNameBaseContext()
}

type CharsetNameBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameBaseContext() *CharsetNameBaseContext {
	var p = new(CharsetNameBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_charsetNameBase
	return p
}

func InitEmptyCharsetNameBaseContext(p *CharsetNameBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_charsetNameBase
}

func (*CharsetNameBaseContext) IsCharsetNameBaseContext() {}

func NewCharsetNameBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameBaseContext {
	var p = new(CharsetNameBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_charsetNameBase

	return p
}

func (s *CharsetNameBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameBaseContext) ARMSCII8() antlr.TerminalNode {
	return s.GetToken(StmtParserARMSCII8, 0)
}

func (s *CharsetNameBaseContext) ASCII() antlr.TerminalNode {
	return s.GetToken(StmtParserASCII, 0)
}

func (s *CharsetNameBaseContext) BIG5() antlr.TerminalNode {
	return s.GetToken(StmtParserBIG5, 0)
}

func (s *CharsetNameBaseContext) BINARY() antlr.TerminalNode {
	return s.GetToken(StmtParserBINARY, 0)
}

func (s *CharsetNameBaseContext) CP1250() antlr.TerminalNode {
	return s.GetToken(StmtParserCP1250, 0)
}

func (s *CharsetNameBaseContext) CP1251() antlr.TerminalNode {
	return s.GetToken(StmtParserCP1251, 0)
}

func (s *CharsetNameBaseContext) CP1256() antlr.TerminalNode {
	return s.GetToken(StmtParserCP1256, 0)
}

func (s *CharsetNameBaseContext) CP1257() antlr.TerminalNode {
	return s.GetToken(StmtParserCP1257, 0)
}

func (s *CharsetNameBaseContext) CP850() antlr.TerminalNode {
	return s.GetToken(StmtParserCP850, 0)
}

func (s *CharsetNameBaseContext) CP852() antlr.TerminalNode {
	return s.GetToken(StmtParserCP852, 0)
}

func (s *CharsetNameBaseContext) CP866() antlr.TerminalNode {
	return s.GetToken(StmtParserCP866, 0)
}

func (s *CharsetNameBaseContext) CP932() antlr.TerminalNode {
	return s.GetToken(StmtParserCP932, 0)
}

func (s *CharsetNameBaseContext) DEC8() antlr.TerminalNode {
	return s.GetToken(StmtParserDEC8, 0)
}

func (s *CharsetNameBaseContext) EUCJPMS() antlr.TerminalNode {
	return s.GetToken(StmtParserEUCJPMS, 0)
}

func (s *CharsetNameBaseContext) EUCKR() antlr.TerminalNode {
	return s.GetToken(StmtParserEUCKR, 0)
}

func (s *CharsetNameBaseContext) GB18030() antlr.TerminalNode {
	return s.GetToken(StmtParserGB18030, 0)
}

func (s *CharsetNameBaseContext) GB2312() antlr.TerminalNode {
	return s.GetToken(StmtParserGB2312, 0)
}

func (s *CharsetNameBaseContext) GBK() antlr.TerminalNode {
	return s.GetToken(StmtParserGBK, 0)
}

func (s *CharsetNameBaseContext) GEOSTD8() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOSTD8, 0)
}

func (s *CharsetNameBaseContext) GREEK() antlr.TerminalNode {
	return s.GetToken(StmtParserGREEK, 0)
}

func (s *CharsetNameBaseContext) HEBREW() antlr.TerminalNode {
	return s.GetToken(StmtParserHEBREW, 0)
}

func (s *CharsetNameBaseContext) HP8() antlr.TerminalNode {
	return s.GetToken(StmtParserHP8, 0)
}

func (s *CharsetNameBaseContext) KEYBCS2() antlr.TerminalNode {
	return s.GetToken(StmtParserKEYBCS2, 0)
}

func (s *CharsetNameBaseContext) KOI8R() antlr.TerminalNode {
	return s.GetToken(StmtParserKOI8R, 0)
}

func (s *CharsetNameBaseContext) KOI8U() antlr.TerminalNode {
	return s.GetToken(StmtParserKOI8U, 0)
}

func (s *CharsetNameBaseContext) LATIN1() antlr.TerminalNode {
	return s.GetToken(StmtParserLATIN1, 0)
}

func (s *CharsetNameBaseContext) LATIN2() antlr.TerminalNode {
	return s.GetToken(StmtParserLATIN2, 0)
}

func (s *CharsetNameBaseContext) LATIN5() antlr.TerminalNode {
	return s.GetToken(StmtParserLATIN5, 0)
}

func (s *CharsetNameBaseContext) LATIN7() antlr.TerminalNode {
	return s.GetToken(StmtParserLATIN7, 0)
}

func (s *CharsetNameBaseContext) MACCE() antlr.TerminalNode {
	return s.GetToken(StmtParserMACCE, 0)
}

func (s *CharsetNameBaseContext) MACROMAN() antlr.TerminalNode {
	return s.GetToken(StmtParserMACROMAN, 0)
}

func (s *CharsetNameBaseContext) SJIS() antlr.TerminalNode {
	return s.GetToken(StmtParserSJIS, 0)
}

func (s *CharsetNameBaseContext) SWE7() antlr.TerminalNode {
	return s.GetToken(StmtParserSWE7, 0)
}

func (s *CharsetNameBaseContext) TIS620() antlr.TerminalNode {
	return s.GetToken(StmtParserTIS620, 0)
}

func (s *CharsetNameBaseContext) UCS2() antlr.TerminalNode {
	return s.GetToken(StmtParserUCS2, 0)
}

func (s *CharsetNameBaseContext) UJIS() antlr.TerminalNode {
	return s.GetToken(StmtParserUJIS, 0)
}

func (s *CharsetNameBaseContext) UTF16() antlr.TerminalNode {
	return s.GetToken(StmtParserUTF16, 0)
}

func (s *CharsetNameBaseContext) UTF16LE() antlr.TerminalNode {
	return s.GetToken(StmtParserUTF16LE, 0)
}

func (s *CharsetNameBaseContext) UTF32() antlr.TerminalNode {
	return s.GetToken(StmtParserUTF32, 0)
}

func (s *CharsetNameBaseContext) UTF8() antlr.TerminalNode {
	return s.GetToken(StmtParserUTF8, 0)
}

func (s *CharsetNameBaseContext) UTF8MB3() antlr.TerminalNode {
	return s.GetToken(StmtParserUTF8MB3, 0)
}

func (s *CharsetNameBaseContext) UTF8MB4() antlr.TerminalNode {
	return s.GetToken(StmtParserUTF8MB4, 0)
}

func (s *CharsetNameBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetNameBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCharsetNameBase(s)
	}
}

func (s *CharsetNameBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCharsetNameBase(s)
	}
}

func (p *StmtParser) CharsetNameBase() (localctx ICharsetNameBaseContext) {
	localctx = NewCharsetNameBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, StmtParserRULE_charsetNameBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1562)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserBINARY || ((int64((_la-726)) & ^0x3f) == 0 && ((int64(1)<<(_la-726))&2199023255551) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionLevelBaseContext is an interface to support dynamic dispatch.
type ITransactionLevelBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEATABLE() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode

	// IsTransactionLevelBaseContext differentiates from other interfaces.
	IsTransactionLevelBaseContext()
}

type TransactionLevelBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionLevelBaseContext() *TransactionLevelBaseContext {
	var p = new(TransactionLevelBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_transactionLevelBase
	return p
}

func InitEmptyTransactionLevelBaseContext(p *TransactionLevelBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_transactionLevelBase
}

func (*TransactionLevelBaseContext) IsTransactionLevelBaseContext() {}

func NewTransactionLevelBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionLevelBaseContext {
	var p = new(TransactionLevelBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_transactionLevelBase

	return p
}

func (s *TransactionLevelBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionLevelBaseContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserREPEATABLE, 0)
}

func (s *TransactionLevelBaseContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMITTED, 0)
}

func (s *TransactionLevelBaseContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(StmtParserUNCOMMITTED, 0)
}

func (s *TransactionLevelBaseContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserSERIALIZABLE, 0)
}

func (s *TransactionLevelBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionLevelBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionLevelBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTransactionLevelBase(s)
	}
}

func (s *TransactionLevelBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTransactionLevelBase(s)
	}
}

func (p *StmtParser) TransactionLevelBase() (localctx ITransactionLevelBaseContext) {
	localctx = NewTransactionLevelBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, StmtParserRULE_transactionLevelBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1564)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-779)) & ^0x3f) == 0 && ((int64(1)<<(_la-779))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegesBaseContext is an interface to support dynamic dispatch.
type IPrivilegesBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLES() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	FILE() antlr.TerminalNode
	PROCESS() antlr.TerminalNode
	RELOAD() antlr.TerminalNode
	SHUTDOWN() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode

	// IsPrivilegesBaseContext differentiates from other interfaces.
	IsPrivilegesBaseContext()
}

type PrivilegesBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegesBaseContext() *PrivilegesBaseContext {
	var p = new(PrivilegesBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_privilegesBase
	return p
}

func InitEmptyPrivilegesBaseContext(p *PrivilegesBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_privilegesBase
}

func (*PrivilegesBaseContext) IsPrivilegesBaseContext() {}

func NewPrivilegesBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegesBaseContext {
	var p = new(PrivilegesBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_privilegesBase

	return p
}

func (s *PrivilegesBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegesBaseContext) TABLES() antlr.TerminalNode {
	return s.GetToken(StmtParserTABLES, 0)
}

func (s *PrivilegesBaseContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StmtParserROUTINE, 0)
}

func (s *PrivilegesBaseContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserEXECUTE, 0)
}

func (s *PrivilegesBaseContext) FILE() antlr.TerminalNode {
	return s.GetToken(StmtParserFILE, 0)
}

func (s *PrivilegesBaseContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(StmtParserPROCESS, 0)
}

func (s *PrivilegesBaseContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(StmtParserRELOAD, 0)
}

func (s *PrivilegesBaseContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(StmtParserSHUTDOWN, 0)
}

func (s *PrivilegesBaseContext) SUPER() antlr.TerminalNode {
	return s.GetToken(StmtParserSUPER, 0)
}

func (s *PrivilegesBaseContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(StmtParserPRIVILEGES, 0)
}

func (s *PrivilegesBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegesBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegesBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPrivilegesBase(s)
	}
}

func (s *PrivilegesBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPrivilegesBase(s)
	}
}

func (p *StmtParser) PrivilegesBase() (localctx IPrivilegesBaseContext) {
	localctx = NewPrivilegesBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, StmtParserRULE_privilegesBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1566)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-680)) & ^0x3f) == 0 && ((int64(1)<<(_la-680))&511) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalTypeBaseContext is an interface to support dynamic dispatch.
type IIntervalTypeBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUARTER() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode

	// IsIntervalTypeBaseContext differentiates from other interfaces.
	IsIntervalTypeBaseContext()
}

type IntervalTypeBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalTypeBaseContext() *IntervalTypeBaseContext {
	var p = new(IntervalTypeBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_intervalTypeBase
	return p
}

func InitEmptyIntervalTypeBaseContext(p *IntervalTypeBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_intervalTypeBase
}

func (*IntervalTypeBaseContext) IsIntervalTypeBaseContext() {}

func NewIntervalTypeBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalTypeBaseContext {
	var p = new(IntervalTypeBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_intervalTypeBase

	return p
}

func (s *IntervalTypeBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalTypeBaseContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(StmtParserQUARTER, 0)
}

func (s *IntervalTypeBaseContext) MONTH() antlr.TerminalNode {
	return s.GetToken(StmtParserMONTH, 0)
}

func (s *IntervalTypeBaseContext) DAY() antlr.TerminalNode {
	return s.GetToken(StmtParserDAY, 0)
}

func (s *IntervalTypeBaseContext) HOUR() antlr.TerminalNode {
	return s.GetToken(StmtParserHOUR, 0)
}

func (s *IntervalTypeBaseContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserMINUTE, 0)
}

func (s *IntervalTypeBaseContext) WEEK() antlr.TerminalNode {
	return s.GetToken(StmtParserWEEK, 0)
}

func (s *IntervalTypeBaseContext) SECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserSECOND, 0)
}

func (s *IntervalTypeBaseContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserMICROSECOND, 0)
}

func (s *IntervalTypeBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTypeBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalTypeBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIntervalTypeBase(s)
	}
}

func (s *IntervalTypeBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIntervalTypeBase(s)
	}
}

func (p *StmtParser) IntervalTypeBase() (localctx IIntervalTypeBaseContext) {
	localctx = NewIntervalTypeBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, StmtParserRULE_intervalTypeBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1568)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-672)) & ^0x3f) == 0 && ((int64(1)<<(_la-672))&255) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeBaseContext is an interface to support dynamic dispatch.
type IDataTypeBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATE() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	TEXT() antlr.TerminalNode

	// IsDataTypeBaseContext differentiates from other interfaces.
	IsDataTypeBaseContext()
}

type DataTypeBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeBaseContext() *DataTypeBaseContext {
	var p = new(DataTypeBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_dataTypeBase
	return p
}

func InitEmptyDataTypeBaseContext(p *DataTypeBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_dataTypeBase
}

func (*DataTypeBaseContext) IsDataTypeBaseContext() {}

func NewDataTypeBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeBaseContext {
	var p = new(DataTypeBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_dataTypeBase

	return p
}

func (s *DataTypeBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeBaseContext) DATE() antlr.TerminalNode {
	return s.GetToken(StmtParserDATE, 0)
}

func (s *DataTypeBaseContext) TIME() antlr.TerminalNode {
	return s.GetToken(StmtParserTIME, 0)
}

func (s *DataTypeBaseContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserTIMESTAMP, 0)
}

func (s *DataTypeBaseContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(StmtParserDATETIME, 0)
}

func (s *DataTypeBaseContext) YEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserYEAR, 0)
}

func (s *DataTypeBaseContext) ENUM() antlr.TerminalNode {
	return s.GetToken(StmtParserENUM, 0)
}

func (s *DataTypeBaseContext) TEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserTEXT, 0)
}

func (s *DataTypeBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterDataTypeBase(s)
	}
}

func (s *DataTypeBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitDataTypeBase(s)
	}
}

func (p *StmtParser) DataTypeBase() (localctx IDataTypeBaseContext) {
	localctx = NewDataTypeBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, StmtParserRULE_dataTypeBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1570)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&1179679) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeywordsCanBeIdContext is an interface to support dynamic dispatch.
type IKeywordsCanBeIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACCOUNT() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	ADMIN() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	ALGORITHM() antlr.TerminalNode
	ANY() antlr.TerminalNode
	AT() antlr.TerminalNode
	AUDIT_ADMIN() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode
	AUTOCOMMIT() antlr.TerminalNode
	AUTOEXTEND_SIZE() antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	AVG() antlr.TerminalNode
	AVG_ROW_LENGTH() antlr.TerminalNode
	BACKUP_ADMIN() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BINLOG() antlr.TerminalNode
	BINLOG_ADMIN() antlr.TerminalNode
	BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode
	BIT() antlr.TerminalNode
	BIT_AND() antlr.TerminalNode
	BIT_OR() antlr.TerminalNode
	BIT_XOR() antlr.TerminalNode
	BLOCK() antlr.TerminalNode
	BOOL() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	BTREE() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	CASCADED() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	CHANGED() antlr.TerminalNode
	CHANNEL() antlr.TerminalNode
	CHECKSUM() antlr.TerminalNode
	PAGE_CHECKSUM() antlr.TerminalNode
	CATALOG_NAME() antlr.TerminalNode
	CIPHER() antlr.TerminalNode
	CLASS_ORIGIN() antlr.TerminalNode
	CLIENT() antlr.TerminalNode
	CLONE_ADMIN() antlr.TerminalNode
	CLOSE() antlr.TerminalNode
	CLUSTERING() antlr.TerminalNode
	COALESCE() antlr.TerminalNode
	CODE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	COLUMN_FORMAT() antlr.TerminalNode
	COLUMN_NAME() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	COMPLETION() antlr.TerminalNode
	COMPRESSED() antlr.TerminalNode
	COMPRESSION() antlr.TerminalNode
	CONCURRENT() antlr.TerminalNode
	CONNECT() antlr.TerminalNode
	CONNECTION() antlr.TerminalNode
	CONNECTION_ADMIN() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	CONSTRAINT_CATALOG() antlr.TerminalNode
	CONSTRAINT_NAME() antlr.TerminalNode
	CONSTRAINT_SCHEMA() antlr.TerminalNode
	CONTAINS() antlr.TerminalNode
	CONTEXT() antlr.TerminalNode
	CONTRIBUTORS() antlr.TerminalNode
	COPY() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CPU() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	CURSOR_NAME() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATAFILE() antlr.TerminalNode
	DEALLOCATE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DEFAULT_AUTH() antlr.TerminalNode
	DEFINER() antlr.TerminalNode
	DELAY_KEY_WRITE() antlr.TerminalNode
	DES_KEY_FILE() antlr.TerminalNode
	DIAGNOSTICS() antlr.TerminalNode
	DIRECTORY() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	DISCARD() antlr.TerminalNode
	DISK() antlr.TerminalNode
	DO() antlr.TerminalNode
	DUMPFILE() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	ENCRYPTION() antlr.TerminalNode
	ENCRYPTION_KEY_ADMIN() antlr.TerminalNode
	END() antlr.TerminalNode
	ENDS() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	ENGINE_ATTRIBUTE() antlr.TerminalNode
	ENGINES() antlr.TerminalNode
	ERROR() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	EUR() antlr.TerminalNode
	EVEN() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	EXCHANGE() antlr.TerminalNode
	EXCLUSIVE() antlr.TerminalNode
	EXPIRE() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	EXTENT_SIZE() antlr.TerminalNode
	FAST() antlr.TerminalNode
	FAULTS() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FILE_BLOCK_SIZE() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIREWALL_ADMIN() antlr.TerminalNode
	FIREWALL_USER() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FIXED() antlr.TerminalNode
	FLUSH() antlr.TerminalNode
	FOLLOWS() antlr.TerminalNode
	FOUND() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GENERAL() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GRANTS() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	GROUP_REPLICATION() antlr.TerminalNode
	GROUP_REPLICATION_ADMIN() antlr.TerminalNode
	HANDLER() antlr.TerminalNode
	HASH() antlr.TerminalNode
	HELP() antlr.TerminalNode
	HOST() antlr.TerminalNode
	HOSTS() antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	IGNORED() antlr.TerminalNode
	IGNORE_SERVER_IDS() antlr.TerminalNode
	IMPORT() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	INITIAL_SIZE() antlr.TerminalNode
	INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode
	INPLACE() antlr.TerminalNode
	INSERT_METHOD() antlr.TerminalNode
	INSTALL() antlr.TerminalNode
	INSTANCE() antlr.TerminalNode
	INSTANT() antlr.TerminalNode
	INTERNAL() antlr.TerminalNode
	INVOKE() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	IO() antlr.TerminalNode
	IO_THREAD() antlr.TerminalNode
	IPC() antlr.TerminalNode
	ISO() antlr.TerminalNode
	ISOLATION() antlr.TerminalNode
	ISSUER() antlr.TerminalNode
	JIS() antlr.TerminalNode
	JSON() antlr.TerminalNode
	KEY_BLOCK_SIZE() antlr.TerminalNode
	LAMBDA() antlr.TerminalNode
	LANGUAGE() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LEAVES() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	LIST() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	MASTER_AUTO_POSITION() antlr.TerminalNode
	MASTER_CONNECT_RETRY() antlr.TerminalNode
	MASTER_DELAY() antlr.TerminalNode
	MASTER_HEARTBEAT_PERIOD() antlr.TerminalNode
	MASTER_HOST() antlr.TerminalNode
	MASTER_LOG_FILE() antlr.TerminalNode
	MASTER_LOG_POS() antlr.TerminalNode
	MASTER_PASSWORD() antlr.TerminalNode
	MASTER_PORT() antlr.TerminalNode
	MASTER_RETRY_COUNT() antlr.TerminalNode
	MASTER_SSL() antlr.TerminalNode
	MASTER_SSL_CA() antlr.TerminalNode
	MASTER_SSL_CAPATH() antlr.TerminalNode
	MASTER_SSL_CERT() antlr.TerminalNode
	MASTER_SSL_CIPHER() antlr.TerminalNode
	MASTER_SSL_CRL() antlr.TerminalNode
	MASTER_SSL_CRLPATH() antlr.TerminalNode
	MASTER_SSL_KEY() antlr.TerminalNode
	MASTER_TLS_VERSION() antlr.TerminalNode
	MASTER_USER() antlr.TerminalNode
	MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode
	MAX_QUERIES_PER_HOUR() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MAX_ROWS() antlr.TerminalNode
	MAX_SIZE() antlr.TerminalNode
	MAX_UPDATES_PER_HOUR() antlr.TerminalNode
	MAX_USER_CONNECTIONS() antlr.TerminalNode
	MEDIUM() antlr.TerminalNode
	MEMBER() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	MESSAGE_TEXT() antlr.TerminalNode
	MID() antlr.TerminalNode
	MIGRATE() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MIN_ROWS() antlr.TerminalNode
	MODE() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	MUTEX() antlr.TerminalNode
	MYSQL() antlr.TerminalNode
	MYSQL_ERRNO() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NAMES() antlr.TerminalNode
	NCHAR() antlr.TerminalNode
	NDB_STORED_USER() antlr.TerminalNode
	NEVER() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	NO() antlr.TerminalNode
	NOCOPY() antlr.TerminalNode
	NODEGROUP() antlr.TerminalNode
	NONE() antlr.TerminalNode
	NOWAIT() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	ODBC() antlr.TerminalNode
	OFFLINE() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	OF() antlr.TerminalNode
	OJ() antlr.TerminalNode
	OLD_PASSWORD() antlr.TerminalNode
	ONE() antlr.TerminalNode
	ONLINE() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPTIMIZER_COSTS() antlr.TerminalNode
	OPTIONAL() antlr.TerminalNode
	OPTIONS() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	OWNER() antlr.TerminalNode
	PACK_KEYS() antlr.TerminalNode
	PAGE() antlr.TerminalNode
	PARSER() antlr.TerminalNode
	PARTIAL() antlr.TerminalNode
	PARTITIONING() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	PASSWORDLESS_USER_ADMIN() antlr.TerminalNode
	PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode
	PHASE() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	PLUGIN_DIR() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	PORT() antlr.TerminalNode
	PRECEDES() antlr.TerminalNode
	PREPARE() antlr.TerminalNode
	PRESERVE() antlr.TerminalNode
	PREV() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	PROFILES() antlr.TerminalNode
	PROXY() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	QUICK() antlr.TerminalNode
	REBUILD() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	RECURSIVE() antlr.TerminalNode
	REDO_BUFFER_SIZE() antlr.TerminalNode
	REDUNDANT() antlr.TerminalNode
	RELAY() antlr.TerminalNode
	RELAYLOG() antlr.TerminalNode
	RELAY_LOG_FILE() antlr.TerminalNode
	RELAY_LOG_POS() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	REORGANIZE() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	REPLICATE_DO_DB() antlr.TerminalNode
	REPLICATE_DO_TABLE() antlr.TerminalNode
	REPLICATE_IGNORE_DB() antlr.TerminalNode
	REPLICATE_IGNORE_TABLE() antlr.TerminalNode
	REPLICATE_REWRITE_DB() antlr.TerminalNode
	REPLICATE_WILD_DO_TABLE() antlr.TerminalNode
	REPLICATE_WILD_IGNORE_TABLE() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	REPLICATION_APPLIER() antlr.TerminalNode
	REPLICATION_SLAVE_ADMIN() antlr.TerminalNode
	RESET() antlr.TerminalNode
	RESOURCE_GROUP_ADMIN() antlr.TerminalNode
	RESOURCE_GROUP_USER() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	RETURNED_SQLSTATE() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	ROLE_ADMIN() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROTATE() antlr.TerminalNode
	ROW() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	ROW_FORMAT() antlr.TerminalNode
	RTREE() antlr.TerminalNode
	S3() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	SCHEMA_NAME() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode
	SERIAL() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	SESSION_VARIABLES_ADMIN() antlr.TerminalNode
	SET_USER_ID() antlr.TerminalNode
	SHARE() antlr.TerminalNode
	SHARED() antlr.TerminalNode
	SHOW_ROUTINE() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	SIMPLE() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	SLOW() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	SOCKET() antlr.TerminalNode
	SOME() antlr.TerminalNode
	SONAME() antlr.TerminalNode
	SOUNDS() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	SQL_AFTER_GTIDS() antlr.TerminalNode
	SQL_AFTER_MTS_GAPS() antlr.TerminalNode
	SQL_BEFORE_GTIDS() antlr.TerminalNode
	SQL_BUFFER_RESULT() antlr.TerminalNode
	SQL_CACHE() antlr.TerminalNode
	SQL_NO_CACHE() antlr.TerminalNode
	SQL_THREAD() antlr.TerminalNode
	STACKED() antlr.TerminalNode
	START() antlr.TerminalNode
	STARTS() antlr.TerminalNode
	STATS_AUTO_RECALC() antlr.TerminalNode
	STATS_PERSISTENT() antlr.TerminalNode
	STATS_SAMPLE_PAGES() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	STD() antlr.TerminalNode
	STDDEV() antlr.TerminalNode
	STDDEV_POP() antlr.TerminalNode
	STDDEV_SAMP() antlr.TerminalNode
	STOP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	STRING() antlr.TerminalNode
	SUBCLASS_ORIGIN() antlr.TerminalNode
	SUBJECT() antlr.TerminalNode
	SUBPARTITION() antlr.TerminalNode
	SUBPARTITIONS() antlr.TerminalNode
	SUM() antlr.TerminalNode
	SUSPEND() antlr.TerminalNode
	SWAPS() antlr.TerminalNode
	SWITCHES() antlr.TerminalNode
	SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode
	TABLE_NAME() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode
	TABLE_TYPE() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TEMPTABLE() antlr.TerminalNode
	THAN() antlr.TerminalNode
	TRADITIONAL() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TRANSACTIONAL() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	UNDEFINED() antlr.TerminalNode
	UNDOFILE() antlr.TerminalNode
	UNDO_BUFFER_SIZE() antlr.TerminalNode
	UNINSTALL() antlr.TerminalNode
	UNKNOWN() antlr.TerminalNode
	UNTIL() antlr.TerminalNode
	UPGRADE() antlr.TerminalNode
	USA() antlr.TerminalNode
	USER() antlr.TerminalNode
	USE_FRM() antlr.TerminalNode
	USER_RESOURCES() antlr.TerminalNode
	VALIDATION() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	VAR_POP() antlr.TerminalNode
	VAR_SAMP() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	VARIANCE() antlr.TerminalNode
	VERSION_TOKEN_ADMIN() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIRTUAL() antlr.TerminalNode
	WAIT() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	WORK() antlr.TerminalNode
	WRAPPER() antlr.TerminalNode
	X509() antlr.TerminalNode
	XA() antlr.TerminalNode
	XA_RECOVER_ADMIN() antlr.TerminalNode
	XML() antlr.TerminalNode
	VIA() antlr.TerminalNode
	LASTVAL() antlr.TerminalNode
	NEXTVAL() antlr.TerminalNode
	SETVAL() antlr.TerminalNode
	PREVIOUS() antlr.TerminalNode
	PERSISTENT() antlr.TerminalNode
	REPLICATION_MASTER_ADMIN() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	READ_ONLY_ADMIN() antlr.TerminalNode
	FEDERATED_ADMIN() antlr.TerminalNode
	BINLOG_MONITOR() antlr.TerminalNode
	BINLOG_REPLAY() antlr.TerminalNode
	SKIP_() antlr.TerminalNode
	LOCKED() antlr.TerminalNode
	CYCLE() antlr.TerminalNode
	INCREMENT() antlr.TerminalNode
	MINVALUE() antlr.TerminalNode
	MAXVALUE() antlr.TerminalNode
	NOCACHE() antlr.TerminalNode
	NOCYCLE() antlr.TerminalNode
	NOMINVALUE() antlr.TerminalNode
	NOMAXVALUE() antlr.TerminalNode
	RESTART() antlr.TerminalNode
	SEQUENCE() antlr.TerminalNode

	// IsKeywordsCanBeIdContext differentiates from other interfaces.
	IsKeywordsCanBeIdContext()
}

type KeywordsCanBeIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordsCanBeIdContext() *KeywordsCanBeIdContext {
	var p = new(KeywordsCanBeIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_keywordsCanBeId
	return p
}

func InitEmptyKeywordsCanBeIdContext(p *KeywordsCanBeIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_keywordsCanBeId
}

func (*KeywordsCanBeIdContext) IsKeywordsCanBeIdContext() {}

func NewKeywordsCanBeIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordsCanBeIdContext {
	var p = new(KeywordsCanBeIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_keywordsCanBeId

	return p
}

func (s *KeywordsCanBeIdContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordsCanBeIdContext) ACCOUNT() antlr.TerminalNode {
	return s.GetToken(StmtParserACCOUNT, 0)
}

func (s *KeywordsCanBeIdContext) ACTION() antlr.TerminalNode {
	return s.GetToken(StmtParserACTION, 0)
}

func (s *KeywordsCanBeIdContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserADMIN, 0)
}

func (s *KeywordsCanBeIdContext) AFTER() antlr.TerminalNode {
	return s.GetToken(StmtParserAFTER, 0)
}

func (s *KeywordsCanBeIdContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(StmtParserAGGREGATE, 0)
}

func (s *KeywordsCanBeIdContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(StmtParserALGORITHM, 0)
}

func (s *KeywordsCanBeIdContext) ANY() antlr.TerminalNode {
	return s.GetToken(StmtParserANY, 0)
}

func (s *KeywordsCanBeIdContext) AT() antlr.TerminalNode {
	return s.GetToken(StmtParserAT, 0)
}

func (s *KeywordsCanBeIdContext) AUDIT_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserAUDIT_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(StmtParserAUTHORS, 0)
}

func (s *KeywordsCanBeIdContext) AUTOCOMMIT() antlr.TerminalNode {
	return s.GetToken(StmtParserAUTOCOMMIT, 0)
}

func (s *KeywordsCanBeIdContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserAUTOEXTEND_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(StmtParserAUTO_INCREMENT, 0)
}

func (s *KeywordsCanBeIdContext) AVG() antlr.TerminalNode {
	return s.GetToken(StmtParserAVG, 0)
}

func (s *KeywordsCanBeIdContext) AVG_ROW_LENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserAVG_ROW_LENGTH, 0)
}

func (s *KeywordsCanBeIdContext) BACKUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserBACKUP_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(StmtParserBEGIN, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(StmtParserBINLOG, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserBINLOG_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserBINLOG_ENCRYPTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BIT() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT, 0)
}

func (s *KeywordsCanBeIdContext) BIT_AND() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_AND, 0)
}

func (s *KeywordsCanBeIdContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_OR, 0)
}

func (s *KeywordsCanBeIdContext) BIT_XOR() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_XOR, 0)
}

func (s *KeywordsCanBeIdContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(StmtParserBLOCK, 0)
}

func (s *KeywordsCanBeIdContext) BOOL() antlr.TerminalNode {
	return s.GetToken(StmtParserBOOL, 0)
}

func (s *KeywordsCanBeIdContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(StmtParserBOOLEAN, 0)
}

func (s *KeywordsCanBeIdContext) BTREE() antlr.TerminalNode {
	return s.GetToken(StmtParserBTREE, 0)
}

func (s *KeywordsCanBeIdContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(StmtParserBUCKETS, 0)
}

func (s *KeywordsCanBeIdContext) CACHE() antlr.TerminalNode {
	return s.GetToken(StmtParserCACHE, 0)
}

func (s *KeywordsCanBeIdContext) CASCADED() antlr.TerminalNode {
	return s.GetToken(StmtParserCASCADED, 0)
}

func (s *KeywordsCanBeIdContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(StmtParserCHAIN, 0)
}

func (s *KeywordsCanBeIdContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(StmtParserCHANGED, 0)
}

func (s *KeywordsCanBeIdContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(StmtParserCHANNEL, 0)
}

func (s *KeywordsCanBeIdContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(StmtParserCHECKSUM, 0)
}

func (s *KeywordsCanBeIdContext) PAGE_CHECKSUM() antlr.TerminalNode {
	return s.GetToken(StmtParserPAGE_CHECKSUM, 0)
}

func (s *KeywordsCanBeIdContext) CATALOG_NAME() antlr.TerminalNode {
	return s.GetToken(StmtParserCATALOG_NAME, 0)
}

func (s *KeywordsCanBeIdContext) CIPHER() antlr.TerminalNode {
	return s.GetToken(StmtParserCIPHER, 0)
}

func (s *KeywordsCanBeIdContext) CLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(StmtParserCLASS_ORIGIN, 0)
}

func (s *KeywordsCanBeIdContext) CLIENT() antlr.TerminalNode {
	return s.GetToken(StmtParserCLIENT, 0)
}

func (s *KeywordsCanBeIdContext) CLONE_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserCLONE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(StmtParserCLOSE, 0)
}

func (s *KeywordsCanBeIdContext) CLUSTERING() antlr.TerminalNode {
	return s.GetToken(StmtParserCLUSTERING, 0)
}

func (s *KeywordsCanBeIdContext) COALESCE() antlr.TerminalNode {
	return s.GetToken(StmtParserCOALESCE, 0)
}

func (s *KeywordsCanBeIdContext) CODE() antlr.TerminalNode {
	return s.GetToken(StmtParserCODE, 0)
}

func (s *KeywordsCanBeIdContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLUMNS, 0)
}

func (s *KeywordsCanBeIdContext) COLUMN_FORMAT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLUMN_FORMAT, 0)
}

func (s *KeywordsCanBeIdContext) COLUMN_NAME() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLUMN_NAME, 0)
}

func (s *KeywordsCanBeIdContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMENT, 0)
}

func (s *KeywordsCanBeIdContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMIT, 0)
}

func (s *KeywordsCanBeIdContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMPACT, 0)
}

func (s *KeywordsCanBeIdContext) COMPLETION() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMPLETION, 0)
}

func (s *KeywordsCanBeIdContext) COMPRESSED() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMPRESSED, 0)
}

func (s *KeywordsCanBeIdContext) COMPRESSION() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMPRESSION, 0)
}

func (s *KeywordsCanBeIdContext) CONCURRENT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONCURRENT, 0)
}

func (s *KeywordsCanBeIdContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONNECT, 0)
}

func (s *KeywordsCanBeIdContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(StmtParserCONNECTION, 0)
}

func (s *KeywordsCanBeIdContext) CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserCONNECTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONSISTENT, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_CATALOG() antlr.TerminalNode {
	return s.GetToken(StmtParserCONSTRAINT_CATALOG, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(StmtParserCONSTRAINT_NAME, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(StmtParserCONSTRAINT_SCHEMA, 0)
}

func (s *KeywordsCanBeIdContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(StmtParserCONTAINS, 0)
}

func (s *KeywordsCanBeIdContext) CONTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONTEXT, 0)
}

func (s *KeywordsCanBeIdContext) CONTRIBUTORS() antlr.TerminalNode {
	return s.GetToken(StmtParserCONTRIBUTORS, 0)
}

func (s *KeywordsCanBeIdContext) COPY() antlr.TerminalNode {
	return s.GetToken(StmtParserCOPY, 0)
}

func (s *KeywordsCanBeIdContext) COUNT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOUNT, 0)
}

func (s *KeywordsCanBeIdContext) CPU() antlr.TerminalNode {
	return s.GetToken(StmtParserCPU, 0)
}

func (s *KeywordsCanBeIdContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(StmtParserCURRENT, 0)
}

func (s *KeywordsCanBeIdContext) CURSOR_NAME() antlr.TerminalNode {
	return s.GetToken(StmtParserCURSOR_NAME, 0)
}

func (s *KeywordsCanBeIdContext) DATA() antlr.TerminalNode {
	return s.GetToken(StmtParserDATA, 0)
}

func (s *KeywordsCanBeIdContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(StmtParserDATAFILE, 0)
}

func (s *KeywordsCanBeIdContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(StmtParserDEALLOCATE, 0)
}

func (s *KeywordsCanBeIdContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *KeywordsCanBeIdContext) DEFAULT_AUTH() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT_AUTH, 0)
}

func (s *KeywordsCanBeIdContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFINER, 0)
}

func (s *KeywordsCanBeIdContext) DELAY_KEY_WRITE() antlr.TerminalNode {
	return s.GetToken(StmtParserDELAY_KEY_WRITE, 0)
}

func (s *KeywordsCanBeIdContext) DES_KEY_FILE() antlr.TerminalNode {
	return s.GetToken(StmtParserDES_KEY_FILE, 0)
}

func (s *KeywordsCanBeIdContext) DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(StmtParserDIAGNOSTICS, 0)
}

func (s *KeywordsCanBeIdContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(StmtParserDIRECTORY, 0)
}

func (s *KeywordsCanBeIdContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserDISABLE, 0)
}

func (s *KeywordsCanBeIdContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(StmtParserDISCARD, 0)
}

func (s *KeywordsCanBeIdContext) DISK() antlr.TerminalNode {
	return s.GetToken(StmtParserDISK, 0)
}

func (s *KeywordsCanBeIdContext) DO() antlr.TerminalNode {
	return s.GetToken(StmtParserDO, 0)
}

func (s *KeywordsCanBeIdContext) DUMPFILE() antlr.TerminalNode {
	return s.GetToken(StmtParserDUMPFILE, 0)
}

func (s *KeywordsCanBeIdContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(StmtParserDUPLICATE, 0)
}

func (s *KeywordsCanBeIdContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(StmtParserDYNAMIC, 0)
}

func (s *KeywordsCanBeIdContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserENABLE, 0)
}

func (s *KeywordsCanBeIdContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(StmtParserENCRYPTION, 0)
}

func (s *KeywordsCanBeIdContext) ENCRYPTION_KEY_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserENCRYPTION_KEY_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) END() antlr.TerminalNode {
	return s.GetToken(StmtParserEND, 0)
}

func (s *KeywordsCanBeIdContext) ENDS() antlr.TerminalNode {
	return s.GetToken(StmtParserENDS, 0)
}

func (s *KeywordsCanBeIdContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(StmtParserENGINE, 0)
}

func (s *KeywordsCanBeIdContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserENGINE_ATTRIBUTE, 0)
}

func (s *KeywordsCanBeIdContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(StmtParserENGINES, 0)
}

func (s *KeywordsCanBeIdContext) ERROR() antlr.TerminalNode {
	return s.GetToken(StmtParserERROR, 0)
}

func (s *KeywordsCanBeIdContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(StmtParserERRORS, 0)
}

func (s *KeywordsCanBeIdContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(StmtParserESCAPE, 0)
}

func (s *KeywordsCanBeIdContext) EUR() antlr.TerminalNode {
	return s.GetToken(StmtParserEUR, 0)
}

func (s *KeywordsCanBeIdContext) EVEN() antlr.TerminalNode {
	return s.GetToken(StmtParserEVEN, 0)
}

func (s *KeywordsCanBeIdContext) EVENT() antlr.TerminalNode {
	return s.GetToken(StmtParserEVENT, 0)
}

func (s *KeywordsCanBeIdContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(StmtParserEVENTS, 0)
}

func (s *KeywordsCanBeIdContext) EVERY() antlr.TerminalNode {
	return s.GetToken(StmtParserEVERY, 0)
}

func (s *KeywordsCanBeIdContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(StmtParserEXCEPT, 0)
}

func (s *KeywordsCanBeIdContext) EXCHANGE() antlr.TerminalNode {
	return s.GetToken(StmtParserEXCHANGE, 0)
}

func (s *KeywordsCanBeIdContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(StmtParserEXCLUSIVE, 0)
}

func (s *KeywordsCanBeIdContext) EXPIRE() antlr.TerminalNode {
	return s.GetToken(StmtParserEXPIRE, 0)
}

func (s *KeywordsCanBeIdContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(StmtParserEXPORT, 0)
}

func (s *KeywordsCanBeIdContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(StmtParserEXTENDED, 0)
}

func (s *KeywordsCanBeIdContext) EXTENT_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserEXTENT_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) FAST() antlr.TerminalNode {
	return s.GetToken(StmtParserFAST, 0)
}

func (s *KeywordsCanBeIdContext) FAULTS() antlr.TerminalNode {
	return s.GetToken(StmtParserFAULTS, 0)
}

func (s *KeywordsCanBeIdContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(StmtParserFIELDS, 0)
}

func (s *KeywordsCanBeIdContext) FILE_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserFILE_BLOCK_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) FILTER() antlr.TerminalNode {
	return s.GetToken(StmtParserFILTER, 0)
}

func (s *KeywordsCanBeIdContext) FIREWALL_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserFIREWALL_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) FIREWALL_USER() antlr.TerminalNode {
	return s.GetToken(StmtParserFIREWALL_USER, 0)
}

func (s *KeywordsCanBeIdContext) FIRST() antlr.TerminalNode {
	return s.GetToken(StmtParserFIRST, 0)
}

func (s *KeywordsCanBeIdContext) FIXED() antlr.TerminalNode {
	return s.GetToken(StmtParserFIXED, 0)
}

func (s *KeywordsCanBeIdContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(StmtParserFLUSH, 0)
}

func (s *KeywordsCanBeIdContext) FOLLOWS() antlr.TerminalNode {
	return s.GetToken(StmtParserFOLLOWS, 0)
}

func (s *KeywordsCanBeIdContext) FOUND() antlr.TerminalNode {
	return s.GetToken(StmtParserFOUND, 0)
}

func (s *KeywordsCanBeIdContext) FULL() antlr.TerminalNode {
	return s.GetToken(StmtParserFULL, 0)
}

func (s *KeywordsCanBeIdContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(StmtParserFUNCTION, 0)
}

func (s *KeywordsCanBeIdContext) GENERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserGENERAL, 0)
}

func (s *KeywordsCanBeIdContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StmtParserGLOBAL, 0)
}

func (s *KeywordsCanBeIdContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(StmtParserGRANTS, 0)
}

func (s *KeywordsCanBeIdContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StmtParserGROUP, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(StmtParserGROUP_CONCAT, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_REPLICATION() antlr.TerminalNode {
	return s.GetToken(StmtParserGROUP_REPLICATION, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_REPLICATION_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserGROUP_REPLICATION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(StmtParserHANDLER, 0)
}

func (s *KeywordsCanBeIdContext) HASH() antlr.TerminalNode {
	return s.GetToken(StmtParserHASH, 0)
}

func (s *KeywordsCanBeIdContext) HELP() antlr.TerminalNode {
	return s.GetToken(StmtParserHELP, 0)
}

func (s *KeywordsCanBeIdContext) HOST() antlr.TerminalNode {
	return s.GetToken(StmtParserHOST, 0)
}

func (s *KeywordsCanBeIdContext) HOSTS() antlr.TerminalNode {
	return s.GetToken(StmtParserHOSTS, 0)
}

func (s *KeywordsCanBeIdContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(StmtParserIDENTIFIED, 0)
}

func (s *KeywordsCanBeIdContext) IGNORED() antlr.TerminalNode {
	return s.GetToken(StmtParserIGNORED, 0)
}

func (s *KeywordsCanBeIdContext) IGNORE_SERVER_IDS() antlr.TerminalNode {
	return s.GetToken(StmtParserIGNORE_SERVER_IDS, 0)
}

func (s *KeywordsCanBeIdContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(StmtParserIMPORT, 0)
}

func (s *KeywordsCanBeIdContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(StmtParserINDEXES, 0)
}

func (s *KeywordsCanBeIdContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserINITIAL_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(StmtParserINNODB_REDO_LOG_ARCHIVE, 0)
}

func (s *KeywordsCanBeIdContext) INPLACE() antlr.TerminalNode {
	return s.GetToken(StmtParserINPLACE, 0)
}

func (s *KeywordsCanBeIdContext) INSERT_METHOD() antlr.TerminalNode {
	return s.GetToken(StmtParserINSERT_METHOD, 0)
}

func (s *KeywordsCanBeIdContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(StmtParserINSTALL, 0)
}

func (s *KeywordsCanBeIdContext) INSTANCE() antlr.TerminalNode {
	return s.GetToken(StmtParserINSTANCE, 0)
}

func (s *KeywordsCanBeIdContext) INSTANT() antlr.TerminalNode {
	return s.GetToken(StmtParserINSTANT, 0)
}

func (s *KeywordsCanBeIdContext) INTERNAL() antlr.TerminalNode {
	return s.GetToken(StmtParserINTERNAL, 0)
}

func (s *KeywordsCanBeIdContext) INVOKE() antlr.TerminalNode {
	return s.GetToken(StmtParserINVOKE, 0)
}

func (s *KeywordsCanBeIdContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(StmtParserINVOKER, 0)
}

func (s *KeywordsCanBeIdContext) IO() antlr.TerminalNode {
	return s.GetToken(StmtParserIO, 0)
}

func (s *KeywordsCanBeIdContext) IO_THREAD() antlr.TerminalNode {
	return s.GetToken(StmtParserIO_THREAD, 0)
}

func (s *KeywordsCanBeIdContext) IPC() antlr.TerminalNode {
	return s.GetToken(StmtParserIPC, 0)
}

func (s *KeywordsCanBeIdContext) ISO() antlr.TerminalNode {
	return s.GetToken(StmtParserISO, 0)
}

func (s *KeywordsCanBeIdContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(StmtParserISOLATION, 0)
}

func (s *KeywordsCanBeIdContext) ISSUER() antlr.TerminalNode {
	return s.GetToken(StmtParserISSUER, 0)
}

func (s *KeywordsCanBeIdContext) JIS() antlr.TerminalNode {
	return s.GetToken(StmtParserJIS, 0)
}

func (s *KeywordsCanBeIdContext) JSON() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON, 0)
}

func (s *KeywordsCanBeIdContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY_BLOCK_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(StmtParserLAMBDA, 0)
}

func (s *KeywordsCanBeIdContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(StmtParserLANGUAGE, 0)
}

func (s *KeywordsCanBeIdContext) LAST() antlr.TerminalNode {
	return s.GetToken(StmtParserLAST, 0)
}

func (s *KeywordsCanBeIdContext) LEAVES() antlr.TerminalNode {
	return s.GetToken(StmtParserLEAVES, 0)
}

func (s *KeywordsCanBeIdContext) LESS() antlr.TerminalNode {
	return s.GetToken(StmtParserLESS, 0)
}

func (s *KeywordsCanBeIdContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(StmtParserLEVEL, 0)
}

func (s *KeywordsCanBeIdContext) LIST() antlr.TerminalNode {
	return s.GetToken(StmtParserLIST, 0)
}

func (s *KeywordsCanBeIdContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(StmtParserLOCAL, 0)
}

func (s *KeywordsCanBeIdContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(StmtParserLOGFILE, 0)
}

func (s *KeywordsCanBeIdContext) LOGS() antlr.TerminalNode {
	return s.GetToken(StmtParserLOGS, 0)
}

func (s *KeywordsCanBeIdContext) MASTER() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_AUTO_POSITION() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_AUTO_POSITION, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_CONNECT_RETRY() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_CONNECT_RETRY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_DELAY() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_DELAY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_HEARTBEAT_PERIOD() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_HEARTBEAT_PERIOD, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_HOST() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_HOST, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_LOG_FILE, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_LOG_POS() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_LOG_POS, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_PASSWORD() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_PASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_PORT() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_PORT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_RETRY_COUNT() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_RETRY_COUNT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_SSL, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CA() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_SSL_CA, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CAPATH() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_SSL_CAPATH, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CERT() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_SSL_CERT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CIPHER() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_SSL_CIPHER, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CRL() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_SSL_CRL, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CRLPATH() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_SSL_CRLPATH, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_SSL_KEY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_TLS_VERSION() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_TLS_VERSION, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_USER() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_USER, 0)
}

func (s *KeywordsCanBeIdContext) MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(StmtParserMAX_CONNECTIONS_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX_QUERIES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(StmtParserMAX_QUERIES_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX() antlr.TerminalNode {
	return s.GetToken(StmtParserMAX, 0)
}

func (s *KeywordsCanBeIdContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(StmtParserMAX_ROWS, 0)
}

func (s *KeywordsCanBeIdContext) MAX_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserMAX_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) MAX_UPDATES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(StmtParserMAX_UPDATES_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX_USER_CONNECTIONS() antlr.TerminalNode {
	return s.GetToken(StmtParserMAX_USER_CONNECTIONS, 0)
}

func (s *KeywordsCanBeIdContext) MEDIUM() antlr.TerminalNode {
	return s.GetToken(StmtParserMEDIUM, 0)
}

func (s *KeywordsCanBeIdContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(StmtParserMEMBER, 0)
}

func (s *KeywordsCanBeIdContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(StmtParserMEMORY, 0)
}

func (s *KeywordsCanBeIdContext) MERGE() antlr.TerminalNode {
	return s.GetToken(StmtParserMERGE, 0)
}

func (s *KeywordsCanBeIdContext) MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserMESSAGE_TEXT, 0)
}

func (s *KeywordsCanBeIdContext) MID() antlr.TerminalNode {
	return s.GetToken(StmtParserMID, 0)
}

func (s *KeywordsCanBeIdContext) MIGRATE() antlr.TerminalNode {
	return s.GetToken(StmtParserMIGRATE, 0)
}

func (s *KeywordsCanBeIdContext) MIN() antlr.TerminalNode {
	return s.GetToken(StmtParserMIN, 0)
}

func (s *KeywordsCanBeIdContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(StmtParserMIN_ROWS, 0)
}

func (s *KeywordsCanBeIdContext) MODE() antlr.TerminalNode {
	return s.GetToken(StmtParserMODE, 0)
}

func (s *KeywordsCanBeIdContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StmtParserMODIFY, 0)
}

func (s *KeywordsCanBeIdContext) MUTEX() antlr.TerminalNode {
	return s.GetToken(StmtParserMUTEX, 0)
}

func (s *KeywordsCanBeIdContext) MYSQL() antlr.TerminalNode {
	return s.GetToken(StmtParserMYSQL, 0)
}

func (s *KeywordsCanBeIdContext) MYSQL_ERRNO() antlr.TerminalNode {
	return s.GetToken(StmtParserMYSQL_ERRNO, 0)
}

func (s *KeywordsCanBeIdContext) NAME() antlr.TerminalNode {
	return s.GetToken(StmtParserNAME, 0)
}

func (s *KeywordsCanBeIdContext) NAMES() antlr.TerminalNode {
	return s.GetToken(StmtParserNAMES, 0)
}

func (s *KeywordsCanBeIdContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(StmtParserNCHAR, 0)
}

func (s *KeywordsCanBeIdContext) NDB_STORED_USER() antlr.TerminalNode {
	return s.GetToken(StmtParserNDB_STORED_USER, 0)
}

func (s *KeywordsCanBeIdContext) NEVER() antlr.TerminalNode {
	return s.GetToken(StmtParserNEVER, 0)
}

func (s *KeywordsCanBeIdContext) NEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserNEXT, 0)
}

func (s *KeywordsCanBeIdContext) NO() antlr.TerminalNode {
	return s.GetToken(StmtParserNO, 0)
}

func (s *KeywordsCanBeIdContext) NOCOPY() antlr.TerminalNode {
	return s.GetToken(StmtParserNOCOPY, 0)
}

func (s *KeywordsCanBeIdContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(StmtParserNODEGROUP, 0)
}

func (s *KeywordsCanBeIdContext) NONE() antlr.TerminalNode {
	return s.GetToken(StmtParserNONE, 0)
}

func (s *KeywordsCanBeIdContext) NOWAIT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOWAIT, 0)
}

func (s *KeywordsCanBeIdContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(StmtParserNUMBER, 0)
}

func (s *KeywordsCanBeIdContext) ODBC() antlr.TerminalNode {
	return s.GetToken(StmtParserODBC, 0)
}

func (s *KeywordsCanBeIdContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(StmtParserOFFLINE, 0)
}

func (s *KeywordsCanBeIdContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(StmtParserOFFSET, 0)
}

func (s *KeywordsCanBeIdContext) OF() antlr.TerminalNode {
	return s.GetToken(StmtParserOF, 0)
}

func (s *KeywordsCanBeIdContext) OJ() antlr.TerminalNode {
	return s.GetToken(StmtParserOJ, 0)
}

func (s *KeywordsCanBeIdContext) OLD_PASSWORD() antlr.TerminalNode {
	return s.GetToken(StmtParserOLD_PASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) ONE() antlr.TerminalNode {
	return s.GetToken(StmtParserONE, 0)
}

func (s *KeywordsCanBeIdContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(StmtParserONLINE, 0)
}

func (s *KeywordsCanBeIdContext) ONLY() antlr.TerminalNode {
	return s.GetToken(StmtParserONLY, 0)
}

func (s *KeywordsCanBeIdContext) OPEN() antlr.TerminalNode {
	return s.GetToken(StmtParserOPEN, 0)
}

func (s *KeywordsCanBeIdContext) OPTIMIZER_COSTS() antlr.TerminalNode {
	return s.GetToken(StmtParserOPTIMIZER_COSTS, 0)
}

func (s *KeywordsCanBeIdContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(StmtParserOPTIONAL, 0)
}

func (s *KeywordsCanBeIdContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(StmtParserOPTIONS, 0)
}

func (s *KeywordsCanBeIdContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StmtParserORDER, 0)
}

func (s *KeywordsCanBeIdContext) OWNER() antlr.TerminalNode {
	return s.GetToken(StmtParserOWNER, 0)
}

func (s *KeywordsCanBeIdContext) PACK_KEYS() antlr.TerminalNode {
	return s.GetToken(StmtParserPACK_KEYS, 0)
}

func (s *KeywordsCanBeIdContext) PAGE() antlr.TerminalNode {
	return s.GetToken(StmtParserPAGE, 0)
}

func (s *KeywordsCanBeIdContext) PARSER() antlr.TerminalNode {
	return s.GetToken(StmtParserPARSER, 0)
}

func (s *KeywordsCanBeIdContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTIAL, 0)
}

func (s *KeywordsCanBeIdContext) PARTITIONING() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTITIONING, 0)
}

func (s *KeywordsCanBeIdContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTITIONS, 0)
}

func (s *KeywordsCanBeIdContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(StmtParserPASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) PASSWORDLESS_USER_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserPASSWORDLESS_USER_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserPERSIST_RO_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) PHASE() antlr.TerminalNode {
	return s.GetToken(StmtParserPHASE, 0)
}

func (s *KeywordsCanBeIdContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(StmtParserPLUGINS, 0)
}

func (s *KeywordsCanBeIdContext) PLUGIN_DIR() antlr.TerminalNode {
	return s.GetToken(StmtParserPLUGIN_DIR, 0)
}

func (s *KeywordsCanBeIdContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(StmtParserPLUGIN, 0)
}

func (s *KeywordsCanBeIdContext) PORT() antlr.TerminalNode {
	return s.GetToken(StmtParserPORT, 0)
}

func (s *KeywordsCanBeIdContext) PRECEDES() antlr.TerminalNode {
	return s.GetToken(StmtParserPRECEDES, 0)
}

func (s *KeywordsCanBeIdContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(StmtParserPREPARE, 0)
}

func (s *KeywordsCanBeIdContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(StmtParserPRESERVE, 0)
}

func (s *KeywordsCanBeIdContext) PREV() antlr.TerminalNode {
	return s.GetToken(StmtParserPREV, 0)
}

func (s *KeywordsCanBeIdContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(StmtParserPRIMARY, 0)
}

func (s *KeywordsCanBeIdContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(StmtParserPROCESSLIST, 0)
}

func (s *KeywordsCanBeIdContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(StmtParserPROFILE, 0)
}

func (s *KeywordsCanBeIdContext) PROFILES() antlr.TerminalNode {
	return s.GetToken(StmtParserPROFILES, 0)
}

func (s *KeywordsCanBeIdContext) PROXY() antlr.TerminalNode {
	return s.GetToken(StmtParserPROXY, 0)
}

func (s *KeywordsCanBeIdContext) QUERY() antlr.TerminalNode {
	return s.GetToken(StmtParserQUERY, 0)
}

func (s *KeywordsCanBeIdContext) QUICK() antlr.TerminalNode {
	return s.GetToken(StmtParserQUICK, 0)
}

func (s *KeywordsCanBeIdContext) REBUILD() antlr.TerminalNode {
	return s.GetToken(StmtParserREBUILD, 0)
}

func (s *KeywordsCanBeIdContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(StmtParserRECOVER, 0)
}

func (s *KeywordsCanBeIdContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(StmtParserRECURSIVE, 0)
}

func (s *KeywordsCanBeIdContext) REDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserREDO_BUFFER_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) REDUNDANT() antlr.TerminalNode {
	return s.GetToken(StmtParserREDUNDANT, 0)
}

func (s *KeywordsCanBeIdContext) RELAY() antlr.TerminalNode {
	return s.GetToken(StmtParserRELAY, 0)
}

func (s *KeywordsCanBeIdContext) RELAYLOG() antlr.TerminalNode {
	return s.GetToken(StmtParserRELAYLOG, 0)
}

func (s *KeywordsCanBeIdContext) RELAY_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(StmtParserRELAY_LOG_FILE, 0)
}

func (s *KeywordsCanBeIdContext) RELAY_LOG_POS() antlr.TerminalNode {
	return s.GetToken(StmtParserRELAY_LOG_POS, 0)
}

func (s *KeywordsCanBeIdContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(StmtParserREMOVE, 0)
}

func (s *KeywordsCanBeIdContext) REORGANIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserREORGANIZE, 0)
}

func (s *KeywordsCanBeIdContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(StmtParserREPAIR, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_DO_DB() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATE_DO_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATE_DO_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_IGNORE_DB() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATE_IGNORE_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATE_IGNORE_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_REWRITE_DB() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATE_REWRITE_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_WILD_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATE_WILD_DO_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_WILD_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATE_WILD_IGNORE_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATION, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION_APPLIER() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATION_APPLIER, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION_SLAVE_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATION_SLAVE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) RESET() antlr.TerminalNode {
	return s.GetToken(StmtParserRESET, 0)
}

func (s *KeywordsCanBeIdContext) RESOURCE_GROUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserRESOURCE_GROUP_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) RESOURCE_GROUP_USER() antlr.TerminalNode {
	return s.GetToken(StmtParserRESOURCE_GROUP_USER, 0)
}

func (s *KeywordsCanBeIdContext) RESUME() antlr.TerminalNode {
	return s.GetToken(StmtParserRESUME, 0)
}

func (s *KeywordsCanBeIdContext) RETURNED_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(StmtParserRETURNED_SQLSTATE, 0)
}

func (s *KeywordsCanBeIdContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(StmtParserRETURNS, 0)
}

func (s *KeywordsCanBeIdContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StmtParserROLE, 0)
}

func (s *KeywordsCanBeIdContext) ROLE_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserROLE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(StmtParserROLLBACK, 0)
}

func (s *KeywordsCanBeIdContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(StmtParserROLLUP, 0)
}

func (s *KeywordsCanBeIdContext) ROTATE() antlr.TerminalNode {
	return s.GetToken(StmtParserROTATE, 0)
}

func (s *KeywordsCanBeIdContext) ROW() antlr.TerminalNode {
	return s.GetToken(StmtParserROW, 0)
}

func (s *KeywordsCanBeIdContext) ROWS() antlr.TerminalNode {
	return s.GetToken(StmtParserROWS, 0)
}

func (s *KeywordsCanBeIdContext) ROW_FORMAT() antlr.TerminalNode {
	return s.GetToken(StmtParserROW_FORMAT, 0)
}

func (s *KeywordsCanBeIdContext) RTREE() antlr.TerminalNode {
	return s.GetToken(StmtParserRTREE, 0)
}

func (s *KeywordsCanBeIdContext) S3() antlr.TerminalNode {
	return s.GetToken(StmtParserS3, 0)
}

func (s *KeywordsCanBeIdContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserSAVEPOINT, 0)
}

func (s *KeywordsCanBeIdContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(StmtParserSCHEDULE, 0)
}

func (s *KeywordsCanBeIdContext) SCHEMA_NAME() antlr.TerminalNode {
	return s.GetToken(StmtParserSCHEMA_NAME, 0)
}

func (s *KeywordsCanBeIdContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StmtParserSECURITY, 0)
}

func (s *KeywordsCanBeIdContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *KeywordsCanBeIdContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSERIAL, 0)
}

func (s *KeywordsCanBeIdContext) SERVER() antlr.TerminalNode {
	return s.GetToken(StmtParserSERVER, 0)
}

func (s *KeywordsCanBeIdContext) SESSION() antlr.TerminalNode {
	return s.GetToken(StmtParserSESSION, 0)
}

func (s *KeywordsCanBeIdContext) SESSION_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserSESSION_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) SET_USER_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserSET_USER_ID, 0)
}

func (s *KeywordsCanBeIdContext) SHARE() antlr.TerminalNode {
	return s.GetToken(StmtParserSHARE, 0)
}

func (s *KeywordsCanBeIdContext) SHARED() antlr.TerminalNode {
	return s.GetToken(StmtParserSHARED, 0)
}

func (s *KeywordsCanBeIdContext) SHOW_ROUTINE() antlr.TerminalNode {
	return s.GetToken(StmtParserSHOW_ROUTINE, 0)
}

func (s *KeywordsCanBeIdContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(StmtParserSIGNED, 0)
}

func (s *KeywordsCanBeIdContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(StmtParserSIMPLE, 0)
}

func (s *KeywordsCanBeIdContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(StmtParserSLAVE, 0)
}

func (s *KeywordsCanBeIdContext) SLOW() antlr.TerminalNode {
	return s.GetToken(StmtParserSLOW, 0)
}

func (s *KeywordsCanBeIdContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(StmtParserSNAPSHOT, 0)
}

func (s *KeywordsCanBeIdContext) SOCKET() antlr.TerminalNode {
	return s.GetToken(StmtParserSOCKET, 0)
}

func (s *KeywordsCanBeIdContext) SOME() antlr.TerminalNode {
	return s.GetToken(StmtParserSOME, 0)
}

func (s *KeywordsCanBeIdContext) SONAME() antlr.TerminalNode {
	return s.GetToken(StmtParserSONAME, 0)
}

func (s *KeywordsCanBeIdContext) SOUNDS() antlr.TerminalNode {
	return s.GetToken(StmtParserSOUNDS, 0)
}

func (s *KeywordsCanBeIdContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(StmtParserSOURCE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(StmtParserSQL_AFTER_GTIDS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_AFTER_MTS_GAPS() antlr.TerminalNode {
	return s.GetToken(StmtParserSQL_AFTER_MTS_GAPS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_BEFORE_GTIDS() antlr.TerminalNode {
	return s.GetToken(StmtParserSQL_BEFORE_GTIDS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_BUFFER_RESULT() antlr.TerminalNode {
	return s.GetToken(StmtParserSQL_BUFFER_RESULT, 0)
}

func (s *KeywordsCanBeIdContext) SQL_CACHE() antlr.TerminalNode {
	return s.GetToken(StmtParserSQL_CACHE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_NO_CACHE() antlr.TerminalNode {
	return s.GetToken(StmtParserSQL_NO_CACHE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_THREAD() antlr.TerminalNode {
	return s.GetToken(StmtParserSQL_THREAD, 0)
}

func (s *KeywordsCanBeIdContext) STACKED() antlr.TerminalNode {
	return s.GetToken(StmtParserSTACKED, 0)
}

func (s *KeywordsCanBeIdContext) START() antlr.TerminalNode {
	return s.GetToken(StmtParserSTART, 0)
}

func (s *KeywordsCanBeIdContext) STARTS() antlr.TerminalNode {
	return s.GetToken(StmtParserSTARTS, 0)
}

func (s *KeywordsCanBeIdContext) STATS_AUTO_RECALC() antlr.TerminalNode {
	return s.GetToken(StmtParserSTATS_AUTO_RECALC, 0)
}

func (s *KeywordsCanBeIdContext) STATS_PERSISTENT() antlr.TerminalNode {
	return s.GetToken(StmtParserSTATS_PERSISTENT, 0)
}

func (s *KeywordsCanBeIdContext) STATS_SAMPLE_PAGES() antlr.TerminalNode {
	return s.GetToken(StmtParserSTATS_SAMPLE_PAGES, 0)
}

func (s *KeywordsCanBeIdContext) STATUS() antlr.TerminalNode {
	return s.GetToken(StmtParserSTATUS, 0)
}

func (s *KeywordsCanBeIdContext) STD() antlr.TerminalNode {
	return s.GetToken(StmtParserSTD, 0)
}

func (s *KeywordsCanBeIdContext) STDDEV() antlr.TerminalNode {
	return s.GetToken(StmtParserSTDDEV, 0)
}

func (s *KeywordsCanBeIdContext) STDDEV_POP() antlr.TerminalNode {
	return s.GetToken(StmtParserSTDDEV_POP, 0)
}

func (s *KeywordsCanBeIdContext) STDDEV_SAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserSTDDEV_SAMP, 0)
}

func (s *KeywordsCanBeIdContext) STOP() antlr.TerminalNode {
	return s.GetToken(StmtParserSTOP, 0)
}

func (s *KeywordsCanBeIdContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StmtParserSTORAGE, 0)
}

func (s *KeywordsCanBeIdContext) STRING() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING, 0)
}

func (s *KeywordsCanBeIdContext) SUBCLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBCLASS_ORIGIN, 0)
}

func (s *KeywordsCanBeIdContext) SUBJECT() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBJECT, 0)
}

func (s *KeywordsCanBeIdContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBPARTITION, 0)
}

func (s *KeywordsCanBeIdContext) SUBPARTITIONS() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBPARTITIONS, 0)
}

func (s *KeywordsCanBeIdContext) SUM() antlr.TerminalNode {
	return s.GetToken(StmtParserSUM, 0)
}

func (s *KeywordsCanBeIdContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(StmtParserSUSPEND, 0)
}

func (s *KeywordsCanBeIdContext) SWAPS() antlr.TerminalNode {
	return s.GetToken(StmtParserSWAPS, 0)
}

func (s *KeywordsCanBeIdContext) SWITCHES() antlr.TerminalNode {
	return s.GetToken(StmtParserSWITCHES, 0)
}

func (s *KeywordsCanBeIdContext) SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserSYSTEM_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_NAME() antlr.TerminalNode {
	return s.GetToken(StmtParserTABLE_NAME, 0)
}

func (s *KeywordsCanBeIdContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(StmtParserTABLESPACE, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserTABLE_ENCRYPTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_TYPE() antlr.TerminalNode {
	return s.GetToken(StmtParserTABLE_TYPE, 0)
}

func (s *KeywordsCanBeIdContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StmtParserTEMPORARY, 0)
}

func (s *KeywordsCanBeIdContext) TEMPTABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserTEMPTABLE, 0)
}

func (s *KeywordsCanBeIdContext) THAN() antlr.TerminalNode {
	return s.GetToken(StmtParserTHAN, 0)
}

func (s *KeywordsCanBeIdContext) TRADITIONAL() antlr.TerminalNode {
	return s.GetToken(StmtParserTRADITIONAL, 0)
}

func (s *KeywordsCanBeIdContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(StmtParserTRANSACTION, 0)
}

func (s *KeywordsCanBeIdContext) TRANSACTIONAL() antlr.TerminalNode {
	return s.GetToken(StmtParserTRANSACTIONAL, 0)
}

func (s *KeywordsCanBeIdContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(StmtParserTRIGGERS, 0)
}

func (s *KeywordsCanBeIdContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(StmtParserTRUNCATE, 0)
}

func (s *KeywordsCanBeIdContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(StmtParserUNDEFINED, 0)
}

func (s *KeywordsCanBeIdContext) UNDOFILE() antlr.TerminalNode {
	return s.GetToken(StmtParserUNDOFILE, 0)
}

func (s *KeywordsCanBeIdContext) UNDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserUNDO_BUFFER_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(StmtParserUNINSTALL, 0)
}

func (s *KeywordsCanBeIdContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(StmtParserUNKNOWN, 0)
}

func (s *KeywordsCanBeIdContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(StmtParserUNTIL, 0)
}

func (s *KeywordsCanBeIdContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(StmtParserUPGRADE, 0)
}

func (s *KeywordsCanBeIdContext) USA() antlr.TerminalNode {
	return s.GetToken(StmtParserUSA, 0)
}

func (s *KeywordsCanBeIdContext) USER() antlr.TerminalNode {
	return s.GetToken(StmtParserUSER, 0)
}

func (s *KeywordsCanBeIdContext) USE_FRM() antlr.TerminalNode {
	return s.GetToken(StmtParserUSE_FRM, 0)
}

func (s *KeywordsCanBeIdContext) USER_RESOURCES() antlr.TerminalNode {
	return s.GetToken(StmtParserUSER_RESOURCES, 0)
}

func (s *KeywordsCanBeIdContext) VALIDATION() antlr.TerminalNode {
	return s.GetToken(StmtParserVALIDATION, 0)
}

func (s *KeywordsCanBeIdContext) VALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserVALUE, 0)
}

func (s *KeywordsCanBeIdContext) VAR_POP() antlr.TerminalNode {
	return s.GetToken(StmtParserVAR_POP, 0)
}

func (s *KeywordsCanBeIdContext) VAR_SAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserVAR_SAMP, 0)
}

func (s *KeywordsCanBeIdContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(StmtParserVARIABLES, 0)
}

func (s *KeywordsCanBeIdContext) VARIANCE() antlr.TerminalNode {
	return s.GetToken(StmtParserVARIANCE, 0)
}

func (s *KeywordsCanBeIdContext) VERSION_TOKEN_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserVERSION_TOKEN_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StmtParserVIEW, 0)
}

func (s *KeywordsCanBeIdContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(StmtParserVIRTUAL, 0)
}

func (s *KeywordsCanBeIdContext) WAIT() antlr.TerminalNode {
	return s.GetToken(StmtParserWAIT, 0)
}

func (s *KeywordsCanBeIdContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(StmtParserWARNINGS, 0)
}

func (s *KeywordsCanBeIdContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(StmtParserWITHOUT, 0)
}

func (s *KeywordsCanBeIdContext) WORK() antlr.TerminalNode {
	return s.GetToken(StmtParserWORK, 0)
}

func (s *KeywordsCanBeIdContext) WRAPPER() antlr.TerminalNode {
	return s.GetToken(StmtParserWRAPPER, 0)
}

func (s *KeywordsCanBeIdContext) X509() antlr.TerminalNode {
	return s.GetToken(StmtParserX509, 0)
}

func (s *KeywordsCanBeIdContext) XA() antlr.TerminalNode {
	return s.GetToken(StmtParserXA, 0)
}

func (s *KeywordsCanBeIdContext) XA_RECOVER_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserXA_RECOVER_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) XML() antlr.TerminalNode {
	return s.GetToken(StmtParserXML, 0)
}

func (s *KeywordsCanBeIdContext) VIA() antlr.TerminalNode {
	return s.GetToken(StmtParserVIA, 0)
}

func (s *KeywordsCanBeIdContext) LASTVAL() antlr.TerminalNode {
	return s.GetToken(StmtParserLASTVAL, 0)
}

func (s *KeywordsCanBeIdContext) NEXTVAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNEXTVAL, 0)
}

func (s *KeywordsCanBeIdContext) SETVAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSETVAL, 0)
}

func (s *KeywordsCanBeIdContext) PREVIOUS() antlr.TerminalNode {
	return s.GetToken(StmtParserPREVIOUS, 0)
}

func (s *KeywordsCanBeIdContext) PERSISTENT() antlr.TerminalNode {
	return s.GetToken(StmtParserPERSISTENT, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION_MASTER_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATION_MASTER_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICA, 0)
}

func (s *KeywordsCanBeIdContext) READ_ONLY_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserREAD_ONLY_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) FEDERATED_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserFEDERATED_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_MONITOR() antlr.TerminalNode {
	return s.GetToken(StmtParserBINLOG_MONITOR, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_REPLAY() antlr.TerminalNode {
	return s.GetToken(StmtParserBINLOG_REPLAY, 0)
}

func (s *KeywordsCanBeIdContext) SKIP_() antlr.TerminalNode {
	return s.GetToken(StmtParserSKIP_, 0)
}

func (s *KeywordsCanBeIdContext) LOCKED() antlr.TerminalNode {
	return s.GetToken(StmtParserLOCKED, 0)
}

func (s *KeywordsCanBeIdContext) CYCLE() antlr.TerminalNode {
	return s.GetToken(StmtParserCYCLE, 0)
}

func (s *KeywordsCanBeIdContext) INCREMENT() antlr.TerminalNode {
	return s.GetToken(StmtParserINCREMENT, 0)
}

func (s *KeywordsCanBeIdContext) MINVALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserMINVALUE, 0)
}

func (s *KeywordsCanBeIdContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserMAXVALUE, 0)
}

func (s *KeywordsCanBeIdContext) NOCACHE() antlr.TerminalNode {
	return s.GetToken(StmtParserNOCACHE, 0)
}

func (s *KeywordsCanBeIdContext) NOCYCLE() antlr.TerminalNode {
	return s.GetToken(StmtParserNOCYCLE, 0)
}

func (s *KeywordsCanBeIdContext) NOMINVALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserNOMINVALUE, 0)
}

func (s *KeywordsCanBeIdContext) NOMAXVALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserNOMAXVALUE, 0)
}

func (s *KeywordsCanBeIdContext) RESTART() antlr.TerminalNode {
	return s.GetToken(StmtParserRESTART, 0)
}

func (s *KeywordsCanBeIdContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(StmtParserSEQUENCE, 0)
}

func (s *KeywordsCanBeIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordsCanBeIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordsCanBeIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterKeywordsCanBeId(s)
	}
}

func (s *KeywordsCanBeIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitKeywordsCanBeId(s)
	}
}

func (p *StmtParser) KeywordsCanBeId() (localctx IKeywordsCanBeIdContext) {
	localctx = NewKeywordsCanBeIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, StmtParserRULE_keywordsCanBeId)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1572)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-17)) & ^0x3f) == 0 && ((int64(1)<<(_la-17))&585468501859368961) != 0) || ((int64((_la-100)) & ^0x3f) == 0 && ((int64(1)<<(_la-100))&-9214364837531737919) != 0) || ((int64((_la-233)) & ^0x3f) == 0 && ((int64(1)<<(_la-233))&-9002150297346244607) != 0) || ((int64((_la-297)) & ^0x3f) == 0 && ((int64(1)<<(_la-297))&-67108737) != 0) || ((int64((_la-361)) & ^0x3f) == 0 && ((int64(1)<<(_la-361))&-1152921504606846977) != 0) || ((int64((_la-425)) & ^0x3f) == 0 && ((int64(1)<<(_la-425))&-2097153) != 0) || ((int64((_la-489)) & ^0x3f) == 0 && ((int64(1)<<(_la-489))&-18014398509481985) != 0) || ((int64((_la-553)) & ^0x3f) == 0 && ((int64(1)<<(_la-553))&-16777217) != 0) || ((int64((_la-617)) & ^0x3f) == 0 && ((int64(1)<<(_la-617))&35460899254829047) != 0) || ((int64((_la-690)) & ^0x3f) == 0 && ((int64(1)<<(_la-690))&68450968063) != 0) || _la == StmtParserMEMORY || _la == StmtParserCATALOG_NAME || _la == StmtParserENGINE_ATTRIBUTE || _la == StmtParserSECONDARY_ENGINE_ATTRIBUTE || _la == StmtParserSCHEMA_NAME || ((int64((_la-1086)) & ^0x3f) == 0 && ((int64(1)<<(_la-1086))&4095) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionNameBaseContext is an interface to support dynamic dispatch.
type IFunctionNameBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABS() antlr.TerminalNode
	ACOS() antlr.TerminalNode
	ADDDATE() antlr.TerminalNode
	ADDTIME() antlr.TerminalNode
	AES_DECRYPT() antlr.TerminalNode
	AES_ENCRYPT() antlr.TerminalNode
	AREA() antlr.TerminalNode
	ASBINARY() antlr.TerminalNode
	ASIN() antlr.TerminalNode
	ASTEXT() antlr.TerminalNode
	ASWKB() antlr.TerminalNode
	ASWKT() antlr.TerminalNode
	ASYMMETRIC_DECRYPT() antlr.TerminalNode
	ASYMMETRIC_DERIVE() antlr.TerminalNode
	ASYMMETRIC_ENCRYPT() antlr.TerminalNode
	ASYMMETRIC_SIGN() antlr.TerminalNode
	ASYMMETRIC_VERIFY() antlr.TerminalNode
	ATAN() antlr.TerminalNode
	ATAN2() antlr.TerminalNode
	BENCHMARK() antlr.TerminalNode
	BIN() antlr.TerminalNode
	BIT_COUNT() antlr.TerminalNode
	BIT_LENGTH() antlr.TerminalNode
	BUFFER() antlr.TerminalNode
	CEIL() antlr.TerminalNode
	CEILING() antlr.TerminalNode
	CENTROID() antlr.TerminalNode
	CHARACTER_LENGTH() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHAR_LENGTH() antlr.TerminalNode
	COERCIBILITY() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	COMPRESS() antlr.TerminalNode
	CONCAT() antlr.TerminalNode
	CONCAT_WS() antlr.TerminalNode
	CONNECTION_ID() antlr.TerminalNode
	CONV() antlr.TerminalNode
	CONVERT_TZ() antlr.TerminalNode
	COS() antlr.TerminalNode
	COT() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CRC32() antlr.TerminalNode
	CREATE_ASYMMETRIC_PRIV_KEY() antlr.TerminalNode
	CREATE_ASYMMETRIC_PUB_KEY() antlr.TerminalNode
	CREATE_DH_PARAMETERS() antlr.TerminalNode
	CREATE_DIGEST() antlr.TerminalNode
	CROSSES() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATEDIFF() antlr.TerminalNode
	DATE_FORMAT() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DAYNAME() antlr.TerminalNode
	DAYOFMONTH() antlr.TerminalNode
	DAYOFWEEK() antlr.TerminalNode
	DAYOFYEAR() antlr.TerminalNode
	DECODE() antlr.TerminalNode
	DEGREES() antlr.TerminalNode
	DENSE_RANK() antlr.TerminalNode
	DES_DECRYPT() antlr.TerminalNode
	DES_ENCRYPT() antlr.TerminalNode
	DIMENSION() antlr.TerminalNode
	DISJOINT() antlr.TerminalNode
	ELT() antlr.TerminalNode
	ENCODE() antlr.TerminalNode
	ENCRYPT() antlr.TerminalNode
	ENDPOINT() antlr.TerminalNode
	ENVELOPE() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	EXP() antlr.TerminalNode
	EXPORT_SET() antlr.TerminalNode
	EXTERIORRING() antlr.TerminalNode
	EXTRACTVALUE() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	FIND_IN_SET() antlr.TerminalNode
	FIRST_VALUE() antlr.TerminalNode
	FLOOR() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FOUND_ROWS() antlr.TerminalNode
	FROM_BASE64() antlr.TerminalNode
	FROM_DAYS() antlr.TerminalNode
	FROM_UNIXTIME() antlr.TerminalNode
	GEOMCOLLFROMTEXT() antlr.TerminalNode
	GEOMCOLLFROMWKB() antlr.TerminalNode
	GEOMETRYCOLLECTION() antlr.TerminalNode
	GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode
	GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode
	GEOMETRYFROMTEXT() antlr.TerminalNode
	GEOMETRYFROMWKB() antlr.TerminalNode
	GEOMETRYN() antlr.TerminalNode
	GEOMETRYTYPE() antlr.TerminalNode
	GEOMFROMTEXT() antlr.TerminalNode
	GEOMFROMWKB() antlr.TerminalNode
	GET_FORMAT() antlr.TerminalNode
	GET_LOCK() antlr.TerminalNode
	GLENGTH() antlr.TerminalNode
	GREATEST() antlr.TerminalNode
	GTID_SUBSET() antlr.TerminalNode
	GTID_SUBTRACT() antlr.TerminalNode
	HEX() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	IFNULL() antlr.TerminalNode
	INET6_ATON() antlr.TerminalNode
	INET6_NTOA() antlr.TerminalNode
	INET_ATON() antlr.TerminalNode
	INET_NTOA() antlr.TerminalNode
	INSTR() antlr.TerminalNode
	INTERIORRINGN() antlr.TerminalNode
	INTERSECTS() antlr.TerminalNode
	INVISIBLE() antlr.TerminalNode
	ISCLOSED() antlr.TerminalNode
	ISEMPTY() antlr.TerminalNode
	ISNULL() antlr.TerminalNode
	ISSIMPLE() antlr.TerminalNode
	IS_FREE_LOCK() antlr.TerminalNode
	IS_IPV4() antlr.TerminalNode
	IS_IPV4_COMPAT() antlr.TerminalNode
	IS_IPV4_MAPPED() antlr.TerminalNode
	IS_IPV6() antlr.TerminalNode
	IS_USED_LOCK() antlr.TerminalNode
	LAG() antlr.TerminalNode
	LAST_INSERT_ID() antlr.TerminalNode
	LAST_VALUE() antlr.TerminalNode
	LCASE() antlr.TerminalNode
	LEAD() antlr.TerminalNode
	LEAST() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LENGTH() antlr.TerminalNode
	LINEFROMTEXT() antlr.TerminalNode
	LINEFROMWKB() antlr.TerminalNode
	LINESTRING() antlr.TerminalNode
	LINESTRINGFROMTEXT() antlr.TerminalNode
	LINESTRINGFROMWKB() antlr.TerminalNode
	LN() antlr.TerminalNode
	LOAD_FILE() antlr.TerminalNode
	LOCATE() antlr.TerminalNode
	LOG() antlr.TerminalNode
	LOG10() antlr.TerminalNode
	LOG2() antlr.TerminalNode
	LOWER() antlr.TerminalNode
	LPAD() antlr.TerminalNode
	LTRIM() antlr.TerminalNode
	MAKEDATE() antlr.TerminalNode
	MAKETIME() antlr.TerminalNode
	MAKE_SET() antlr.TerminalNode
	MASTER_POS_WAIT() antlr.TerminalNode
	MBRCONTAINS() antlr.TerminalNode
	MBRDISJOINT() antlr.TerminalNode
	MBREQUAL() antlr.TerminalNode
	MBRINTERSECTS() antlr.TerminalNode
	MBROVERLAPS() antlr.TerminalNode
	MBRTOUCHES() antlr.TerminalNode
	MBRWITHIN() antlr.TerminalNode
	MD5() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MLINEFROMTEXT() antlr.TerminalNode
	MLINEFROMWKB() antlr.TerminalNode
	MOD() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	MONTHNAME() antlr.TerminalNode
	MPOINTFROMTEXT() antlr.TerminalNode
	MPOINTFROMWKB() antlr.TerminalNode
	MPOLYFROMTEXT() antlr.TerminalNode
	MPOLYFROMWKB() antlr.TerminalNode
	MULTILINESTRING() antlr.TerminalNode
	MULTILINESTRINGFROMTEXT() antlr.TerminalNode
	MULTILINESTRINGFROMWKB() antlr.TerminalNode
	MULTIPOINT() antlr.TerminalNode
	MULTIPOINTFROMTEXT() antlr.TerminalNode
	MULTIPOINTFROMWKB() antlr.TerminalNode
	MULTIPOLYGON() antlr.TerminalNode
	MULTIPOLYGONFROMTEXT() antlr.TerminalNode
	MULTIPOLYGONFROMWKB() antlr.TerminalNode
	NAME_CONST() antlr.TerminalNode
	NTH_VALUE() antlr.TerminalNode
	NTILE() antlr.TerminalNode
	NULLIF() antlr.TerminalNode
	NUMGEOMETRIES() antlr.TerminalNode
	NUMINTERIORRINGS() antlr.TerminalNode
	NUMPOINTS() antlr.TerminalNode
	OCT() antlr.TerminalNode
	OCTET_LENGTH() antlr.TerminalNode
	ORD() antlr.TerminalNode
	OVERLAPS() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	PERIOD_ADD() antlr.TerminalNode
	PERIOD_DIFF() antlr.TerminalNode
	PI() antlr.TerminalNode
	POINT() antlr.TerminalNode
	POINTFROMTEXT() antlr.TerminalNode
	POINTFROMWKB() antlr.TerminalNode
	POINTN() antlr.TerminalNode
	POLYFROMTEXT() antlr.TerminalNode
	POLYFROMWKB() antlr.TerminalNode
	POLYGON() antlr.TerminalNode
	POLYGONFROMTEXT() antlr.TerminalNode
	POLYGONFROMWKB() antlr.TerminalNode
	POSITION() antlr.TerminalNode
	POW() antlr.TerminalNode
	POWER() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	QUOTE() antlr.TerminalNode
	RADIANS() antlr.TerminalNode
	RAND() antlr.TerminalNode
	RANK() antlr.TerminalNode
	RANDOM_BYTES() antlr.TerminalNode
	RELEASE_LOCK() antlr.TerminalNode
	REVERSE() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	ROUND() antlr.TerminalNode
	ROW_COUNT() antlr.TerminalNode
	ROW_NUMBER() antlr.TerminalNode
	RPAD() antlr.TerminalNode
	RTRIM() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SEC_TO_TIME() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	SESSION_USER() antlr.TerminalNode
	SESSION_VARIABLES_ADMIN() antlr.TerminalNode
	SHA() antlr.TerminalNode
	SHA1() antlr.TerminalNode
	SHA2() antlr.TerminalNode
	SIGN() antlr.TerminalNode
	SIN() antlr.TerminalNode
	SLEEP() antlr.TerminalNode
	SOUNDEX() antlr.TerminalNode
	SQL_THREAD_WAIT_AFTER_GTIDS() antlr.TerminalNode
	SQRT() antlr.TerminalNode
	SRID() antlr.TerminalNode
	STARTPOINT() antlr.TerminalNode
	STRCMP() antlr.TerminalNode
	STR_TO_DATE() antlr.TerminalNode
	ST_AREA() antlr.TerminalNode
	ST_ASBINARY() antlr.TerminalNode
	ST_ASTEXT() antlr.TerminalNode
	ST_ASWKB() antlr.TerminalNode
	ST_ASWKT() antlr.TerminalNode
	ST_BUFFER() antlr.TerminalNode
	ST_CENTROID() antlr.TerminalNode
	ST_CONTAINS() antlr.TerminalNode
	ST_CROSSES() antlr.TerminalNode
	ST_DIFFERENCE() antlr.TerminalNode
	ST_DIMENSION() antlr.TerminalNode
	ST_DISJOINT() antlr.TerminalNode
	ST_DISTANCE() antlr.TerminalNode
	ST_ENDPOINT() antlr.TerminalNode
	ST_ENVELOPE() antlr.TerminalNode
	ST_EQUALS() antlr.TerminalNode
	ST_EXTERIORRING() antlr.TerminalNode
	ST_GEOMCOLLFROMTEXT() antlr.TerminalNode
	ST_GEOMCOLLFROMTXT() antlr.TerminalNode
	ST_GEOMCOLLFROMWKB() antlr.TerminalNode
	ST_GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode
	ST_GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode
	ST_GEOMETRYFROMTEXT() antlr.TerminalNode
	ST_GEOMETRYFROMWKB() antlr.TerminalNode
	ST_GEOMETRYN() antlr.TerminalNode
	ST_GEOMETRYTYPE() antlr.TerminalNode
	ST_GEOMFROMTEXT() antlr.TerminalNode
	ST_GEOMFROMWKB() antlr.TerminalNode
	ST_INTERIORRINGN() antlr.TerminalNode
	ST_INTERSECTION() antlr.TerminalNode
	ST_INTERSECTS() antlr.TerminalNode
	ST_ISCLOSED() antlr.TerminalNode
	ST_ISEMPTY() antlr.TerminalNode
	ST_ISSIMPLE() antlr.TerminalNode
	ST_LINEFROMTEXT() antlr.TerminalNode
	ST_LINEFROMWKB() antlr.TerminalNode
	ST_LINESTRINGFROMTEXT() antlr.TerminalNode
	ST_LINESTRINGFROMWKB() antlr.TerminalNode
	ST_NUMGEOMETRIES() antlr.TerminalNode
	ST_NUMINTERIORRING() antlr.TerminalNode
	ST_NUMINTERIORRINGS() antlr.TerminalNode
	ST_NUMPOINTS() antlr.TerminalNode
	ST_OVERLAPS() antlr.TerminalNode
	ST_POINTFROMTEXT() antlr.TerminalNode
	ST_POINTFROMWKB() antlr.TerminalNode
	ST_POINTN() antlr.TerminalNode
	ST_POLYFROMTEXT() antlr.TerminalNode
	ST_POLYFROMWKB() antlr.TerminalNode
	ST_POLYGONFROMTEXT() antlr.TerminalNode
	ST_POLYGONFROMWKB() antlr.TerminalNode
	ST_SRID() antlr.TerminalNode
	ST_STARTPOINT() antlr.TerminalNode
	ST_SYMDIFFERENCE() antlr.TerminalNode
	ST_TOUCHES() antlr.TerminalNode
	ST_UNION() antlr.TerminalNode
	ST_WITHIN() antlr.TerminalNode
	ST_X() antlr.TerminalNode
	ST_Y() antlr.TerminalNode
	SUBDATE() antlr.TerminalNode
	SUBSTRING_INDEX() antlr.TerminalNode
	SUBTIME() antlr.TerminalNode
	SYSTEM_USER() antlr.TerminalNode
	TAN() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMEDIFF() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TIMESTAMPADD() antlr.TerminalNode
	TIMESTAMPDIFF() antlr.TerminalNode
	TIME_FORMAT() antlr.TerminalNode
	TIME_TO_SEC() antlr.TerminalNode
	TOUCHES() antlr.TerminalNode
	TO_BASE64() antlr.TerminalNode
	TO_DAYS() antlr.TerminalNode
	TO_SECONDS() antlr.TerminalNode
	UCASE() antlr.TerminalNode
	UNCOMPRESS() antlr.TerminalNode
	UNCOMPRESSED_LENGTH() antlr.TerminalNode
	UNHEX() antlr.TerminalNode
	UNIX_TIMESTAMP() antlr.TerminalNode
	UPDATEXML() antlr.TerminalNode
	UPPER() antlr.TerminalNode
	UUID() antlr.TerminalNode
	UUID_SHORT() antlr.TerminalNode
	VALIDATE_PASSWORD_STRENGTH() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	VISIBLE() antlr.TerminalNode
	WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	WEEKDAY() antlr.TerminalNode
	WEEKOFYEAR() antlr.TerminalNode
	WEIGHT_STRING() antlr.TerminalNode
	WITHIN() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	YEARWEEK() antlr.TerminalNode
	Y_FUNCTION() antlr.TerminalNode
	X_FUNCTION() antlr.TerminalNode
	JSON_ARRAY() antlr.TerminalNode
	JSON_OBJECT() antlr.TerminalNode
	JSON_QUOTE() antlr.TerminalNode
	JSON_CONTAINS() antlr.TerminalNode
	JSON_CONTAINS_PATH() antlr.TerminalNode
	JSON_EXTRACT() antlr.TerminalNode
	JSON_KEYS() antlr.TerminalNode
	JSON_OVERLAPS() antlr.TerminalNode
	JSON_SEARCH() antlr.TerminalNode
	JSON_VALUE() antlr.TerminalNode
	JSON_ARRAY_APPEND() antlr.TerminalNode
	JSON_ARRAY_INSERT() antlr.TerminalNode
	JSON_INSERT() antlr.TerminalNode
	JSON_MERGE() antlr.TerminalNode
	JSON_MERGE_PATCH() antlr.TerminalNode
	JSON_MERGE_PRESERVE() antlr.TerminalNode
	JSON_REMOVE() antlr.TerminalNode
	JSON_REPLACE() antlr.TerminalNode
	JSON_SET() antlr.TerminalNode
	JSON_UNQUOTE() antlr.TerminalNode
	JSON_DEPTH() antlr.TerminalNode
	JSON_LENGTH() antlr.TerminalNode
	JSON_TYPE() antlr.TerminalNode
	JSON_VALID() antlr.TerminalNode
	JSON_TABLE() antlr.TerminalNode
	JSON_SCHEMA_VALID() antlr.TerminalNode
	JSON_SCHEMA_VALIDATION_REPORT() antlr.TerminalNode
	JSON_PRETTY() antlr.TerminalNode
	JSON_STORAGE_FREE() antlr.TerminalNode
	JSON_STORAGE_SIZE() antlr.TerminalNode
	JSON_ARRAYAGG() antlr.TerminalNode
	JSON_OBJECTAGG() antlr.TerminalNode
	LASTVAL() antlr.TerminalNode
	NEXTVAL() antlr.TerminalNode
	SETVAL() antlr.TerminalNode

	// IsFunctionNameBaseContext differentiates from other interfaces.
	IsFunctionNameBaseContext()
}

type FunctionNameBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameBaseContext() *FunctionNameBaseContext {
	var p = new(FunctionNameBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_functionNameBase
	return p
}

func InitEmptyFunctionNameBaseContext(p *FunctionNameBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StmtParserRULE_functionNameBase
}

func (*FunctionNameBaseContext) IsFunctionNameBaseContext() {}

func NewFunctionNameBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameBaseContext {
	var p = new(FunctionNameBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_functionNameBase

	return p
}

func (s *FunctionNameBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameBaseContext) ABS() antlr.TerminalNode {
	return s.GetToken(StmtParserABS, 0)
}

func (s *FunctionNameBaseContext) ACOS() antlr.TerminalNode {
	return s.GetToken(StmtParserACOS, 0)
}

func (s *FunctionNameBaseContext) ADDDATE() antlr.TerminalNode {
	return s.GetToken(StmtParserADDDATE, 0)
}

func (s *FunctionNameBaseContext) ADDTIME() antlr.TerminalNode {
	return s.GetToken(StmtParserADDTIME, 0)
}

func (s *FunctionNameBaseContext) AES_DECRYPT() antlr.TerminalNode {
	return s.GetToken(StmtParserAES_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) AES_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(StmtParserAES_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) AREA() antlr.TerminalNode {
	return s.GetToken(StmtParserAREA, 0)
}

func (s *FunctionNameBaseContext) ASBINARY() antlr.TerminalNode {
	return s.GetToken(StmtParserASBINARY, 0)
}

func (s *FunctionNameBaseContext) ASIN() antlr.TerminalNode {
	return s.GetToken(StmtParserASIN, 0)
}

func (s *FunctionNameBaseContext) ASTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserASTEXT, 0)
}

func (s *FunctionNameBaseContext) ASWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserASWKB, 0)
}

func (s *FunctionNameBaseContext) ASWKT() antlr.TerminalNode {
	return s.GetToken(StmtParserASWKT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_DECRYPT() antlr.TerminalNode {
	return s.GetToken(StmtParserASYMMETRIC_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_DERIVE() antlr.TerminalNode {
	return s.GetToken(StmtParserASYMMETRIC_DERIVE, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(StmtParserASYMMETRIC_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_SIGN() antlr.TerminalNode {
	return s.GetToken(StmtParserASYMMETRIC_SIGN, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_VERIFY() antlr.TerminalNode {
	return s.GetToken(StmtParserASYMMETRIC_VERIFY, 0)
}

func (s *FunctionNameBaseContext) ATAN() antlr.TerminalNode {
	return s.GetToken(StmtParserATAN, 0)
}

func (s *FunctionNameBaseContext) ATAN2() antlr.TerminalNode {
	return s.GetToken(StmtParserATAN2, 0)
}

func (s *FunctionNameBaseContext) BENCHMARK() antlr.TerminalNode {
	return s.GetToken(StmtParserBENCHMARK, 0)
}

func (s *FunctionNameBaseContext) BIN() antlr.TerminalNode {
	return s.GetToken(StmtParserBIN, 0)
}

func (s *FunctionNameBaseContext) BIT_COUNT() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_COUNT, 0)
}

func (s *FunctionNameBaseContext) BIT_LENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_LENGTH, 0)
}

func (s *FunctionNameBaseContext) BUFFER() antlr.TerminalNode {
	return s.GetToken(StmtParserBUFFER, 0)
}

func (s *FunctionNameBaseContext) CEIL() antlr.TerminalNode {
	return s.GetToken(StmtParserCEIL, 0)
}

func (s *FunctionNameBaseContext) CEILING() antlr.TerminalNode {
	return s.GetToken(StmtParserCEILING, 0)
}

func (s *FunctionNameBaseContext) CENTROID() antlr.TerminalNode {
	return s.GetToken(StmtParserCENTROID, 0)
}

func (s *FunctionNameBaseContext) CHARACTER_LENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserCHARACTER_LENGTH, 0)
}

func (s *FunctionNameBaseContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(StmtParserCHARSET, 0)
}

func (s *FunctionNameBaseContext) CHAR_LENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserCHAR_LENGTH, 0)
}

func (s *FunctionNameBaseContext) COERCIBILITY() antlr.TerminalNode {
	return s.GetToken(StmtParserCOERCIBILITY, 0)
}

func (s *FunctionNameBaseContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLLATION, 0)
}

func (s *FunctionNameBaseContext) COMPRESS() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMPRESS, 0)
}

func (s *FunctionNameBaseContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONCAT, 0)
}

func (s *FunctionNameBaseContext) CONCAT_WS() antlr.TerminalNode {
	return s.GetToken(StmtParserCONCAT_WS, 0)
}

func (s *FunctionNameBaseContext) CONNECTION_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserCONNECTION_ID, 0)
}

func (s *FunctionNameBaseContext) CONV() antlr.TerminalNode {
	return s.GetToken(StmtParserCONV, 0)
}

func (s *FunctionNameBaseContext) CONVERT_TZ() antlr.TerminalNode {
	return s.GetToken(StmtParserCONVERT_TZ, 0)
}

func (s *FunctionNameBaseContext) COS() antlr.TerminalNode {
	return s.GetToken(StmtParserCOS, 0)
}

func (s *FunctionNameBaseContext) COT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOT, 0)
}

func (s *FunctionNameBaseContext) COUNT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOUNT, 0)
}

func (s *FunctionNameBaseContext) CRC32() antlr.TerminalNode {
	return s.GetToken(StmtParserCRC32, 0)
}

func (s *FunctionNameBaseContext) CREATE_ASYMMETRIC_PRIV_KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserCREATE_ASYMMETRIC_PRIV_KEY, 0)
}

func (s *FunctionNameBaseContext) CREATE_ASYMMETRIC_PUB_KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserCREATE_ASYMMETRIC_PUB_KEY, 0)
}

func (s *FunctionNameBaseContext) CREATE_DH_PARAMETERS() antlr.TerminalNode {
	return s.GetToken(StmtParserCREATE_DH_PARAMETERS, 0)
}

func (s *FunctionNameBaseContext) CREATE_DIGEST() antlr.TerminalNode {
	return s.GetToken(StmtParserCREATE_DIGEST, 0)
}

func (s *FunctionNameBaseContext) CROSSES() antlr.TerminalNode {
	return s.GetToken(StmtParserCROSSES, 0)
}

func (s *FunctionNameBaseContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(StmtParserCUME_DIST, 0)
}

func (s *FunctionNameBaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StmtParserDATABASE, 0)
}

func (s *FunctionNameBaseContext) DATE() antlr.TerminalNode {
	return s.GetToken(StmtParserDATE, 0)
}

func (s *FunctionNameBaseContext) DATEDIFF() antlr.TerminalNode {
	return s.GetToken(StmtParserDATEDIFF, 0)
}

func (s *FunctionNameBaseContext) DATE_FORMAT() antlr.TerminalNode {
	return s.GetToken(StmtParserDATE_FORMAT, 0)
}

func (s *FunctionNameBaseContext) DAY() antlr.TerminalNode {
	return s.GetToken(StmtParserDAY, 0)
}

func (s *FunctionNameBaseContext) DAYNAME() antlr.TerminalNode {
	return s.GetToken(StmtParserDAYNAME, 0)
}

func (s *FunctionNameBaseContext) DAYOFMONTH() antlr.TerminalNode {
	return s.GetToken(StmtParserDAYOFMONTH, 0)
}

func (s *FunctionNameBaseContext) DAYOFWEEK() antlr.TerminalNode {
	return s.GetToken(StmtParserDAYOFWEEK, 0)
}

func (s *FunctionNameBaseContext) DAYOFYEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserDAYOFYEAR, 0)
}

func (s *FunctionNameBaseContext) DECODE() antlr.TerminalNode {
	return s.GetToken(StmtParserDECODE, 0)
}

func (s *FunctionNameBaseContext) DEGREES() antlr.TerminalNode {
	return s.GetToken(StmtParserDEGREES, 0)
}

func (s *FunctionNameBaseContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(StmtParserDENSE_RANK, 0)
}

func (s *FunctionNameBaseContext) DES_DECRYPT() antlr.TerminalNode {
	return s.GetToken(StmtParserDES_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) DES_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(StmtParserDES_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) DIMENSION() antlr.TerminalNode {
	return s.GetToken(StmtParserDIMENSION, 0)
}

func (s *FunctionNameBaseContext) DISJOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserDISJOINT, 0)
}

func (s *FunctionNameBaseContext) ELT() antlr.TerminalNode {
	return s.GetToken(StmtParserELT, 0)
}

func (s *FunctionNameBaseContext) ENCODE() antlr.TerminalNode {
	return s.GetToken(StmtParserENCODE, 0)
}

func (s *FunctionNameBaseContext) ENCRYPT() antlr.TerminalNode {
	return s.GetToken(StmtParserENCRYPT, 0)
}

func (s *FunctionNameBaseContext) ENDPOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserENDPOINT, 0)
}

func (s *FunctionNameBaseContext) ENVELOPE() antlr.TerminalNode {
	return s.GetToken(StmtParserENVELOPE, 0)
}

func (s *FunctionNameBaseContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUALS, 0)
}

func (s *FunctionNameBaseContext) EXP() antlr.TerminalNode {
	return s.GetToken(StmtParserEXP, 0)
}

func (s *FunctionNameBaseContext) EXPORT_SET() antlr.TerminalNode {
	return s.GetToken(StmtParserEXPORT_SET, 0)
}

func (s *FunctionNameBaseContext) EXTERIORRING() antlr.TerminalNode {
	return s.GetToken(StmtParserEXTERIORRING, 0)
}

func (s *FunctionNameBaseContext) EXTRACTVALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserEXTRACTVALUE, 0)
}

func (s *FunctionNameBaseContext) FIELD() antlr.TerminalNode {
	return s.GetToken(StmtParserFIELD, 0)
}

func (s *FunctionNameBaseContext) FIND_IN_SET() antlr.TerminalNode {
	return s.GetToken(StmtParserFIND_IN_SET, 0)
}

func (s *FunctionNameBaseContext) FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserFIRST_VALUE, 0)
}

func (s *FunctionNameBaseContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(StmtParserFLOOR, 0)
}

func (s *FunctionNameBaseContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(StmtParserFORMAT, 0)
}

func (s *FunctionNameBaseContext) FOUND_ROWS() antlr.TerminalNode {
	return s.GetToken(StmtParserFOUND_ROWS, 0)
}

func (s *FunctionNameBaseContext) FROM_BASE64() antlr.TerminalNode {
	return s.GetToken(StmtParserFROM_BASE64, 0)
}

func (s *FunctionNameBaseContext) FROM_DAYS() antlr.TerminalNode {
	return s.GetToken(StmtParserFROM_DAYS, 0)
}

func (s *FunctionNameBaseContext) FROM_UNIXTIME() antlr.TerminalNode {
	return s.GetToken(StmtParserFROM_UNIXTIME, 0)
}

func (s *FunctionNameBaseContext) GEOMCOLLFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMCOLLFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMCOLLFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMCOLLFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTION() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMETRYCOLLECTION, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMETRYCOLLECTIONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMETRYCOLLECTIONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMETRYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMETRYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYN() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMETRYN, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYTYPE() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMETRYTYPE, 0)
}

func (s *FunctionNameBaseContext) GEOMFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GET_FORMAT() antlr.TerminalNode {
	return s.GetToken(StmtParserGET_FORMAT, 0)
}

func (s *FunctionNameBaseContext) GET_LOCK() antlr.TerminalNode {
	return s.GetToken(StmtParserGET_LOCK, 0)
}

func (s *FunctionNameBaseContext) GLENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserGLENGTH, 0)
}

func (s *FunctionNameBaseContext) GREATEST() antlr.TerminalNode {
	return s.GetToken(StmtParserGREATEST, 0)
}

func (s *FunctionNameBaseContext) GTID_SUBSET() antlr.TerminalNode {
	return s.GetToken(StmtParserGTID_SUBSET, 0)
}

func (s *FunctionNameBaseContext) GTID_SUBTRACT() antlr.TerminalNode {
	return s.GetToken(StmtParserGTID_SUBTRACT, 0)
}

func (s *FunctionNameBaseContext) HEX() antlr.TerminalNode {
	return s.GetToken(StmtParserHEX, 0)
}

func (s *FunctionNameBaseContext) HOUR() antlr.TerminalNode {
	return s.GetToken(StmtParserHOUR, 0)
}

func (s *FunctionNameBaseContext) IFNULL() antlr.TerminalNode {
	return s.GetToken(StmtParserIFNULL, 0)
}

func (s *FunctionNameBaseContext) INET6_ATON() antlr.TerminalNode {
	return s.GetToken(StmtParserINET6_ATON, 0)
}

func (s *FunctionNameBaseContext) INET6_NTOA() antlr.TerminalNode {
	return s.GetToken(StmtParserINET6_NTOA, 0)
}

func (s *FunctionNameBaseContext) INET_ATON() antlr.TerminalNode {
	return s.GetToken(StmtParserINET_ATON, 0)
}

func (s *FunctionNameBaseContext) INET_NTOA() antlr.TerminalNode {
	return s.GetToken(StmtParserINET_NTOA, 0)
}

func (s *FunctionNameBaseContext) INSTR() antlr.TerminalNode {
	return s.GetToken(StmtParserINSTR, 0)
}

func (s *FunctionNameBaseContext) INTERIORRINGN() antlr.TerminalNode {
	return s.GetToken(StmtParserINTERIORRINGN, 0)
}

func (s *FunctionNameBaseContext) INTERSECTS() antlr.TerminalNode {
	return s.GetToken(StmtParserINTERSECTS, 0)
}

func (s *FunctionNameBaseContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(StmtParserINVISIBLE, 0)
}

func (s *FunctionNameBaseContext) ISCLOSED() antlr.TerminalNode {
	return s.GetToken(StmtParserISCLOSED, 0)
}

func (s *FunctionNameBaseContext) ISEMPTY() antlr.TerminalNode {
	return s.GetToken(StmtParserISEMPTY, 0)
}

func (s *FunctionNameBaseContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(StmtParserISNULL, 0)
}

func (s *FunctionNameBaseContext) ISSIMPLE() antlr.TerminalNode {
	return s.GetToken(StmtParserISSIMPLE, 0)
}

func (s *FunctionNameBaseContext) IS_FREE_LOCK() antlr.TerminalNode {
	return s.GetToken(StmtParserIS_FREE_LOCK, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4() antlr.TerminalNode {
	return s.GetToken(StmtParserIS_IPV4, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4_COMPAT() antlr.TerminalNode {
	return s.GetToken(StmtParserIS_IPV4_COMPAT, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4_MAPPED() antlr.TerminalNode {
	return s.GetToken(StmtParserIS_IPV4_MAPPED, 0)
}

func (s *FunctionNameBaseContext) IS_IPV6() antlr.TerminalNode {
	return s.GetToken(StmtParserIS_IPV6, 0)
}

func (s *FunctionNameBaseContext) IS_USED_LOCK() antlr.TerminalNode {
	return s.GetToken(StmtParserIS_USED_LOCK, 0)
}

func (s *FunctionNameBaseContext) LAG() antlr.TerminalNode {
	return s.GetToken(StmtParserLAG, 0)
}

func (s *FunctionNameBaseContext) LAST_INSERT_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserLAST_INSERT_ID, 0)
}

func (s *FunctionNameBaseContext) LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserLAST_VALUE, 0)
}

func (s *FunctionNameBaseContext) LCASE() antlr.TerminalNode {
	return s.GetToken(StmtParserLCASE, 0)
}

func (s *FunctionNameBaseContext) LEAD() antlr.TerminalNode {
	return s.GetToken(StmtParserLEAD, 0)
}

func (s *FunctionNameBaseContext) LEAST() antlr.TerminalNode {
	return s.GetToken(StmtParserLEAST, 0)
}

func (s *FunctionNameBaseContext) LEFT() antlr.TerminalNode {
	return s.GetToken(StmtParserLEFT, 0)
}

func (s *FunctionNameBaseContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserLENGTH, 0)
}

func (s *FunctionNameBaseContext) LINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserLINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) LINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserLINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) LINESTRING() antlr.TerminalNode {
	return s.GetToken(StmtParserLINESTRING, 0)
}

func (s *FunctionNameBaseContext) LINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserLINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) LINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserLINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) LN() antlr.TerminalNode {
	return s.GetToken(StmtParserLN, 0)
}

func (s *FunctionNameBaseContext) LOAD_FILE() antlr.TerminalNode {
	return s.GetToken(StmtParserLOAD_FILE, 0)
}

func (s *FunctionNameBaseContext) LOCATE() antlr.TerminalNode {
	return s.GetToken(StmtParserLOCATE, 0)
}

func (s *FunctionNameBaseContext) LOG() antlr.TerminalNode {
	return s.GetToken(StmtParserLOG, 0)
}

func (s *FunctionNameBaseContext) LOG10() antlr.TerminalNode {
	return s.GetToken(StmtParserLOG10, 0)
}

func (s *FunctionNameBaseContext) LOG2() antlr.TerminalNode {
	return s.GetToken(StmtParserLOG2, 0)
}

func (s *FunctionNameBaseContext) LOWER() antlr.TerminalNode {
	return s.GetToken(StmtParserLOWER, 0)
}

func (s *FunctionNameBaseContext) LPAD() antlr.TerminalNode {
	return s.GetToken(StmtParserLPAD, 0)
}

func (s *FunctionNameBaseContext) LTRIM() antlr.TerminalNode {
	return s.GetToken(StmtParserLTRIM, 0)
}

func (s *FunctionNameBaseContext) MAKEDATE() antlr.TerminalNode {
	return s.GetToken(StmtParserMAKEDATE, 0)
}

func (s *FunctionNameBaseContext) MAKETIME() antlr.TerminalNode {
	return s.GetToken(StmtParserMAKETIME, 0)
}

func (s *FunctionNameBaseContext) MAKE_SET() antlr.TerminalNode {
	return s.GetToken(StmtParserMAKE_SET, 0)
}

func (s *FunctionNameBaseContext) MASTER_POS_WAIT() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_POS_WAIT, 0)
}

func (s *FunctionNameBaseContext) MBRCONTAINS() antlr.TerminalNode {
	return s.GetToken(StmtParserMBRCONTAINS, 0)
}

func (s *FunctionNameBaseContext) MBRDISJOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserMBRDISJOINT, 0)
}

func (s *FunctionNameBaseContext) MBREQUAL() antlr.TerminalNode {
	return s.GetToken(StmtParserMBREQUAL, 0)
}

func (s *FunctionNameBaseContext) MBRINTERSECTS() antlr.TerminalNode {
	return s.GetToken(StmtParserMBRINTERSECTS, 0)
}

func (s *FunctionNameBaseContext) MBROVERLAPS() antlr.TerminalNode {
	return s.GetToken(StmtParserMBROVERLAPS, 0)
}

func (s *FunctionNameBaseContext) MBRTOUCHES() antlr.TerminalNode {
	return s.GetToken(StmtParserMBRTOUCHES, 0)
}

func (s *FunctionNameBaseContext) MBRWITHIN() antlr.TerminalNode {
	return s.GetToken(StmtParserMBRWITHIN, 0)
}

func (s *FunctionNameBaseContext) MD5() antlr.TerminalNode {
	return s.GetToken(StmtParserMD5, 0)
}

func (s *FunctionNameBaseContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserMICROSECOND, 0)
}

func (s *FunctionNameBaseContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserMINUTE, 0)
}

func (s *FunctionNameBaseContext) MLINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserMLINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MLINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserMLINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MOD() antlr.TerminalNode {
	return s.GetToken(StmtParserMOD, 0)
}

func (s *FunctionNameBaseContext) MONTH() antlr.TerminalNode {
	return s.GetToken(StmtParserMONTH, 0)
}

func (s *FunctionNameBaseContext) MONTHNAME() antlr.TerminalNode {
	return s.GetToken(StmtParserMONTHNAME, 0)
}

func (s *FunctionNameBaseContext) MPOINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserMPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MPOINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserMPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MPOLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserMPOLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MPOLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserMPOLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRING() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTILINESTRING, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTILINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTILINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTIPOINT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTIPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTIPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGON() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTIPOLYGON, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTIPOLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTIPOLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) NAME_CONST() antlr.TerminalNode {
	return s.GetToken(StmtParserNAME_CONST, 0)
}

func (s *FunctionNameBaseContext) NTH_VALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserNTH_VALUE, 0)
}

func (s *FunctionNameBaseContext) NTILE() antlr.TerminalNode {
	return s.GetToken(StmtParserNTILE, 0)
}

func (s *FunctionNameBaseContext) NULLIF() antlr.TerminalNode {
	return s.GetToken(StmtParserNULLIF, 0)
}

func (s *FunctionNameBaseContext) NUMGEOMETRIES() antlr.TerminalNode {
	return s.GetToken(StmtParserNUMGEOMETRIES, 0)
}

func (s *FunctionNameBaseContext) NUMINTERIORRINGS() antlr.TerminalNode {
	return s.GetToken(StmtParserNUMINTERIORRINGS, 0)
}

func (s *FunctionNameBaseContext) NUMPOINTS() antlr.TerminalNode {
	return s.GetToken(StmtParserNUMPOINTS, 0)
}

func (s *FunctionNameBaseContext) OCT() antlr.TerminalNode {
	return s.GetToken(StmtParserOCT, 0)
}

func (s *FunctionNameBaseContext) OCTET_LENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserOCTET_LENGTH, 0)
}

func (s *FunctionNameBaseContext) ORD() antlr.TerminalNode {
	return s.GetToken(StmtParserORD, 0)
}

func (s *FunctionNameBaseContext) OVERLAPS() antlr.TerminalNode {
	return s.GetToken(StmtParserOVERLAPS, 0)
}

func (s *FunctionNameBaseContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(StmtParserPERCENT_RANK, 0)
}

func (s *FunctionNameBaseContext) PERIOD_ADD() antlr.TerminalNode {
	return s.GetToken(StmtParserPERIOD_ADD, 0)
}

func (s *FunctionNameBaseContext) PERIOD_DIFF() antlr.TerminalNode {
	return s.GetToken(StmtParserPERIOD_DIFF, 0)
}

func (s *FunctionNameBaseContext) PI() antlr.TerminalNode {
	return s.GetToken(StmtParserPI, 0)
}

func (s *FunctionNameBaseContext) POINT() antlr.TerminalNode {
	return s.GetToken(StmtParserPOINT, 0)
}

func (s *FunctionNameBaseContext) POINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POINTN() antlr.TerminalNode {
	return s.GetToken(StmtParserPOINTN, 0)
}

func (s *FunctionNameBaseContext) POLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserPOLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserPOLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POLYGON() antlr.TerminalNode {
	return s.GetToken(StmtParserPOLYGON, 0)
}

func (s *FunctionNameBaseContext) POLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserPOLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserPOLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POSITION() antlr.TerminalNode {
	return s.GetToken(StmtParserPOSITION, 0)
}

func (s *FunctionNameBaseContext) POW() antlr.TerminalNode {
	return s.GetToken(StmtParserPOW, 0)
}

func (s *FunctionNameBaseContext) POWER() antlr.TerminalNode {
	return s.GetToken(StmtParserPOWER, 0)
}

func (s *FunctionNameBaseContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(StmtParserQUARTER, 0)
}

func (s *FunctionNameBaseContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(StmtParserQUOTE, 0)
}

func (s *FunctionNameBaseContext) RADIANS() antlr.TerminalNode {
	return s.GetToken(StmtParserRADIANS, 0)
}

func (s *FunctionNameBaseContext) RAND() antlr.TerminalNode {
	return s.GetToken(StmtParserRAND, 0)
}

func (s *FunctionNameBaseContext) RANK() antlr.TerminalNode {
	return s.GetToken(StmtParserRANK, 0)
}

func (s *FunctionNameBaseContext) RANDOM_BYTES() antlr.TerminalNode {
	return s.GetToken(StmtParserRANDOM_BYTES, 0)
}

func (s *FunctionNameBaseContext) RELEASE_LOCK() antlr.TerminalNode {
	return s.GetToken(StmtParserRELEASE_LOCK, 0)
}

func (s *FunctionNameBaseContext) REVERSE() antlr.TerminalNode {
	return s.GetToken(StmtParserREVERSE, 0)
}

func (s *FunctionNameBaseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(StmtParserRIGHT, 0)
}

func (s *FunctionNameBaseContext) ROUND() antlr.TerminalNode {
	return s.GetToken(StmtParserROUND, 0)
}

func (s *FunctionNameBaseContext) ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(StmtParserROW_COUNT, 0)
}

func (s *FunctionNameBaseContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(StmtParserROW_NUMBER, 0)
}

func (s *FunctionNameBaseContext) RPAD() antlr.TerminalNode {
	return s.GetToken(StmtParserRPAD, 0)
}

func (s *FunctionNameBaseContext) RTRIM() antlr.TerminalNode {
	return s.GetToken(StmtParserRTRIM, 0)
}

func (s *FunctionNameBaseContext) SECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserSECOND, 0)
}

func (s *FunctionNameBaseContext) SEC_TO_TIME() antlr.TerminalNode {
	return s.GetToken(StmtParserSEC_TO_TIME, 0)
}

func (s *FunctionNameBaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(StmtParserSCHEMA, 0)
}

func (s *FunctionNameBaseContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(StmtParserSESSION_USER, 0)
}

func (s *FunctionNameBaseContext) SESSION_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserSESSION_VARIABLES_ADMIN, 0)
}

func (s *FunctionNameBaseContext) SHA() antlr.TerminalNode {
	return s.GetToken(StmtParserSHA, 0)
}

func (s *FunctionNameBaseContext) SHA1() antlr.TerminalNode {
	return s.GetToken(StmtParserSHA1, 0)
}

func (s *FunctionNameBaseContext) SHA2() antlr.TerminalNode {
	return s.GetToken(StmtParserSHA2, 0)
}

func (s *FunctionNameBaseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(StmtParserSIGN, 0)
}

func (s *FunctionNameBaseContext) SIN() antlr.TerminalNode {
	return s.GetToken(StmtParserSIN, 0)
}

func (s *FunctionNameBaseContext) SLEEP() antlr.TerminalNode {
	return s.GetToken(StmtParserSLEEP, 0)
}

func (s *FunctionNameBaseContext) SOUNDEX() antlr.TerminalNode {
	return s.GetToken(StmtParserSOUNDEX, 0)
}

func (s *FunctionNameBaseContext) SQL_THREAD_WAIT_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(StmtParserSQL_THREAD_WAIT_AFTER_GTIDS, 0)
}

func (s *FunctionNameBaseContext) SQRT() antlr.TerminalNode {
	return s.GetToken(StmtParserSQRT, 0)
}

func (s *FunctionNameBaseContext) SRID() antlr.TerminalNode {
	return s.GetToken(StmtParserSRID, 0)
}

func (s *FunctionNameBaseContext) STARTPOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserSTARTPOINT, 0)
}

func (s *FunctionNameBaseContext) STRCMP() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRCMP, 0)
}

func (s *FunctionNameBaseContext) STR_TO_DATE() antlr.TerminalNode {
	return s.GetToken(StmtParserSTR_TO_DATE, 0)
}

func (s *FunctionNameBaseContext) ST_AREA() antlr.TerminalNode {
	return s.GetToken(StmtParserST_AREA, 0)
}

func (s *FunctionNameBaseContext) ST_ASBINARY() antlr.TerminalNode {
	return s.GetToken(StmtParserST_ASBINARY, 0)
}

func (s *FunctionNameBaseContext) ST_ASTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_ASTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_ASWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_ASWKB, 0)
}

func (s *FunctionNameBaseContext) ST_ASWKT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_ASWKT, 0)
}

func (s *FunctionNameBaseContext) ST_BUFFER() antlr.TerminalNode {
	return s.GetToken(StmtParserST_BUFFER, 0)
}

func (s *FunctionNameBaseContext) ST_CENTROID() antlr.TerminalNode {
	return s.GetToken(StmtParserST_CENTROID, 0)
}

func (s *FunctionNameBaseContext) ST_CONTAINS() antlr.TerminalNode {
	return s.GetToken(StmtParserST_CONTAINS, 0)
}

func (s *FunctionNameBaseContext) ST_CROSSES() antlr.TerminalNode {
	return s.GetToken(StmtParserST_CROSSES, 0)
}

func (s *FunctionNameBaseContext) ST_DIFFERENCE() antlr.TerminalNode {
	return s.GetToken(StmtParserST_DIFFERENCE, 0)
}

func (s *FunctionNameBaseContext) ST_DIMENSION() antlr.TerminalNode {
	return s.GetToken(StmtParserST_DIMENSION, 0)
}

func (s *FunctionNameBaseContext) ST_DISJOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_DISJOINT, 0)
}

func (s *FunctionNameBaseContext) ST_DISTANCE() antlr.TerminalNode {
	return s.GetToken(StmtParserST_DISTANCE, 0)
}

func (s *FunctionNameBaseContext) ST_ENDPOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_ENDPOINT, 0)
}

func (s *FunctionNameBaseContext) ST_ENVELOPE() antlr.TerminalNode {
	return s.GetToken(StmtParserST_ENVELOPE, 0)
}

func (s *FunctionNameBaseContext) ST_EQUALS() antlr.TerminalNode {
	return s.GetToken(StmtParserST_EQUALS, 0)
}

func (s *FunctionNameBaseContext) ST_EXTERIORRING() antlr.TerminalNode {
	return s.GetToken(StmtParserST_EXTERIORRING, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMCOLLFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMTXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMCOLLFROMTXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMCOLLFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMETRYCOLLECTIONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMETRYCOLLECTIONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMETRYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMETRYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYN() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMETRYN, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYTYPE() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMETRYTYPE, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_INTERIORRINGN() antlr.TerminalNode {
	return s.GetToken(StmtParserST_INTERIORRINGN, 0)
}

func (s *FunctionNameBaseContext) ST_INTERSECTION() antlr.TerminalNode {
	return s.GetToken(StmtParserST_INTERSECTION, 0)
}

func (s *FunctionNameBaseContext) ST_INTERSECTS() antlr.TerminalNode {
	return s.GetToken(StmtParserST_INTERSECTS, 0)
}

func (s *FunctionNameBaseContext) ST_ISCLOSED() antlr.TerminalNode {
	return s.GetToken(StmtParserST_ISCLOSED, 0)
}

func (s *FunctionNameBaseContext) ST_ISEMPTY() antlr.TerminalNode {
	return s.GetToken(StmtParserST_ISEMPTY, 0)
}

func (s *FunctionNameBaseContext) ST_ISSIMPLE() antlr.TerminalNode {
	return s.GetToken(StmtParserST_ISSIMPLE, 0)
}

func (s *FunctionNameBaseContext) ST_LINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_LINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_LINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_LINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_LINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_LINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_LINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_LINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_NUMGEOMETRIES() antlr.TerminalNode {
	return s.GetToken(StmtParserST_NUMGEOMETRIES, 0)
}

func (s *FunctionNameBaseContext) ST_NUMINTERIORRING() antlr.TerminalNode {
	return s.GetToken(StmtParserST_NUMINTERIORRING, 0)
}

func (s *FunctionNameBaseContext) ST_NUMINTERIORRINGS() antlr.TerminalNode {
	return s.GetToken(StmtParserST_NUMINTERIORRINGS, 0)
}

func (s *FunctionNameBaseContext) ST_NUMPOINTS() antlr.TerminalNode {
	return s.GetToken(StmtParserST_NUMPOINTS, 0)
}

func (s *FunctionNameBaseContext) ST_OVERLAPS() antlr.TerminalNode {
	return s.GetToken(StmtParserST_OVERLAPS, 0)
}

func (s *FunctionNameBaseContext) ST_POINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_POINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_POINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_POINTN() antlr.TerminalNode {
	return s.GetToken(StmtParserST_POINTN, 0)
}

func (s *FunctionNameBaseContext) ST_POLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_POLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_POLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_POLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_POLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_POLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_SRID() antlr.TerminalNode {
	return s.GetToken(StmtParserST_SRID, 0)
}

func (s *FunctionNameBaseContext) ST_STARTPOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_STARTPOINT, 0)
}

func (s *FunctionNameBaseContext) ST_SYMDIFFERENCE() antlr.TerminalNode {
	return s.GetToken(StmtParserST_SYMDIFFERENCE, 0)
}

func (s *FunctionNameBaseContext) ST_TOUCHES() antlr.TerminalNode {
	return s.GetToken(StmtParserST_TOUCHES, 0)
}

func (s *FunctionNameBaseContext) ST_UNION() antlr.TerminalNode {
	return s.GetToken(StmtParserST_UNION, 0)
}

func (s *FunctionNameBaseContext) ST_WITHIN() antlr.TerminalNode {
	return s.GetToken(StmtParserST_WITHIN, 0)
}

func (s *FunctionNameBaseContext) ST_X() antlr.TerminalNode {
	return s.GetToken(StmtParserST_X, 0)
}

func (s *FunctionNameBaseContext) ST_Y() antlr.TerminalNode {
	return s.GetToken(StmtParserST_Y, 0)
}

func (s *FunctionNameBaseContext) SUBDATE() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBDATE, 0)
}

func (s *FunctionNameBaseContext) SUBSTRING_INDEX() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBSTRING_INDEX, 0)
}

func (s *FunctionNameBaseContext) SUBTIME() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBTIME, 0)
}

func (s *FunctionNameBaseContext) SYSTEM_USER() antlr.TerminalNode {
	return s.GetToken(StmtParserSYSTEM_USER, 0)
}

func (s *FunctionNameBaseContext) TAN() antlr.TerminalNode {
	return s.GetToken(StmtParserTAN, 0)
}

func (s *FunctionNameBaseContext) TIME() antlr.TerminalNode {
	return s.GetToken(StmtParserTIME, 0)
}

func (s *FunctionNameBaseContext) TIMEDIFF() antlr.TerminalNode {
	return s.GetToken(StmtParserTIMEDIFF, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserTIMESTAMP, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(StmtParserTIMESTAMPADD, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(StmtParserTIMESTAMPDIFF, 0)
}

func (s *FunctionNameBaseContext) TIME_FORMAT() antlr.TerminalNode {
	return s.GetToken(StmtParserTIME_FORMAT, 0)
}

func (s *FunctionNameBaseContext) TIME_TO_SEC() antlr.TerminalNode {
	return s.GetToken(StmtParserTIME_TO_SEC, 0)
}

func (s *FunctionNameBaseContext) TOUCHES() antlr.TerminalNode {
	return s.GetToken(StmtParserTOUCHES, 0)
}

func (s *FunctionNameBaseContext) TO_BASE64() antlr.TerminalNode {
	return s.GetToken(StmtParserTO_BASE64, 0)
}

func (s *FunctionNameBaseContext) TO_DAYS() antlr.TerminalNode {
	return s.GetToken(StmtParserTO_DAYS, 0)
}

func (s *FunctionNameBaseContext) TO_SECONDS() antlr.TerminalNode {
	return s.GetToken(StmtParserTO_SECONDS, 0)
}

func (s *FunctionNameBaseContext) UCASE() antlr.TerminalNode {
	return s.GetToken(StmtParserUCASE, 0)
}

func (s *FunctionNameBaseContext) UNCOMPRESS() antlr.TerminalNode {
	return s.GetToken(StmtParserUNCOMPRESS, 0)
}

func (s *FunctionNameBaseContext) UNCOMPRESSED_LENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserUNCOMPRESSED_LENGTH, 0)
}

func (s *FunctionNameBaseContext) UNHEX() antlr.TerminalNode {
	return s.GetToken(StmtParserUNHEX, 0)
}

func (s *FunctionNameBaseContext) UNIX_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserUNIX_TIMESTAMP, 0)
}

func (s *FunctionNameBaseContext) UPDATEXML() antlr.TerminalNode {
	return s.GetToken(StmtParserUPDATEXML, 0)
}

func (s *FunctionNameBaseContext) UPPER() antlr.TerminalNode {
	return s.GetToken(StmtParserUPPER, 0)
}

func (s *FunctionNameBaseContext) UUID() antlr.TerminalNode {
	return s.GetToken(StmtParserUUID, 0)
}

func (s *FunctionNameBaseContext) UUID_SHORT() antlr.TerminalNode {
	return s.GetToken(StmtParserUUID_SHORT, 0)
}

func (s *FunctionNameBaseContext) VALIDATE_PASSWORD_STRENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserVALIDATE_PASSWORD_STRENGTH, 0)
}

func (s *FunctionNameBaseContext) VERSION() antlr.TerminalNode {
	return s.GetToken(StmtParserVERSION, 0)
}

func (s *FunctionNameBaseContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(StmtParserVISIBLE, 0)
}

func (s *FunctionNameBaseContext) WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(StmtParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, 0)
}

func (s *FunctionNameBaseContext) WEEK() antlr.TerminalNode {
	return s.GetToken(StmtParserWEEK, 0)
}

func (s *FunctionNameBaseContext) WEEKDAY() antlr.TerminalNode {
	return s.GetToken(StmtParserWEEKDAY, 0)
}

func (s *FunctionNameBaseContext) WEEKOFYEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserWEEKOFYEAR, 0)
}

func (s *FunctionNameBaseContext) WEIGHT_STRING() antlr.TerminalNode {
	return s.GetToken(StmtParserWEIGHT_STRING, 0)
}

func (s *FunctionNameBaseContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(StmtParserWITHIN, 0)
}

func (s *FunctionNameBaseContext) YEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserYEAR, 0)
}

func (s *FunctionNameBaseContext) YEARWEEK() antlr.TerminalNode {
	return s.GetToken(StmtParserYEARWEEK, 0)
}

func (s *FunctionNameBaseContext) Y_FUNCTION() antlr.TerminalNode {
	return s.GetToken(StmtParserY_FUNCTION, 0)
}

func (s *FunctionNameBaseContext) X_FUNCTION() antlr.TerminalNode {
	return s.GetToken(StmtParserX_FUNCTION, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAY() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_ARRAY, 0)
}

func (s *FunctionNameBaseContext) JSON_OBJECT() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_OBJECT, 0)
}

func (s *FunctionNameBaseContext) JSON_QUOTE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_QUOTE, 0)
}

func (s *FunctionNameBaseContext) JSON_CONTAINS() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_CONTAINS, 0)
}

func (s *FunctionNameBaseContext) JSON_CONTAINS_PATH() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_CONTAINS_PATH, 0)
}

func (s *FunctionNameBaseContext) JSON_EXTRACT() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_EXTRACT, 0)
}

func (s *FunctionNameBaseContext) JSON_KEYS() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_KEYS, 0)
}

func (s *FunctionNameBaseContext) JSON_OVERLAPS() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_OVERLAPS, 0)
}

func (s *FunctionNameBaseContext) JSON_SEARCH() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_SEARCH, 0)
}

func (s *FunctionNameBaseContext) JSON_VALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_VALUE, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAY_APPEND() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_ARRAY_APPEND, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAY_INSERT() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_ARRAY_INSERT, 0)
}

func (s *FunctionNameBaseContext) JSON_INSERT() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_INSERT, 0)
}

func (s *FunctionNameBaseContext) JSON_MERGE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_MERGE, 0)
}

func (s *FunctionNameBaseContext) JSON_MERGE_PATCH() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_MERGE_PATCH, 0)
}

func (s *FunctionNameBaseContext) JSON_MERGE_PRESERVE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_MERGE_PRESERVE, 0)
}

func (s *FunctionNameBaseContext) JSON_REMOVE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_REMOVE, 0)
}

func (s *FunctionNameBaseContext) JSON_REPLACE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_REPLACE, 0)
}

func (s *FunctionNameBaseContext) JSON_SET() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_SET, 0)
}

func (s *FunctionNameBaseContext) JSON_UNQUOTE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_UNQUOTE, 0)
}

func (s *FunctionNameBaseContext) JSON_DEPTH() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_DEPTH, 0)
}

func (s *FunctionNameBaseContext) JSON_LENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_LENGTH, 0)
}

func (s *FunctionNameBaseContext) JSON_TYPE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_TYPE, 0)
}

func (s *FunctionNameBaseContext) JSON_VALID() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_VALID, 0)
}

func (s *FunctionNameBaseContext) JSON_TABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_TABLE, 0)
}

func (s *FunctionNameBaseContext) JSON_SCHEMA_VALID() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_SCHEMA_VALID, 0)
}

func (s *FunctionNameBaseContext) JSON_SCHEMA_VALIDATION_REPORT() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_SCHEMA_VALIDATION_REPORT, 0)
}

func (s *FunctionNameBaseContext) JSON_PRETTY() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_PRETTY, 0)
}

func (s *FunctionNameBaseContext) JSON_STORAGE_FREE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_STORAGE_FREE, 0)
}

func (s *FunctionNameBaseContext) JSON_STORAGE_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_STORAGE_SIZE, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAYAGG() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_ARRAYAGG, 0)
}

func (s *FunctionNameBaseContext) JSON_OBJECTAGG() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_OBJECTAGG, 0)
}

func (s *FunctionNameBaseContext) LASTVAL() antlr.TerminalNode {
	return s.GetToken(StmtParserLASTVAL, 0)
}

func (s *FunctionNameBaseContext) NEXTVAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNEXTVAL, 0)
}

func (s *FunctionNameBaseContext) SETVAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSETVAL, 0)
}

func (s *FunctionNameBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterFunctionNameBase(s)
	}
}

func (s *FunctionNameBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitFunctionNameBase(s)
	}
}

func (p *StmtParser) FunctionNameBase() (localctx IFunctionNameBaseContext) {
	localctx = NewFunctionNameBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, StmtParserRULE_functionNameBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1574)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserDATABASE || ((int64((_la-93)) & ^0x3f) == 0 && ((int64(1)<<(_la-93))&11258999068426241) != 0) || ((int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17179869161) != 0) || ((int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&1099513674691) != 0) || _la == StmtParserINVISIBLE || ((int64((_la-656)) & ^0x3f) == 0 && ((int64(1)<<(_la-656))&-9223372036838064127) != 0) || ((int64((_la-783)) & ^0x3f) == 0 && ((int64(1)<<(_la-783))&-8589934599) != 0) || ((int64((_la-847)) & ^0x3f) == 0 && ((int64(1)<<(_la-847))&-257) != 0) || ((int64((_la-911)) & ^0x3f) == 0 && ((int64(1)<<(_la-911))&-1) != 0) || ((int64((_la-975)) & ^0x3f) == 0 && ((int64(1)<<(_la-975))&-529) != 0) || ((int64((_la-1039)) & ^0x3f) == 0 && ((int64(1)<<(_la-1039))&2111062325329919) != 0) || _la == StmtParserMOD) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *StmtParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 57:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 58:
		var t *PredicateContext = nil
		if localctx != nil {
			t = localctx.(*PredicateContext)
		}
		return p.Predicate_Sempred(t, predIndex)

	case 59:
		var t *ExpressionAtomContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionAtomContext)
		}
		return p.ExpressionAtom_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *StmtParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *StmtParser) Predicate_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *StmtParser) ExpressionAtom_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 10)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
