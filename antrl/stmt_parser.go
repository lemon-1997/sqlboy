// Code generated from java-escape by ANTLR 4.11.1. DO NOT EDIT.

package parser // StmtParser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type StmtParser struct {
	*antlr.BaseParser
}

var stmtparserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func stmtparserParserInit() {
	staticData := &stmtparserParserStaticData
	staticData.literalNames = []string{
		"", "", "", "", "", "'ADD'", "'ALL'", "'ALTER'", "'ALWAYS'", "'ANALYZE'",
		"'AND'", "'ARRAY'", "'AS'", "'ASC'", "'BEFORE'", "'BETWEEN'", "'BOTH'",
		"'BUCKETS'", "'BY'", "'CALL'", "'CASCADE'", "'CASE'", "'CAST'", "'CHANGE'",
		"'CHARACTER'", "'CHECK'", "'COLLATE'", "'COLUMN'", "'CONDITION'", "'CONSTRAINT'",
		"'CONTINUE'", "'CONVERT'", "'CREATE'", "'CROSS'", "'CURRENT'", "'CURRENT_USER'",
		"'CURSOR'", "'DATABASE'", "'DATABASES'", "'DECLARE'", "'DEFAULT'", "'DELAYED'",
		"'DELETE'", "'DESC'", "'DESCRIBE'", "'DETERMINISTIC'", "'DIAGNOSTICS'",
		"'DISTINCT'", "'DISTINCTROW'", "'DROP'", "'EACH'", "'ELSE'", "'ELSEIF'",
		"'EMPTY'", "'ENCLOSED'", "'ESCAPED'", "'EXCEPT'", "'EXISTS'", "'EXIT'",
		"'EXPLAIN'", "'FALSE'", "'FETCH'", "'FOR'", "'FORCE'", "'FOREIGN'",
		"'FROM'", "'FULLTEXT'", "'GENERATED'", "'GET'", "'GRANT'", "'GROUP'",
		"'HAVING'", "'HIGH_PRIORITY'", "'HISTOGRAM'", "'IF'", "'IGNORE'", "'IGNORED'",
		"'IN'", "'INDEX'", "'INFILE'", "'INNER'", "'INOUT'", "'INSERT'", "'INTERVAL'",
		"'INTO'", "'IS'", "'ITERATE'", "'JOIN'", "'KEY'", "'KEYS'", "'KILL'",
		"'LEADING'", "'LEAVE'", "'LEFT'", "'LIKE'", "'LIMIT'", "'LINEAR'", "'LINES'",
		"'LOAD'", "'LOCK'", "'LOCKED'", "'LOOP'", "'LOW_PRIORITY'", "'MASTER_BIND'",
		"'MASTER_SSL_VERIFY_SERVER_CERT'", "'MATCH'", "'MAXVALUE'", "'MINVALUE'",
		"'MODIFIES'", "'NATURAL'", "'NOT'", "'NO_WRITE_TO_BINLOG'", "'NULL'",
		"'NUMBER'", "'ON'", "'OPTIMIZE'", "'OPTION'", "'OPTIONAL'", "'OPTIONALLY'",
		"'OR'", "'ORDER'", "'OUT'", "'OVER'", "'OUTER'", "'OUTFILE'", "'PARTITION'",
		"'PRIMARY'", "'PROCEDURE'", "'PURGE'", "'RANGE'", "'READ'", "'READS'",
		"'REFERENCES'", "'REGEXP'", "'RELEASE'", "'RENAME'", "'REPEAT'", "'REPLACE'",
		"'REQUIRE'", "'RESIGNAL'", "'RESTRICT'", "'RETAIN'", "'RETURN'", "'REVOKE'",
		"'RIGHT'", "'RLIKE'", "'SCHEMA'", "'SCHEMAS'", "'SELECT'", "'SET'",
		"'SEPARATOR'", "'SHOW'", "'SIGNAL'", "'SKIP'", "'SPATIAL'", "'SQL'",
		"'SQLEXCEPTION'", "'SQLSTATE'", "'SQLWARNING'", "'SQL_BIG_RESULT'",
		"'SQL_CALC_FOUND_ROWS'", "'SQL_SMALL_RESULT'", "'SSL'", "'STACKED'",
		"'STARTING'", "'STRAIGHT_JOIN'", "'TABLE'", "'TERMINATED'", "'THEN'",
		"'TO'", "'TRAILING'", "'TRIGGER'", "'TRUE'", "'UNDO'", "'UNION'", "'UNIQUE'",
		"'UNLOCK'", "'UNSIGNED'", "'UPDATE'", "'USAGE'", "'USE'", "'USING'",
		"'VALUES'", "'WHEN'", "'WHERE'", "'WHILE'", "'WITH'", "'WRITE'", "'XOR'",
		"'ZEROFILL'", "'TINYINT'", "'SMALLINT'", "'MEDIUMINT'", "'MIDDLEINT'",
		"'INT'", "'INT1'", "'INT2'", "'INT3'", "'INT4'", "'INT8'", "'INTEGER'",
		"'BIGINT'", "'REAL'", "'DOUBLE'", "'PRECISION'", "'FLOAT'", "'FLOAT4'",
		"'FLOAT8'", "'DECIMAL'", "'DEC'", "'NUMERIC'", "'DATE'", "'TIME'", "'TIMESTAMP'",
		"'DATETIME'", "'YEAR'", "'CHAR'", "'VARCHAR'", "'NVARCHAR'", "'NATIONAL'",
		"'BINARY'", "'VARBINARY'", "'TINYBLOB'", "'BLOB'", "'MEDIUMBLOB'", "'LONG'",
		"'LONGBLOB'", "'TINYTEXT'", "'TEXT'", "'MEDIUMTEXT'", "'LONGTEXT'",
		"'ENUM'", "'VARYING'", "'SERIAL'", "'YEAR_MONTH'", "'DAY_HOUR'", "'DAY_MINUTE'",
		"'DAY_SECOND'", "'HOUR_MINUTE'", "'HOUR_SECOND'", "'MINUTE_SECOND'",
		"'SECOND_MICROSECOND'", "'MINUTE_MICROSECOND'", "'HOUR_MICROSECOND'",
		"'DAY_MICROSECOND'", "'JSON_ARRAY'", "'JSON_OBJECT'", "'JSON_QUOTE'",
		"'JSON_CONTAINS'", "'JSON_CONTAINS_PATH'", "'JSON_EXTRACT'", "'JSON_KEYS'",
		"'JSON_OVERLAPS'", "'JSON_SEARCH'", "'JSON_VALUE'", "'JSON_ARRAY_APPEND'",
		"'JSON_ARRAY_INSERT'", "'JSON_INSERT'", "'JSON_MERGE'", "'JSON_MERGE_PATCH'",
		"'JSON_MERGE_PRESERVE'", "'JSON_REMOVE'", "'JSON_REPLACE'", "'JSON_SET'",
		"'JSON_UNQUOTE'", "'JSON_DEPTH'", "'JSON_LENGTH'", "'JSON_TYPE'", "'JSON_VALID'",
		"'JSON_TABLE'", "'JSON_SCHEMA_VALID'", "'JSON_SCHEMA_VALIDATION_REPORT'",
		"'JSON_PRETTY'", "'JSON_STORAGE_FREE'", "'JSON_STORAGE_SIZE'", "'JSON_ARRAYAGG'",
		"'JSON_OBJECTAGG'", "'AVG'", "'BIT_AND'", "'BIT_OR'", "'BIT_XOR'", "'COUNT'",
		"'CUME_DIST'", "'DENSE_RANK'", "'FIRST_VALUE'", "'GROUP_CONCAT'", "'LAG'",
		"'LAST_VALUE'", "'LEAD'", "'MAX'", "'MIN'", "'NTILE'", "'NTH_VALUE'",
		"'PERCENT_RANK'", "'RANK'", "'ROW_NUMBER'", "'STD'", "'STDDEV'", "'STDDEV_POP'",
		"'STDDEV_SAMP'", "'SUM'", "'VAR_POP'", "'VAR_SAMP'", "'VARIANCE'", "'CURRENT_DATE'",
		"'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'LOCALTIME'", "'CURDATE'",
		"'CURTIME'", "'DATE_ADD'", "'DATE_SUB'", "'EXTRACT'", "'LOCALTIMESTAMP'",
		"'NOW'", "'POSITION'", "'SUBSTR'", "'SUBSTRING'", "'SYSDATE'", "'TRIM'",
		"'UTC_DATE'", "'UTC_TIME'", "'UTC_TIMESTAMP'", "'ACCOUNT'", "'ACTION'",
		"'AFTER'", "'AGGREGATE'", "'ALGORITHM'", "'ANY'", "'AT'", "'AUTHORS'",
		"'AUTOCOMMIT'", "'AUTOEXTEND_SIZE'", "'AUTO_INCREMENT'", "'AVG_ROW_LENGTH'",
		"'BEGIN'", "'BINLOG'", "'BIT'", "'BLOCK'", "'BOOL'", "'BOOLEAN'", "'BTREE'",
		"'CACHE'", "'CASCADED'", "'CHAIN'", "'CHANGED'", "'CHANNEL'", "'CHECKSUM'",
		"'PAGE_CHECKSUM'", "'CIPHER'", "'CLASS_ORIGIN'", "'CLIENT'", "'CLOSE'",
		"'CLUSTERING'", "'COALESCE'", "'CODE'", "'COLUMNS'", "'COLUMN_FORMAT'",
		"'COLUMN_NAME'", "'COMMENT'", "'COMMIT'", "'COMPACT'", "'COMPLETION'",
		"'COMPRESSED'", "'COMPRESSION'", "'CONCURRENT'", "'CONNECT'", "'CONNECTION'",
		"'CONSISTENT'", "'CONSTRAINT_CATALOG'", "'CONSTRAINT_SCHEMA'", "'CONSTRAINT_NAME'",
		"'CONTAINS'", "'CONTEXT'", "'CONTRIBUTORS'", "'COPY'", "'CPU'", "'CYCLE'",
		"'CURSOR_NAME'", "'DATA'", "'DATAFILE'", "'DEALLOCATE'", "'DEFAULT_AUTH'",
		"'DEFINER'", "'DELAY_KEY_WRITE'", "'DES_KEY_FILE'", "'DIRECTORY'", "'DISABLE'",
		"'DISCARD'", "'DISK'", "'DO'", "'DUMPFILE'", "'DUPLICATE'", "'DYNAMIC'",
		"'ENABLE'", "'ENCRYPTION'", "'END'", "'ENDS'", "'ENGINE'", "'ENGINES'",
		"'ERROR'", "'ERRORS'", "'ESCAPE'", "'EVEN'", "'EVENT'", "'EVENTS'",
		"'EVERY'", "'EXCHANGE'", "'EXCLUSIVE'", "'EXPIRE'", "'EXPORT'", "'EXTENDED'",
		"'EXTENT_SIZE'", "'FAST'", "'FAULTS'", "'FIELDS'", "'FILE_BLOCK_SIZE'",
		"'FILTER'", "'FIRST'", "'FIXED'", "'FLUSH'", "'FOLLOWING'", "'FOLLOWS'",
		"'FOUND'", "'FULL'", "'FUNCTION'", "'GENERAL'", "'GLOBAL'", "'GRANTS'",
		"'GROUP_REPLICATION'", "'HANDLER'", "'HASH'", "'HELP'", "'HOST'", "'HOSTS'",
		"'IDENTIFIED'", "'IGNORE_SERVER_IDS'", "'IMPORT'", "'INCREMENT'", "'INDEXES'",
		"'INITIAL_SIZE'", "'INPLACE'", "'INSERT_METHOD'", "'INSTALL'", "'INSTANCE'",
		"'INSTANT'", "'INVISIBLE'", "'INVOKER'", "'IO'", "'IO_THREAD'", "'IPC'",
		"'ISOLATION'", "'ISSUER'", "'JSON'", "'KEY_BLOCK_SIZE'", "'LANGUAGE'",
		"'LAST'", "'LEAVES'", "'LESS'", "'LEVEL'", "'LIST'", "'LOCAL'", "'LOGFILE'",
		"'LOGS'", "'MASTER'", "'MASTER_AUTO_POSITION'", "'MASTER_CONNECT_RETRY'",
		"'MASTER_DELAY'", "'MASTER_HEARTBEAT_PERIOD'", "'MASTER_HOST'", "'MASTER_LOG_FILE'",
		"'MASTER_LOG_POS'", "'MASTER_PASSWORD'", "'MASTER_PORT'", "'MASTER_RETRY_COUNT'",
		"'MASTER_SSL'", "'MASTER_SSL_CA'", "'MASTER_SSL_CAPATH'", "'MASTER_SSL_CERT'",
		"'MASTER_SSL_CIPHER'", "'MASTER_SSL_CRL'", "'MASTER_SSL_CRLPATH'", "'MASTER_SSL_KEY'",
		"'MASTER_TLS_VERSION'", "'MASTER_USER'", "'MAX_CONNECTIONS_PER_HOUR'",
		"'MAX_QUERIES_PER_HOUR'", "'MAX_ROWS'", "'MAX_SIZE'", "'MAX_UPDATES_PER_HOUR'",
		"'MAX_USER_CONNECTIONS'", "'MEDIUM'", "'MEMBER'", "'MERGE'", "'MESSAGE_TEXT'",
		"'MID'", "'MIGRATE'", "'MIN_ROWS'", "'MODE'", "'MODIFY'", "'MUTEX'",
		"'MYSQL'", "'MYSQL_ERRNO'", "'NAME'", "'NAMES'", "'NCHAR'", "'NEVER'",
		"'NEXT'", "'NO'", "'NOCACHE'", "'NOCOPY'", "'NOCYCLE'", "'NOMAXVALUE'",
		"'NOMINVALUE'", "'NOWAIT'", "'NODEGROUP'", "'NONE'", "'ODBC'", "'OFFLINE'",
		"'OFFSET'", "'OF'", "'OJ'", "'OLD_PASSWORD'", "'ONE'", "'ONLINE'", "'ONLY'",
		"'OPEN'", "'OPTIMIZER_COSTS'", "'OPTIONS'", "'OWNER'", "'PACK_KEYS'",
		"'PAGE'", "'PARSER'", "'PARTIAL'", "'PARTITIONING'", "'PARTITIONS'",
		"'PASSWORD'", "'PHASE'", "'PLUGIN'", "'PLUGIN_DIR'", "'PLUGINS'", "'PORT'",
		"'PRECEDES'", "'PRECEDING'", "'PREPARE'", "'PRESERVE'", "'PREV'", "'PROCESSLIST'",
		"'PROFILE'", "'PROFILES'", "'PROXY'", "'QUERY'", "'QUICK'", "'REBUILD'",
		"'RECOVER'", "'RECURSIVE'", "'REDO_BUFFER_SIZE'", "'REDUNDANT'", "'RELAY'",
		"'RELAY_LOG_FILE'", "'RELAY_LOG_POS'", "'RELAYLOG'", "'REMOVE'", "'REORGANIZE'",
		"'REPAIR'", "'REPLICATE_DO_DB'", "'REPLICATE_DO_TABLE'", "'REPLICATE_IGNORE_DB'",
		"'REPLICATE_IGNORE_TABLE'", "'REPLICATE_REWRITE_DB'", "'REPLICATE_WILD_DO_TABLE'",
		"'REPLICATE_WILD_IGNORE_TABLE'", "'REPLICATION'", "'RESET'", "'RESTART'",
		"'RESUME'", "'RETURNED_SQLSTATE'", "'RETURNING'", "'RETURNS'", "'ROLE'",
		"'ROLLBACK'", "'ROLLUP'", "'ROTATE'", "'ROW'", "'ROWS'", "'ROW_FORMAT'",
		"'RTREE'", "'SAVEPOINT'", "'SCHEDULE'", "'SECURITY'", "'SEQUENCE'",
		"'SERVER'", "'SESSION'", "'SHARE'", "'SHARED'", "'SIGNED'", "'SIMPLE'",
		"'SLAVE'", "'SLOW'", "'SNAPSHOT'", "'SOCKET'", "'SOME'", "'SONAME'",
		"'SOUNDS'", "'SOURCE'", "'SQL_AFTER_GTIDS'", "'SQL_AFTER_MTS_GAPS'",
		"'SQL_BEFORE_GTIDS'", "'SQL_BUFFER_RESULT'", "'SQL_CACHE'", "'SQL_NO_CACHE'",
		"'SQL_THREAD'", "'START'", "'STARTS'", "'STATS_AUTO_RECALC'", "'STATS_PERSISTENT'",
		"'STATS_SAMPLE_PAGES'", "'STATUS'", "'STOP'", "'STORAGE'", "'STORED'",
		"'STRING'", "'SUBCLASS_ORIGIN'", "'SUBJECT'", "'SUBPARTITION'", "'SUBPARTITIONS'",
		"'SUSPEND'", "'SWAPS'", "'SWITCHES'", "'TABLE_NAME'", "'TABLESPACE'",
		"'TABLE_TYPE'", "'TEMPORARY'", "'TEMPTABLE'", "'THAN'", "'TRADITIONAL'",
		"'TRANSACTION'", "'TRANSACTIONAL'", "'TRIGGERS'", "'TRUNCATE'", "'UNBOUNDED'",
		"'UNDEFINED'", "'UNDOFILE'", "'UNDO_BUFFER_SIZE'", "'UNINSTALL'", "'UNKNOWN'",
		"'UNTIL'", "'UPGRADE'", "'USER'", "'USE_FRM'", "'USER_RESOURCES'", "'VALIDATION'",
		"'VALUE'", "'VARIABLES'", "'VIEW'", "'VIRTUAL'", "'VISIBLE'", "'WAIT'",
		"'WARNINGS'", "'WINDOW'", "'WITHOUT'", "'WORK'", "'WRAPPER'", "'X509'",
		"'XA'", "'XML'", "'YES'", "'EUR'", "'USA'", "'JIS'", "'ISO'", "'INTERNAL'",
		"'QUARTER'", "'MONTH'", "'DAY'", "'HOUR'", "'MINUTE'", "'WEEK'", "'SECOND'",
		"'MICROSECOND'", "'TABLES'", "'ROUTINE'", "'EXECUTE'", "'FILE'", "'PROCESS'",
		"'RELOAD'", "'SHUTDOWN'", "'SUPER'", "'PRIVILEGES'", "'APPLICATION_PASSWORD_ADMIN'",
		"'AUDIT_ADMIN'", "'BACKUP_ADMIN'", "'BINLOG_ADMIN'", "'BINLOG_ENCRYPTION_ADMIN'",
		"'CLONE_ADMIN'", "'CONNECTION_ADMIN'", "'ENCRYPTION_KEY_ADMIN'", "'FIREWALL_ADMIN'",
		"'FIREWALL_USER'", "'FLUSH_OPTIMIZER_COSTS'", "'FLUSH_STATUS'", "'FLUSH_TABLES'",
		"'FLUSH_USER_RESOURCES'", "'ADMIN'", "'GROUP_REPLICATION_ADMIN'", "'INNODB_REDO_LOG_ARCHIVE'",
		"'INNODB_REDO_LOG_ENABLE'", "'INVOKE'", "'LAMBDA'", "'NDB_STORED_USER'",
		"'PASSWORDLESS_USER_ADMIN'", "'PERSIST_RO_VARIABLES_ADMIN'", "'REPLICATION_APPLIER'",
		"'REPLICATION_SLAVE_ADMIN'", "'RESOURCE_GROUP_ADMIN'", "'RESOURCE_GROUP_USER'",
		"'ROLE_ADMIN'", "'S3'", "'SERVICE_CONNECTION_ADMIN'", "", "'SET_USER_ID'",
		"'SHOW_ROUTINE'", "'SYSTEM_VARIABLES_ADMIN'", "'TABLE_ENCRYPTION_ADMIN'",
		"'VERSION_TOKEN_ADMIN'", "'XA_RECOVER_ADMIN'", "'ARMSCII8'", "'ASCII'",
		"'BIG5'", "'CP1250'", "'CP1251'", "'CP1256'", "'CP1257'", "'CP850'",
		"'CP852'", "'CP866'", "'CP932'", "'DEC8'", "'EUCJPMS'", "'EUCKR'", "'GB18030'",
		"'GB2312'", "'GBK'", "'GEOSTD8'", "'GREEK'", "'HEBREW'", "'HP8'", "'KEYBCS2'",
		"'KOI8R'", "'KOI8U'", "'LATIN1'", "'LATIN2'", "'LATIN5'", "'LATIN7'",
		"'MACCE'", "'MACROMAN'", "'SJIS'", "'SWE7'", "'TIS620'", "'UCS2'", "'UJIS'",
		"'UTF16'", "'UTF16LE'", "'UTF32'", "'UTF8'", "'UTF8MB3'", "'UTF8MB4'",
		"'ARCHIVE'", "'BLACKHOLE'", "'CSV'", "'FEDERATED'", "'INNODB'", "'MEMORY'",
		"'MRG_MYISAM'", "'MYISAM'", "'NDB'", "'NDBCLUSTER'", "'PERFORMANCE_SCHEMA'",
		"'TOKUDB'", "'REPEATABLE'", "'COMMITTED'", "'UNCOMMITTED'", "'SERIALIZABLE'",
		"'GEOMETRYCOLLECTION'", "'GEOMCOLLECTION'", "'GEOMETRY'", "'LINESTRING'",
		"'MULTILINESTRING'", "'MULTIPOINT'", "'MULTIPOLYGON'", "'POINT'", "'POLYGON'",
		"'ABS'", "'ACOS'", "'ADDDATE'", "'ADDTIME'", "'AES_DECRYPT'", "'AES_ENCRYPT'",
		"'AREA'", "'ASBINARY'", "'ASIN'", "'ASTEXT'", "'ASWKB'", "'ASWKT'",
		"'ASYMMETRIC_DECRYPT'", "'ASYMMETRIC_DERIVE'", "'ASYMMETRIC_ENCRYPT'",
		"'ASYMMETRIC_SIGN'", "'ASYMMETRIC_VERIFY'", "'ATAN'", "'ATAN2'", "'BENCHMARK'",
		"'BIN'", "'BIT_COUNT'", "'BIT_LENGTH'", "'BUFFER'", "'CATALOG_NAME'",
		"'CEIL'", "'CEILING'", "'CENTROID'", "'CHARACTER_LENGTH'", "'CHARSET'",
		"'CHAR_LENGTH'", "'COERCIBILITY'", "'COLLATION'", "'COMPRESS'", "'CONCAT'",
		"'CONCAT_WS'", "'CONNECTION_ID'", "'CONV'", "'CONVERT_TZ'", "'COS'",
		"'COT'", "'CRC32'", "'CREATE_ASYMMETRIC_PRIV_KEY'", "'CREATE_ASYMMETRIC_PUB_KEY'",
		"'CREATE_DH_PARAMETERS'", "'CREATE_DIGEST'", "'CROSSES'", "'DATEDIFF'",
		"'DATE_FORMAT'", "'DAYNAME'", "'DAYOFMONTH'", "'DAYOFWEEK'", "'DAYOFYEAR'",
		"'DECODE'", "'DEGREES'", "'DES_DECRYPT'", "'DES_ENCRYPT'", "'DIMENSION'",
		"'DISJOINT'", "'ELT'", "'ENCODE'", "'ENCRYPT'", "'ENDPOINT'", "'ENGINE_ATTRIBUTE'",
		"'ENVELOPE'", "'EQUALS'", "'EXP'", "'EXPORT_SET'", "'EXTERIORRING'",
		"'EXTRACTVALUE'", "'FIELD'", "'FIND_IN_SET'", "'FLOOR'", "'FORMAT'",
		"'FOUND_ROWS'", "'FROM_BASE64'", "'FROM_DAYS'", "'FROM_UNIXTIME'", "'GEOMCOLLFROMTEXT'",
		"'GEOMCOLLFROMWKB'", "'GEOMETRYCOLLECTIONFROMTEXT'", "'GEOMETRYCOLLECTIONFROMWKB'",
		"'GEOMETRYFROMTEXT'", "'GEOMETRYFROMWKB'", "'GEOMETRYN'", "'GEOMETRYTYPE'",
		"'GEOMFROMTEXT'", "'GEOMFROMWKB'", "'GET_FORMAT'", "'GET_LOCK'", "'GLENGTH'",
		"'GREATEST'", "'GTID_SUBSET'", "'GTID_SUBTRACT'", "'HEX'", "'IFNULL'",
		"'INET6_ATON'", "'INET6_NTOA'", "'INET_ATON'", "'INET_NTOA'", "'INSTR'",
		"'INTERIORRINGN'", "'INTERSECTS'", "'ISCLOSED'", "'ISEMPTY'", "'ISNULL'",
		"'ISSIMPLE'", "'IS_FREE_LOCK'", "'IS_IPV4'", "'IS_IPV4_COMPAT'", "'IS_IPV4_MAPPED'",
		"'IS_IPV6'", "'IS_USED_LOCK'", "'LAST_INSERT_ID'", "'LCASE'", "'LEAST'",
		"'LENGTH'", "'LINEFROMTEXT'", "'LINEFROMWKB'", "'LINESTRINGFROMTEXT'",
		"'LINESTRINGFROMWKB'", "'LN'", "'LOAD_FILE'", "'LOCATE'", "'LOG'", "'LOG10'",
		"'LOG2'", "'LOWER'", "'LPAD'", "'LTRIM'", "'MAKEDATE'", "'MAKETIME'",
		"'MAKE_SET'", "'MASTER_POS_WAIT'", "'MBRCONTAINS'", "'MBRDISJOINT'",
		"'MBREQUAL'", "'MBRINTERSECTS'", "'MBROVERLAPS'", "'MBRTOUCHES'", "'MBRWITHIN'",
		"'MD5'", "'MLINEFROMTEXT'", "'MLINEFROMWKB'", "'MONTHNAME'", "'MPOINTFROMTEXT'",
		"'MPOINTFROMWKB'", "'MPOLYFROMTEXT'", "'MPOLYFROMWKB'", "'MULTILINESTRINGFROMTEXT'",
		"'MULTILINESTRINGFROMWKB'", "'MULTIPOINTFROMTEXT'", "'MULTIPOINTFROMWKB'",
		"'MULTIPOLYGONFROMTEXT'", "'MULTIPOLYGONFROMWKB'", "'NAME_CONST'", "'NULLIF'",
		"'NUMGEOMETRIES'", "'NUMINTERIORRINGS'", "'NUMPOINTS'", "'OCT'", "'OCTET_LENGTH'",
		"'ORD'", "'OVERLAPS'", "'PERIOD_ADD'", "'PERIOD_DIFF'", "'PI'", "'POINTFROMTEXT'",
		"'POINTFROMWKB'", "'POINTN'", "'POLYFROMTEXT'", "'POLYFROMWKB'", "'POLYGONFROMTEXT'",
		"'POLYGONFROMWKB'", "'POW'", "'POWER'", "'QUOTE'", "'RADIANS'", "'RAND'",
		"'RANDOM_BYTES'", "'RELEASE_LOCK'", "'REVERSE'", "'ROUND'", "'ROW_COUNT'",
		"'RPAD'", "'RTRIM'", "'SEC_TO_TIME'", "'SECONDARY_ENGINE_ATTRIBUTE'",
		"'SESSION_USER'", "'SHA'", "'SHA1'", "'SHA2'", "'SCHEMA_NAME'", "'SIGN'",
		"'SIN'", "'SLEEP'", "'SOUNDEX'", "'SQL_THREAD_WAIT_AFTER_GTIDS'", "'SQRT'",
		"'SRID'", "'STARTPOINT'", "'STRCMP'", "'STR_TO_DATE'", "'ST_AREA'",
		"'ST_ASBINARY'", "'ST_ASTEXT'", "'ST_ASWKB'", "'ST_ASWKT'", "'ST_BUFFER'",
		"'ST_CENTROID'", "'ST_CONTAINS'", "'ST_CROSSES'", "'ST_DIFFERENCE'",
		"'ST_DIMENSION'", "'ST_DISJOINT'", "'ST_DISTANCE'", "'ST_ENDPOINT'",
		"'ST_ENVELOPE'", "'ST_EQUALS'", "'ST_EXTERIORRING'", "'ST_GEOMCOLLFROMTEXT'",
		"'ST_GEOMCOLLFROMTXT'", "'ST_GEOMCOLLFROMWKB'", "'ST_GEOMETRYCOLLECTIONFROMTEXT'",
		"'ST_GEOMETRYCOLLECTIONFROMWKB'", "'ST_GEOMETRYFROMTEXT'", "'ST_GEOMETRYFROMWKB'",
		"'ST_GEOMETRYN'", "'ST_GEOMETRYTYPE'", "'ST_GEOMFROMTEXT'", "'ST_GEOMFROMWKB'",
		"'ST_INTERIORRINGN'", "'ST_INTERSECTION'", "'ST_INTERSECTS'", "'ST_ISCLOSED'",
		"'ST_ISEMPTY'", "'ST_ISSIMPLE'", "'ST_LINEFROMTEXT'", "'ST_LINEFROMWKB'",
		"'ST_LINESTRINGFROMTEXT'", "'ST_LINESTRINGFROMWKB'", "'ST_NUMGEOMETRIES'",
		"'ST_NUMINTERIORRING'", "'ST_NUMINTERIORRINGS'", "'ST_NUMPOINTS'", "'ST_OVERLAPS'",
		"'ST_POINTFROMTEXT'", "'ST_POINTFROMWKB'", "'ST_POINTN'", "'ST_POLYFROMTEXT'",
		"'ST_POLYFROMWKB'", "'ST_POLYGONFROMTEXT'", "'ST_POLYGONFROMWKB'", "'ST_SRID'",
		"'ST_STARTPOINT'", "'ST_SYMDIFFERENCE'", "'ST_TOUCHES'", "'ST_UNION'",
		"'ST_WITHIN'", "'ST_X'", "'ST_Y'", "'SUBDATE'", "'SUBSTRING_INDEX'",
		"'SUBTIME'", "'SYSTEM_USER'", "'TAN'", "'TIMEDIFF'", "'TIMESTAMPADD'",
		"'TIMESTAMPDIFF'", "'TIME_FORMAT'", "'TIME_TO_SEC'", "'TOUCHES'", "'TO_BASE64'",
		"'TO_DAYS'", "'TO_SECONDS'", "'UCASE'", "'UNCOMPRESS'", "'UNCOMPRESSED_LENGTH'",
		"'UNHEX'", "'UNIX_TIMESTAMP'", "'UPDATEXML'", "'UPPER'", "'UUID'", "'UUID_SHORT'",
		"'VALIDATE_PASSWORD_STRENGTH'", "'VERSION'", "'WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS'",
		"'WEEKDAY'", "'WEEKOFYEAR'", "'WEIGHT_STRING'", "'WITHIN'", "'YEARWEEK'",
		"'Y'", "'X'", "'VIA'", "'LASTVAL'", "'NEXTVAL'", "'SETVAL'", "'PREVIOUS'",
		"'PERSISTENT'", "'BINLOG_MONITOR'", "'BINLOG_REPLAY'", "'FEDERATED_ADMIN'",
		"'READ_ONLY_ADMIN'", "'REPLICA'", "'REPLICATION_MASTER_ADMIN'", "':='",
		"'+='", "'-='", "'*='", "'/='", "'%='", "'&='", "'^='", "'|='", "'*'",
		"'/'", "'%'", "'+'", "'-'", "'DIV'", "'MOD'", "'='", "'>'", "'<'", "'!'",
		"'~'", "'|'", "'&'", "'^'", "'.'", "'('", "')'", "','", "';'", "'@'",
		"'0'", "'1'", "'2'", "'''", "'\"'", "'`'", "':'",
	}
	staticData.symbolicNames = []string{
		"", "SPACE", "SPEC_MYSQL_COMMENT", "COMMENT_INPUT", "LINE_COMMENT",
		"ADD", "ALL", "ALTER", "ALWAYS", "ANALYZE", "AND", "ARRAY", "AS", "ASC",
		"BEFORE", "BETWEEN", "BOTH", "BUCKETS", "BY", "CALL", "CASCADE", "CASE",
		"CAST", "CHANGE", "CHARACTER", "CHECK", "COLLATE", "COLUMN", "CONDITION",
		"CONSTRAINT", "CONTINUE", "CONVERT", "CREATE", "CROSS", "CURRENT", "CURRENT_USER",
		"CURSOR", "DATABASE", "DATABASES", "DECLARE", "DEFAULT", "DELAYED",
		"DELETE", "DESC", "DESCRIBE", "DETERMINISTIC", "DIAGNOSTICS", "DISTINCT",
		"DISTINCTROW", "DROP", "EACH", "ELSE", "ELSEIF", "EMPTY", "ENCLOSED",
		"ESCAPED", "EXCEPT", "EXISTS", "EXIT", "EXPLAIN", "FALSE", "FETCH",
		"FOR", "FORCE", "FOREIGN", "FROM", "FULLTEXT", "GENERATED", "GET", "GRANT",
		"GROUP", "HAVING", "HIGH_PRIORITY", "HISTOGRAM", "IF", "IGNORE", "IGNORED",
		"IN", "INDEX", "INFILE", "INNER", "INOUT", "INSERT", "INTERVAL", "INTO",
		"IS", "ITERATE", "JOIN", "KEY", "KEYS", "KILL", "LEADING", "LEAVE",
		"LEFT", "LIKE", "LIMIT", "LINEAR", "LINES", "LOAD", "LOCK", "LOCKED",
		"LOOP", "LOW_PRIORITY", "MASTER_BIND", "MASTER_SSL_VERIFY_SERVER_CERT",
		"MATCH", "MAXVALUE", "MINVALUE", "MODIFIES", "NATURAL", "NOT", "NO_WRITE_TO_BINLOG",
		"NULL_LITERAL", "NUMBER", "ON", "OPTIMIZE", "OPTION", "OPTIONAL", "OPTIONALLY",
		"OR", "ORDER", "OUT", "OVER", "OUTER", "OUTFILE", "PARTITION", "PRIMARY",
		"PROCEDURE", "PURGE", "RANGE", "READ", "READS", "REFERENCES", "REGEXP",
		"RELEASE", "RENAME", "REPEAT", "REPLACE", "REQUIRE", "RESIGNAL", "RESTRICT",
		"RETAIN", "RETURN", "REVOKE", "RIGHT", "RLIKE", "SCHEMA", "SCHEMAS",
		"SELECT", "SET", "SEPARATOR", "SHOW", "SIGNAL", "SKIP_", "SPATIAL",
		"SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT", "SQL_CALC_FOUND_ROWS",
		"SQL_SMALL_RESULT", "SSL", "STACKED", "STARTING", "STRAIGHT_JOIN", "TABLE",
		"TERMINATED", "THEN", "TO", "TRAILING", "TRIGGER", "TRUE", "UNDO", "UNION",
		"UNIQUE", "UNLOCK", "UNSIGNED", "UPDATE", "USAGE", "USE", "USING", "VALUES",
		"WHEN", "WHERE", "WHILE", "WITH", "WRITE", "XOR", "ZEROFILL", "TINYINT",
		"SMALLINT", "MEDIUMINT", "MIDDLEINT", "INT", "INT1", "INT2", "INT3",
		"INT4", "INT8", "INTEGER", "BIGINT", "REAL", "DOUBLE", "PRECISION",
		"FLOAT", "FLOAT4", "FLOAT8", "DECIMAL", "DEC", "NUMERIC", "DATE", "TIME",
		"TIMESTAMP", "DATETIME", "YEAR", "CHAR", "VARCHAR", "NVARCHAR", "NATIONAL",
		"BINARY", "VARBINARY", "TINYBLOB", "BLOB", "MEDIUMBLOB", "LONG", "LONGBLOB",
		"TINYTEXT", "TEXT", "MEDIUMTEXT", "LONGTEXT", "ENUM", "VARYING", "SERIAL",
		"YEAR_MONTH", "DAY_HOUR", "DAY_MINUTE", "DAY_SECOND", "HOUR_MINUTE",
		"HOUR_SECOND", "MINUTE_SECOND", "SECOND_MICROSECOND", "MINUTE_MICROSECOND",
		"HOUR_MICROSECOND", "DAY_MICROSECOND", "JSON_ARRAY", "JSON_OBJECT",
		"JSON_QUOTE", "JSON_CONTAINS", "JSON_CONTAINS_PATH", "JSON_EXTRACT",
		"JSON_KEYS", "JSON_OVERLAPS", "JSON_SEARCH", "JSON_VALUE", "JSON_ARRAY_APPEND",
		"JSON_ARRAY_INSERT", "JSON_INSERT", "JSON_MERGE", "JSON_MERGE_PATCH",
		"JSON_MERGE_PRESERVE", "JSON_REMOVE", "JSON_REPLACE", "JSON_SET", "JSON_UNQUOTE",
		"JSON_DEPTH", "JSON_LENGTH", "JSON_TYPE", "JSON_VALID", "JSON_TABLE",
		"JSON_SCHEMA_VALID", "JSON_SCHEMA_VALIDATION_REPORT", "JSON_PRETTY",
		"JSON_STORAGE_FREE", "JSON_STORAGE_SIZE", "JSON_ARRAYAGG", "JSON_OBJECTAGG",
		"AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "COUNT", "CUME_DIST", "DENSE_RANK",
		"FIRST_VALUE", "GROUP_CONCAT", "LAG", "LAST_VALUE", "LEAD", "MAX", "MIN",
		"NTILE", "NTH_VALUE", "PERCENT_RANK", "RANK", "ROW_NUMBER", "STD", "STDDEV",
		"STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP", "VARIANCE",
		"CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "LOCALTIME", "CURDATE",
		"CURTIME", "DATE_ADD", "DATE_SUB", "EXTRACT", "LOCALTIMESTAMP", "NOW",
		"POSITION", "SUBSTR", "SUBSTRING", "SYSDATE", "TRIM", "UTC_DATE", "UTC_TIME",
		"UTC_TIMESTAMP", "ACCOUNT", "ACTION", "AFTER", "AGGREGATE", "ALGORITHM",
		"ANY", "AT", "AUTHORS", "AUTOCOMMIT", "AUTOEXTEND_SIZE", "AUTO_INCREMENT",
		"AVG_ROW_LENGTH", "BEGIN", "BINLOG", "BIT", "BLOCK", "BOOL", "BOOLEAN",
		"BTREE", "CACHE", "CASCADED", "CHAIN", "CHANGED", "CHANNEL", "CHECKSUM",
		"PAGE_CHECKSUM", "CIPHER", "CLASS_ORIGIN", "CLIENT", "CLOSE", "CLUSTERING",
		"COALESCE", "CODE", "COLUMNS", "COLUMN_FORMAT", "COLUMN_NAME", "COMMENT",
		"COMMIT", "COMPACT", "COMPLETION", "COMPRESSED", "COMPRESSION", "CONCURRENT",
		"CONNECT", "CONNECTION", "CONSISTENT", "CONSTRAINT_CATALOG", "CONSTRAINT_SCHEMA",
		"CONSTRAINT_NAME", "CONTAINS", "CONTEXT", "CONTRIBUTORS", "COPY", "CPU",
		"CYCLE", "CURSOR_NAME", "DATA", "DATAFILE", "DEALLOCATE", "DEFAULT_AUTH",
		"DEFINER", "DELAY_KEY_WRITE", "DES_KEY_FILE", "DIRECTORY", "DISABLE",
		"DISCARD", "DISK", "DO", "DUMPFILE", "DUPLICATE", "DYNAMIC", "ENABLE",
		"ENCRYPTION", "END", "ENDS", "ENGINE", "ENGINES", "ERROR", "ERRORS",
		"ESCAPE", "EVEN", "EVENT", "EVENTS", "EVERY", "EXCHANGE", "EXCLUSIVE",
		"EXPIRE", "EXPORT", "EXTENDED", "EXTENT_SIZE", "FAST", "FAULTS", "FIELDS",
		"FILE_BLOCK_SIZE", "FILTER", "FIRST", "FIXED", "FLUSH", "FOLLOWING",
		"FOLLOWS", "FOUND", "FULL", "FUNCTION", "GENERAL", "GLOBAL", "GRANTS",
		"GROUP_REPLICATION", "HANDLER", "HASH", "HELP", "HOST", "HOSTS", "IDENTIFIED",
		"IGNORE_SERVER_IDS", "IMPORT", "INCREMENT", "INDEXES", "INITIAL_SIZE",
		"INPLACE", "INSERT_METHOD", "INSTALL", "INSTANCE", "INSTANT", "INVISIBLE",
		"INVOKER", "IO", "IO_THREAD", "IPC", "ISOLATION", "ISSUER", "JSON",
		"KEY_BLOCK_SIZE", "LANGUAGE", "LAST", "LEAVES", "LESS", "LEVEL", "LIST",
		"LOCAL", "LOGFILE", "LOGS", "MASTER", "MASTER_AUTO_POSITION", "MASTER_CONNECT_RETRY",
		"MASTER_DELAY", "MASTER_HEARTBEAT_PERIOD", "MASTER_HOST", "MASTER_LOG_FILE",
		"MASTER_LOG_POS", "MASTER_PASSWORD", "MASTER_PORT", "MASTER_RETRY_COUNT",
		"MASTER_SSL", "MASTER_SSL_CA", "MASTER_SSL_CAPATH", "MASTER_SSL_CERT",
		"MASTER_SSL_CIPHER", "MASTER_SSL_CRL", "MASTER_SSL_CRLPATH", "MASTER_SSL_KEY",
		"MASTER_TLS_VERSION", "MASTER_USER", "MAX_CONNECTIONS_PER_HOUR", "MAX_QUERIES_PER_HOUR",
		"MAX_ROWS", "MAX_SIZE", "MAX_UPDATES_PER_HOUR", "MAX_USER_CONNECTIONS",
		"MEDIUM", "MEMBER", "MERGE", "MESSAGE_TEXT", "MID", "MIGRATE", "MIN_ROWS",
		"MODE", "MODIFY", "MUTEX", "MYSQL", "MYSQL_ERRNO", "NAME", "NAMES",
		"NCHAR", "NEVER", "NEXT", "NO", "NOCACHE", "NOCOPY", "NOCYCLE", "NOMAXVALUE",
		"NOMINVALUE", "NOWAIT", "NODEGROUP", "NONE", "ODBC", "OFFLINE", "OFFSET",
		"OF", "OJ", "OLD_PASSWORD", "ONE", "ONLINE", "ONLY", "OPEN", "OPTIMIZER_COSTS",
		"OPTIONS", "OWNER", "PACK_KEYS", "PAGE", "PARSER", "PARTIAL", "PARTITIONING",
		"PARTITIONS", "PASSWORD", "PHASE", "PLUGIN", "PLUGIN_DIR", "PLUGINS",
		"PORT", "PRECEDES", "PRECEDING", "PREPARE", "PRESERVE", "PREV", "PROCESSLIST",
		"PROFILE", "PROFILES", "PROXY", "QUERY", "QUICK", "REBUILD", "RECOVER",
		"RECURSIVE", "REDO_BUFFER_SIZE", "REDUNDANT", "RELAY", "RELAY_LOG_FILE",
		"RELAY_LOG_POS", "RELAYLOG", "REMOVE", "REORGANIZE", "REPAIR", "REPLICATE_DO_DB",
		"REPLICATE_DO_TABLE", "REPLICATE_IGNORE_DB", "REPLICATE_IGNORE_TABLE",
		"REPLICATE_REWRITE_DB", "REPLICATE_WILD_DO_TABLE", "REPLICATE_WILD_IGNORE_TABLE",
		"REPLICATION", "RESET", "RESTART", "RESUME", "RETURNED_SQLSTATE", "RETURNING",
		"RETURNS", "ROLE", "ROLLBACK", "ROLLUP", "ROTATE", "ROW", "ROWS", "ROW_FORMAT",
		"RTREE", "SAVEPOINT", "SCHEDULE", "SECURITY", "SEQUENCE", "SERVER",
		"SESSION", "SHARE", "SHARED", "SIGNED", "SIMPLE", "SLAVE", "SLOW", "SNAPSHOT",
		"SOCKET", "SOME", "SONAME", "SOUNDS", "SOURCE", "SQL_AFTER_GTIDS", "SQL_AFTER_MTS_GAPS",
		"SQL_BEFORE_GTIDS", "SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_NO_CACHE",
		"SQL_THREAD", "START", "STARTS", "STATS_AUTO_RECALC", "STATS_PERSISTENT",
		"STATS_SAMPLE_PAGES", "STATUS", "STOP", "STORAGE", "STORED", "STRING",
		"SUBCLASS_ORIGIN", "SUBJECT", "SUBPARTITION", "SUBPARTITIONS", "SUSPEND",
		"SWAPS", "SWITCHES", "TABLE_NAME", "TABLESPACE", "TABLE_TYPE", "TEMPORARY",
		"TEMPTABLE", "THAN", "TRADITIONAL", "TRANSACTION", "TRANSACTIONAL",
		"TRIGGERS", "TRUNCATE", "UNBOUNDED", "UNDEFINED", "UNDOFILE", "UNDO_BUFFER_SIZE",
		"UNINSTALL", "UNKNOWN", "UNTIL", "UPGRADE", "USER", "USE_FRM", "USER_RESOURCES",
		"VALIDATION", "VALUE", "VARIABLES", "VIEW", "VIRTUAL", "VISIBLE", "WAIT",
		"WARNINGS", "WINDOW", "WITHOUT", "WORK", "WRAPPER", "X509", "XA", "XML",
		"YES", "EUR", "USA", "JIS", "ISO", "INTERNAL", "QUARTER", "MONTH", "DAY",
		"HOUR", "MINUTE", "WEEK", "SECOND", "MICROSECOND", "TABLES", "ROUTINE",
		"EXECUTE", "FILE", "PROCESS", "RELOAD", "SHUTDOWN", "SUPER", "PRIVILEGES",
		"APPLICATION_PASSWORD_ADMIN", "AUDIT_ADMIN", "BACKUP_ADMIN", "BINLOG_ADMIN",
		"BINLOG_ENCRYPTION_ADMIN", "CLONE_ADMIN", "CONNECTION_ADMIN", "ENCRYPTION_KEY_ADMIN",
		"FIREWALL_ADMIN", "FIREWALL_USER", "FLUSH_OPTIMIZER_COSTS", "FLUSH_STATUS",
		"FLUSH_TABLES", "FLUSH_USER_RESOURCES", "ADMIN", "GROUP_REPLICATION_ADMIN",
		"INNODB_REDO_LOG_ARCHIVE", "INNODB_REDO_LOG_ENABLE", "INVOKE", "LAMBDA",
		"NDB_STORED_USER", "PASSWORDLESS_USER_ADMIN", "PERSIST_RO_VARIABLES_ADMIN",
		"REPLICATION_APPLIER", "REPLICATION_SLAVE_ADMIN", "RESOURCE_GROUP_ADMIN",
		"RESOURCE_GROUP_USER", "ROLE_ADMIN", "S3", "SERVICE_CONNECTION_ADMIN",
		"SESSION_VARIABLES_ADMIN", "SET_USER_ID", "SHOW_ROUTINE", "SYSTEM_VARIABLES_ADMIN",
		"TABLE_ENCRYPTION_ADMIN", "VERSION_TOKEN_ADMIN", "XA_RECOVER_ADMIN",
		"ARMSCII8", "ASCII", "BIG5", "CP1250", "CP1251", "CP1256", "CP1257",
		"CP850", "CP852", "CP866", "CP932", "DEC8", "EUCJPMS", "EUCKR", "GB18030",
		"GB2312", "GBK", "GEOSTD8", "GREEK", "HEBREW", "HP8", "KEYBCS2", "KOI8R",
		"KOI8U", "LATIN1", "LATIN2", "LATIN5", "LATIN7", "MACCE", "MACROMAN",
		"SJIS", "SWE7", "TIS620", "UCS2", "UJIS", "UTF16", "UTF16LE", "UTF32",
		"UTF8", "UTF8MB3", "UTF8MB4", "ARCHIVE", "BLACKHOLE", "CSV", "FEDERATED",
		"INNODB", "MEMORY", "MRG_MYISAM", "MYISAM", "NDB", "NDBCLUSTER", "PERFORMANCE_SCHEMA",
		"TOKUDB", "REPEATABLE", "COMMITTED", "UNCOMMITTED", "SERIALIZABLE",
		"GEOMETRYCOLLECTION", "GEOMCOLLECTION", "GEOMETRY", "LINESTRING", "MULTILINESTRING",
		"MULTIPOINT", "MULTIPOLYGON", "POINT", "POLYGON", "ABS", "ACOS", "ADDDATE",
		"ADDTIME", "AES_DECRYPT", "AES_ENCRYPT", "AREA", "ASBINARY", "ASIN",
		"ASTEXT", "ASWKB", "ASWKT", "ASYMMETRIC_DECRYPT", "ASYMMETRIC_DERIVE",
		"ASYMMETRIC_ENCRYPT", "ASYMMETRIC_SIGN", "ASYMMETRIC_VERIFY", "ATAN",
		"ATAN2", "BENCHMARK", "BIN", "BIT_COUNT", "BIT_LENGTH", "BUFFER", "CATALOG_NAME",
		"CEIL", "CEILING", "CENTROID", "CHARACTER_LENGTH", "CHARSET", "CHAR_LENGTH",
		"COERCIBILITY", "COLLATION", "COMPRESS", "CONCAT", "CONCAT_WS", "CONNECTION_ID",
		"CONV", "CONVERT_TZ", "COS", "COT", "CRC32", "CREATE_ASYMMETRIC_PRIV_KEY",
		"CREATE_ASYMMETRIC_PUB_KEY", "CREATE_DH_PARAMETERS", "CREATE_DIGEST",
		"CROSSES", "DATEDIFF", "DATE_FORMAT", "DAYNAME", "DAYOFMONTH", "DAYOFWEEK",
		"DAYOFYEAR", "DECODE", "DEGREES", "DES_DECRYPT", "DES_ENCRYPT", "DIMENSION",
		"DISJOINT", "ELT", "ENCODE", "ENCRYPT", "ENDPOINT", "ENGINE_ATTRIBUTE",
		"ENVELOPE", "EQUALS", "EXP", "EXPORT_SET", "EXTERIORRING", "EXTRACTVALUE",
		"FIELD", "FIND_IN_SET", "FLOOR", "FORMAT", "FOUND_ROWS", "FROM_BASE64",
		"FROM_DAYS", "FROM_UNIXTIME", "GEOMCOLLFROMTEXT", "GEOMCOLLFROMWKB",
		"GEOMETRYCOLLECTIONFROMTEXT", "GEOMETRYCOLLECTIONFROMWKB", "GEOMETRYFROMTEXT",
		"GEOMETRYFROMWKB", "GEOMETRYN", "GEOMETRYTYPE", "GEOMFROMTEXT", "GEOMFROMWKB",
		"GET_FORMAT", "GET_LOCK", "GLENGTH", "GREATEST", "GTID_SUBSET", "GTID_SUBTRACT",
		"HEX", "IFNULL", "INET6_ATON", "INET6_NTOA", "INET_ATON", "INET_NTOA",
		"INSTR", "INTERIORRINGN", "INTERSECTS", "ISCLOSED", "ISEMPTY", "ISNULL",
		"ISSIMPLE", "IS_FREE_LOCK", "IS_IPV4", "IS_IPV4_COMPAT", "IS_IPV4_MAPPED",
		"IS_IPV6", "IS_USED_LOCK", "LAST_INSERT_ID", "LCASE", "LEAST", "LENGTH",
		"LINEFROMTEXT", "LINEFROMWKB", "LINESTRINGFROMTEXT", "LINESTRINGFROMWKB",
		"LN", "LOAD_FILE", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD",
		"LTRIM", "MAKEDATE", "MAKETIME", "MAKE_SET", "MASTER_POS_WAIT", "MBRCONTAINS",
		"MBRDISJOINT", "MBREQUAL", "MBRINTERSECTS", "MBROVERLAPS", "MBRTOUCHES",
		"MBRWITHIN", "MD5", "MLINEFROMTEXT", "MLINEFROMWKB", "MONTHNAME", "MPOINTFROMTEXT",
		"MPOINTFROMWKB", "MPOLYFROMTEXT", "MPOLYFROMWKB", "MULTILINESTRINGFROMTEXT",
		"MULTILINESTRINGFROMWKB", "MULTIPOINTFROMTEXT", "MULTIPOINTFROMWKB",
		"MULTIPOLYGONFROMTEXT", "MULTIPOLYGONFROMWKB", "NAME_CONST", "NULLIF",
		"NUMGEOMETRIES", "NUMINTERIORRINGS", "NUMPOINTS", "OCT", "OCTET_LENGTH",
		"ORD", "OVERLAPS", "PERIOD_ADD", "PERIOD_DIFF", "PI", "POINTFROMTEXT",
		"POINTFROMWKB", "POINTN", "POLYFROMTEXT", "POLYFROMWKB", "POLYGONFROMTEXT",
		"POLYGONFROMWKB", "POW", "POWER", "QUOTE", "RADIANS", "RAND", "RANDOM_BYTES",
		"RELEASE_LOCK", "REVERSE", "ROUND", "ROW_COUNT", "RPAD", "RTRIM", "SEC_TO_TIME",
		"SECONDARY_ENGINE_ATTRIBUTE", "SESSION_USER", "SHA", "SHA1", "SHA2",
		"SCHEMA_NAME", "SIGN", "SIN", "SLEEP", "SOUNDEX", "SQL_THREAD_WAIT_AFTER_GTIDS",
		"SQRT", "SRID", "STARTPOINT", "STRCMP", "STR_TO_DATE", "ST_AREA", "ST_ASBINARY",
		"ST_ASTEXT", "ST_ASWKB", "ST_ASWKT", "ST_BUFFER", "ST_CENTROID", "ST_CONTAINS",
		"ST_CROSSES", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE",
		"ST_ENDPOINT", "ST_ENVELOPE", "ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMCOLLFROMTEXT",
		"ST_GEOMCOLLFROMTXT", "ST_GEOMCOLLFROMWKB", "ST_GEOMETRYCOLLECTIONFROMTEXT",
		"ST_GEOMETRYCOLLECTIONFROMWKB", "ST_GEOMETRYFROMTEXT", "ST_GEOMETRYFROMWKB",
		"ST_GEOMETRYN", "ST_GEOMETRYTYPE", "ST_GEOMFROMTEXT", "ST_GEOMFROMWKB",
		"ST_INTERIORRINGN", "ST_INTERSECTION", "ST_INTERSECTS", "ST_ISCLOSED",
		"ST_ISEMPTY", "ST_ISSIMPLE", "ST_LINEFROMTEXT", "ST_LINEFROMWKB", "ST_LINESTRINGFROMTEXT",
		"ST_LINESTRINGFROMWKB", "ST_NUMGEOMETRIES", "ST_NUMINTERIORRING", "ST_NUMINTERIORRINGS",
		"ST_NUMPOINTS", "ST_OVERLAPS", "ST_POINTFROMTEXT", "ST_POINTFROMWKB",
		"ST_POINTN", "ST_POLYFROMTEXT", "ST_POLYFROMWKB", "ST_POLYGONFROMTEXT",
		"ST_POLYGONFROMWKB", "ST_SRID", "ST_STARTPOINT", "ST_SYMDIFFERENCE",
		"ST_TOUCHES", "ST_UNION", "ST_WITHIN", "ST_X", "ST_Y", "SUBDATE", "SUBSTRING_INDEX",
		"SUBTIME", "SYSTEM_USER", "TAN", "TIMEDIFF", "TIMESTAMPADD", "TIMESTAMPDIFF",
		"TIME_FORMAT", "TIME_TO_SEC", "TOUCHES", "TO_BASE64", "TO_DAYS", "TO_SECONDS",
		"UCASE", "UNCOMPRESS", "UNCOMPRESSED_LENGTH", "UNHEX", "UNIX_TIMESTAMP",
		"UPDATEXML", "UPPER", "UUID", "UUID_SHORT", "VALIDATE_PASSWORD_STRENGTH",
		"VERSION", "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS", "WEEKDAY", "WEEKOFYEAR",
		"WEIGHT_STRING", "WITHIN", "YEARWEEK", "Y_FUNCTION", "X_FUNCTION", "VIA",
		"LASTVAL", "NEXTVAL", "SETVAL", "PREVIOUS", "PERSISTENT", "BINLOG_MONITOR",
		"BINLOG_REPLAY", "FEDERATED_ADMIN", "READ_ONLY_ADMIN", "REPLICA", "REPLICATION_MASTER_ADMIN",
		"VAR_ASSIGN", "PLUS_ASSIGN", "MINUS_ASSIGN", "MULT_ASSIGN", "DIV_ASSIGN",
		"MOD_ASSIGN", "AND_ASSIGN", "XOR_ASSIGN", "OR_ASSIGN", "STAR", "DIVIDE",
		"MODULE", "PLUS", "MINUS", "DIV", "MOD", "EQUAL_SYMBOL", "GREATER_SYMBOL",
		"LESS_SYMBOL", "EXCLAMATION_SYMBOL", "BIT_NOT_OP", "BIT_OR_OP", "BIT_AND_OP",
		"BIT_XOR_OP", "DOT", "LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", "AT_SIGN",
		"ZERO_DECIMAL", "ONE_DECIMAL", "TWO_DECIMAL", "SINGLE_QUOTE_SYMB", "DOUBLE_QUOTE_SYMB",
		"REVERSE_QUOTE_SYMB", "COLON_SYMB", "CHARSET_REVERSE_QOUTE_STRING",
		"FILESIZE_LITERAL", "START_NATIONAL_STRING_LITERAL", "STRING_LITERAL",
		"DECIMAL_LITERAL", "HEXADECIMAL_LITERAL", "REAL_LITERAL", "NULL_SPEC_LITERAL",
		"BIT_STRING", "STRING_CHARSET_NAME", "DOT_ID", "ID", "REVERSE_QUOTE_ID",
		"STRING_USER_NAME", "IP_ADDRESS", "STRING_USER_NAME_MARIADB", "LOCAL_ID",
		"GLOBAL_ID", "ERROR_RECONGNIGION",
	}
	staticData.ruleNames = []string{
		"prog", "sqlStatement", "charSet", "intervalType", "indexType", "indexOption",
		"createDefinitions", "createDefinition", "columnDefinition", "columnConstraint",
		"tableConstraint", "referenceDefinition", "referenceAction", "referenceControlType",
		"indexColumnDefinition", "tableOption", "tableType", "tablespaceStorage",
		"partitionDefinitions", "partitionFunctionDefinition", "subpartitionFunctionDefinition",
		"partitionDefinition", "partitionDefinerAtom", "partitionDefinerVector",
		"subpartitionDefinition", "partitionOption", "fullId", "tableName",
		"fullColumnName", "indexColumnName", "mysqlVariable", "charsetName",
		"collationName", "engineName", "uid", "simpleId", "dottedId", "decimalLiteral",
		"fileSizeLiteral", "stringLiteral", "booleanLiteral", "hexadecimalLiteral",
		"nullNotnull", "constant", "dataType", "collectionOptions", "convertedDataType",
		"lengthOneDimension", "lengthTwoDimension", "lengthTwoOptionalDimension",
		"uidList", "tables", "indexColumnNames", "defaultValue", "currentTimestamp",
		"ifNotExists", "scalarFunctionName", "expression", "predicate", "expressionAtom",
		"unaryOperator", "comparisonOperator", "logicalOperator", "bitOperator",
		"mathOperator", "jsonOperator", "charsetNameBase", "transactionLevelBase",
		"privilegesBase", "intervalTypeBase", "dataTypeBase", "keywordsCanBeId",
		"functionNameBase",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 1153, 1572, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 1, 0,
		1, 0, 3, 0, 149, 8, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 3, 1, 156, 8, 1, 1,
		1, 3, 1, 159, 8, 1, 1, 1, 1, 1, 3, 1, 163, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		3, 1, 169, 8, 1, 1, 1, 5, 1, 172, 8, 1, 10, 1, 12, 1, 175, 9, 1, 3, 1,
		177, 8, 1, 1, 1, 3, 1, 180, 8, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 187,
		8, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 3, 3, 202, 8, 3, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 3, 5, 209, 8,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 221,
		8, 5, 1, 5, 1, 5, 1, 5, 3, 5, 226, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 3, 5, 235, 8, 5, 3, 5, 237, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 5,
		6, 243, 8, 6, 10, 6, 12, 6, 246, 9, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1,
		7, 1, 7, 3, 7, 255, 8, 7, 1, 8, 1, 8, 5, 8, 259, 8, 8, 10, 8, 12, 8, 262,
		9, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 273,
		8, 9, 1, 9, 3, 9, 276, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 281, 8, 9, 1, 9, 1,
		9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 294, 8,
		9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 301, 8, 9, 1, 9, 1, 9, 1, 9, 1,
		9, 1, 9, 3, 9, 308, 8, 9, 3, 9, 310, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		3, 9, 317, 8, 9, 1, 10, 1, 10, 3, 10, 321, 8, 10, 3, 10, 323, 8, 10, 1,
		10, 1, 10, 1, 10, 3, 10, 328, 8, 10, 1, 10, 3, 10, 331, 8, 10, 1, 10, 1,
		10, 5, 10, 335, 8, 10, 10, 10, 12, 10, 338, 9, 10, 1, 10, 1, 10, 3, 10,
		342, 8, 10, 3, 10, 344, 8, 10, 1, 10, 1, 10, 3, 10, 348, 8, 10, 1, 10,
		3, 10, 351, 8, 10, 1, 10, 3, 10, 354, 8, 10, 1, 10, 1, 10, 5, 10, 358,
		8, 10, 10, 10, 12, 10, 361, 9, 10, 1, 10, 1, 10, 3, 10, 365, 8, 10, 3,
		10, 367, 8, 10, 1, 10, 1, 10, 1, 10, 3, 10, 372, 8, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 3, 10, 379, 8, 10, 3, 10, 381, 8, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 3, 10, 388, 8, 10, 1, 11, 1, 11, 1, 11, 3, 11, 393, 8,
		11, 1, 11, 1, 11, 3, 11, 397, 8, 11, 1, 11, 3, 11, 400, 8, 11, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 408, 8, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 3, 12, 416, 8, 12, 3, 12, 418, 8, 12, 1, 13, 1, 13,
		1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 426, 8, 13, 1, 14, 1, 14, 3, 14, 430,
		8, 14, 1, 14, 3, 14, 433, 8, 14, 1, 14, 1, 14, 5, 14, 437, 8, 14, 10, 14,
		12, 14, 440, 9, 14, 1, 14, 1, 14, 3, 14, 444, 8, 14, 1, 14, 3, 14, 447,
		8, 14, 1, 14, 1, 14, 5, 14, 451, 8, 14, 10, 14, 12, 14, 454, 9, 14, 3,
		14, 456, 8, 14, 1, 15, 1, 15, 3, 15, 460, 8, 15, 1, 15, 3, 15, 463, 8,
		15, 1, 15, 1, 15, 3, 15, 467, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 472, 8,
		15, 1, 15, 1, 15, 1, 15, 3, 15, 477, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15,
		482, 8, 15, 1, 15, 1, 15, 3, 15, 486, 8, 15, 1, 15, 1, 15, 3, 15, 490,
		8, 15, 1, 15, 1, 15, 3, 15, 494, 8, 15, 1, 15, 1, 15, 3, 15, 498, 8, 15,
		1, 15, 1, 15, 3, 15, 502, 8, 15, 1, 15, 1, 15, 3, 15, 506, 8, 15, 1, 15,
		1, 15, 1, 15, 3, 15, 511, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 516, 8, 15,
		1, 15, 1, 15, 1, 15, 3, 15, 521, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3,
		15, 527, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 532, 8, 15, 1, 15, 1, 15, 1,
		15, 3, 15, 537, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 543, 8, 15, 1,
		15, 1, 15, 1, 15, 3, 15, 548, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 553, 8,
		15, 1, 15, 1, 15, 1, 15, 3, 15, 558, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15,
		563, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 568, 8, 15, 1, 15, 1, 15, 1, 15,
		3, 15, 573, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 578, 8, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 3, 15, 585, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 590,
		8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 595, 8, 15, 1, 15, 1, 15, 1, 15, 3,
		15, 600, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 606, 8, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 614, 8, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 3, 15, 620, 8, 15, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 18, 1,
		18, 1, 18, 1, 18, 1, 18, 3, 18, 632, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18,
		1, 18, 3, 18, 639, 8, 18, 3, 18, 641, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18,
		5, 18, 647, 8, 18, 10, 18, 12, 18, 650, 9, 18, 1, 18, 1, 18, 3, 18, 654,
		8, 18, 1, 19, 3, 19, 657, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 3, 19, 665, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 671, 8, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19,
		1, 19, 1, 19, 1, 19, 3, 19, 687, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 699, 8, 19, 3, 19, 701, 8,
		19, 1, 20, 3, 20, 704, 8, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20,
		3, 20, 712, 8, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 718, 8, 20, 1, 20,
		1, 20, 1, 20, 1, 20, 3, 20, 724, 8, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1,
		21, 1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 735, 8, 21, 10, 21, 12, 21, 738,
		9, 21, 1, 21, 1, 21, 5, 21, 742, 8, 21, 10, 21, 12, 21, 745, 9, 21, 1,
		21, 1, 21, 1, 21, 1, 21, 5, 21, 751, 8, 21, 10, 21, 12, 21, 754, 9, 21,
		1, 21, 1, 21, 3, 21, 758, 8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1,
		21, 1, 21, 5, 21, 767, 8, 21, 10, 21, 12, 21, 770, 9, 21, 1, 21, 1, 21,
		1, 21, 1, 21, 5, 21, 776, 8, 21, 10, 21, 12, 21, 779, 9, 21, 1, 21, 1,
		21, 3, 21, 783, 8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21,
		1, 21, 5, 21, 793, 8, 21, 10, 21, 12, 21, 796, 9, 21, 1, 21, 1, 21, 5,
		21, 800, 8, 21, 10, 21, 12, 21, 803, 9, 21, 1, 21, 1, 21, 1, 21, 1, 21,
		5, 21, 809, 8, 21, 10, 21, 12, 21, 812, 9, 21, 1, 21, 1, 21, 3, 21, 816,
		8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 826,
		8, 21, 10, 21, 12, 21, 829, 9, 21, 1, 21, 1, 21, 5, 21, 833, 8, 21, 10,
		21, 12, 21, 836, 9, 21, 1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 842, 8, 21,
		10, 21, 12, 21, 845, 9, 21, 1, 21, 1, 21, 3, 21, 849, 8, 21, 1, 21, 1,
		21, 1, 21, 5, 21, 854, 8, 21, 10, 21, 12, 21, 857, 9, 21, 1, 21, 1, 21,
		1, 21, 1, 21, 5, 21, 863, 8, 21, 10, 21, 12, 21, 866, 9, 21, 1, 21, 1,
		21, 3, 21, 870, 8, 21, 3, 21, 872, 8, 21, 1, 22, 1, 22, 1, 22, 3, 22, 877,
		8, 22, 1, 23, 1, 23, 1, 23, 1, 23, 4, 23, 883, 8, 23, 11, 23, 12, 23, 884,
		1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 5, 24, 892, 8, 24, 10, 24, 12, 24, 895,
		9, 24, 1, 25, 3, 25, 898, 8, 25, 1, 25, 3, 25, 901, 8, 25, 1, 25, 1, 25,
		3, 25, 905, 8, 25, 1, 25, 1, 25, 1, 25, 3, 25, 910, 8, 25, 1, 25, 1, 25,
		1, 25, 1, 25, 3, 25, 916, 8, 25, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 922,
		8, 25, 1, 25, 1, 25, 1, 25, 3, 25, 927, 8, 25, 1, 25, 1, 25, 1, 25, 3,
		25, 932, 8, 25, 1, 25, 1, 25, 1, 25, 3, 25, 937, 8, 25, 1, 25, 1, 25, 1,
		25, 3, 25, 942, 8, 25, 1, 25, 3, 25, 945, 8, 25, 1, 26, 1, 26, 1, 26, 1,
		26, 3, 26, 951, 8, 26, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 3, 28, 958, 8,
		28, 3, 28, 960, 8, 28, 1, 28, 1, 28, 1, 28, 3, 28, 965, 8, 28, 3, 28, 967,
		8, 28, 1, 29, 1, 29, 3, 29, 971, 8, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3,
		29, 977, 8, 29, 1, 29, 3, 29, 980, 8, 29, 1, 29, 3, 29, 983, 8, 29, 1,
		30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 991, 8, 31, 1, 32, 1, 32,
		3, 32, 995, 8, 32, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 3, 34, 1002, 8, 34,
		1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 1013,
		8, 35, 1, 36, 1, 36, 1, 36, 3, 36, 1018, 8, 36, 1, 37, 1, 37, 1, 38, 1,
		38, 3, 38, 1024, 8, 38, 1, 39, 3, 39, 1027, 8, 39, 1, 39, 1, 39, 3, 39,
		1031, 8, 39, 1, 39, 4, 39, 1034, 8, 39, 11, 39, 12, 39, 1035, 1, 39, 3,
		39, 1039, 8, 39, 1, 39, 1, 39, 3, 39, 1043, 8, 39, 1, 39, 1, 39, 3, 39,
		1047, 8, 39, 3, 39, 1049, 8, 39, 1, 40, 1, 40, 1, 41, 3, 41, 1054, 8, 41,
		1, 41, 1, 41, 1, 42, 3, 42, 1059, 8, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 1072, 8, 43, 1, 43,
		3, 43, 1075, 8, 43, 1, 44, 1, 44, 3, 44, 1079, 8, 44, 1, 44, 5, 44, 1082,
		8, 44, 10, 44, 12, 44, 1085, 9, 44, 1, 44, 1, 44, 3, 44, 1089, 8, 44, 1,
		44, 5, 44, 1092, 8, 44, 10, 44, 12, 44, 1095, 9, 44, 1, 44, 1, 44, 3, 44,
		1099, 8, 44, 1, 44, 3, 44, 1102, 8, 44, 1, 44, 5, 44, 1105, 8, 44, 10,
		44, 12, 44, 1108, 9, 44, 1, 44, 1, 44, 3, 44, 1112, 8, 44, 1, 44, 5, 44,
		1115, 8, 44, 10, 44, 12, 44, 1118, 9, 44, 1, 44, 1, 44, 3, 44, 1122, 8,
		44, 1, 44, 1, 44, 1, 44, 3, 44, 1127, 8, 44, 1, 44, 3, 44, 1130, 8, 44,
		1, 44, 3, 44, 1133, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1138, 8, 44, 1,
		44, 1, 44, 1, 44, 3, 44, 1143, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1148,
		8, 44, 1, 44, 3, 44, 1151, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1156, 8,
		44, 1, 44, 3, 44, 1159, 8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1165,
		8, 44, 1, 44, 3, 44, 1168, 8, 44, 1, 44, 1, 44, 3, 44, 1172, 8, 44, 1,
		44, 3, 44, 1175, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1180, 8, 44, 1, 44,
		1, 44, 3, 44, 1184, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1189, 8, 44, 1,
		44, 1, 44, 1, 44, 3, 44, 1194, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1199,
		8, 44, 1, 44, 1, 44, 3, 44, 1203, 8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3,
		44, 1209, 8, 44, 1, 44, 3, 44, 1212, 8, 44, 1, 45, 1, 45, 1, 45, 1, 45,
		5, 45, 1218, 8, 45, 10, 45, 12, 45, 1221, 9, 45, 1, 45, 1, 45, 1, 46, 1,
		46, 3, 46, 1227, 8, 46, 1, 46, 1, 46, 3, 46, 1231, 8, 46, 1, 46, 1, 46,
		1, 46, 3, 46, 1236, 8, 46, 1, 46, 1, 46, 1, 46, 3, 46, 1241, 8, 46, 1,
		46, 1, 46, 3, 46, 1245, 8, 46, 3, 46, 1247, 8, 46, 1, 46, 3, 46, 1250,
		8, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1,
		48, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 1266, 8, 49, 1, 49, 1, 49, 1, 50,
		1, 50, 1, 50, 5, 50, 1273, 8, 50, 10, 50, 12, 50, 1276, 9, 50, 1, 51, 1,
		51, 1, 51, 5, 51, 1281, 8, 51, 10, 51, 12, 51, 1284, 9, 51, 1, 52, 1, 52,
		1, 52, 1, 52, 5, 52, 1290, 8, 52, 10, 52, 12, 52, 1293, 9, 52, 1, 52, 1,
		52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53,
		1306, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1313, 8, 53, 1,
		53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53,
		1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1332, 8, 53, 1, 54, 1,
		54, 1, 54, 3, 54, 1337, 8, 54, 1, 54, 3, 54, 1340, 8, 54, 1, 54, 1, 54,
		1, 54, 3, 54, 1345, 8, 54, 1, 54, 3, 54, 1348, 8, 54, 1, 55, 1, 55, 1,
		55, 1, 55, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1,
		56, 1, 56, 1, 56, 1, 56, 3, 56, 1377, 8, 56, 1, 57, 1, 57, 1, 57, 1, 57,
		1, 57, 1, 57, 3, 57, 1385, 8, 57, 1, 57, 1, 57, 1, 57, 3, 57, 1390, 8,
		57, 1, 57, 1, 57, 1, 57, 1, 57, 5, 57, 1396, 8, 57, 10, 57, 12, 57, 1399,
		9, 57, 1, 58, 1, 58, 1, 58, 3, 58, 1404, 8, 58, 1, 58, 1, 58, 1, 58, 1,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 1414, 8, 58, 1, 58, 1, 58, 1, 58,
		1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 1427, 8,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 1436, 8, 58,
		1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 1442, 8, 58, 1, 58, 1, 58, 1, 58, 1,
		58, 1, 58, 1, 58, 1, 58, 5, 58, 1451, 8, 58, 10, 58, 12, 58, 1454, 9, 58,
		1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1,
		59, 1, 59, 1, 59, 5, 59, 1469, 8, 59, 10, 59, 12, 59, 1472, 9, 59, 1, 59,
		1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 4, 59, 1481, 8, 59, 11, 59, 12,
		59, 1482, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 1491, 8, 59,
		1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1,
		59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 1508, 8, 59, 10, 59, 12, 59, 1511,
		9, 59, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1,
		61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 1529, 8, 61, 1, 62,
		1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 1538, 8, 62, 1, 63, 1,
		63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 1547, 8, 63, 1, 64, 1, 64,
		1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 1556, 8, 65, 1, 66, 1, 66, 1,
		67, 1, 67, 1, 68, 1, 68, 1, 69, 1, 69, 1, 70, 1, 70, 1, 71, 1, 71, 1, 72,
		1, 72, 1, 72, 0, 3, 114, 116, 118, 73, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18,
		20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54,
		56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90,
		92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
		122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 0, 56, 3, 0,
		341, 341, 431, 431, 586, 586, 2, 0, 446, 446, 656, 656, 2, 0, 508, 508,
		666, 666, 3, 0, 40, 40, 393, 393, 419, 419, 3, 0, 40, 40, 389, 389, 772,
		772, 2, 0, 620, 620, 655, 655, 2, 0, 78, 78, 88, 88, 3, 0, 424, 424, 533,
		533, 596, 596, 2, 0, 66, 66, 154, 154, 1, 0, 347, 348, 1, 0, 1128, 1129,
		2, 0, 1138, 1138, 1146, 1146, 2, 0, 78, 78, 379, 379, 3, 0, 418, 418, 456,
		456, 508, 508, 2, 0, 40, 40, 1128, 1129, 7, 0, 40, 40, 361, 361, 363, 363,
		393, 393, 419, 419, 557, 557, 1146, 1146, 2, 0, 40, 40, 1139, 1139, 2,
		0, 501, 501, 517, 517, 1, 0, 1129, 1130, 2, 0, 13, 13, 43, 43, 1, 0, 1151,
		1152, 4, 0, 366, 366, 767, 778, 1138, 1138, 1146, 1147, 3, 0, 1128, 1130,
		1139, 1139, 1141, 1141, 2, 0, 60, 60, 172, 172, 2, 0, 112, 112, 1142, 1142,
		1, 0, 190, 201, 3, 0, 177, 177, 189, 189, 595, 595, 2, 0, 205, 210, 419,
		419, 1, 0, 212, 214, 5, 0, 24, 24, 216, 218, 225, 225, 227, 230, 505, 505,
		2, 0, 24, 24, 217, 217, 2, 0, 24, 24, 216, 216, 2, 0, 149, 149, 231, 231,
		2, 0, 220, 221, 223, 223, 3, 0, 222, 222, 224, 224, 226, 226, 2, 0, 233,
		233, 339, 340, 2, 0, 215, 215, 337, 337, 1, 0, 783, 791, 2, 0, 220, 220,
		505, 505, 5, 0, 194, 194, 200, 200, 211, 212, 214, 214, 453, 453, 2, 0,
		177, 177, 595, 595, 1, 0, 1087, 1088, 2, 0, 507, 507, 1090, 1090, 2, 0,
		306, 309, 313, 313, 2, 0, 110, 110, 1117, 1117, 3, 0, 60, 60, 172, 172,
		645, 645, 2, 0, 133, 133, 145, 145, 3, 0, 110, 110, 1110, 1111, 1117, 1118,
		1, 0, 1107, 1113, 2, 0, 220, 220, 726, 766, 1, 0, 779, 782, 1, 0, 680,
		688, 1, 0, 672, 679, 3, 0, 211, 215, 228, 228, 231, 231, 40, 0, 17, 17,
		34, 34, 40, 40, 46, 46, 56, 56, 70, 70, 76, 76, 100, 100, 106, 107, 113,
		113, 117, 117, 120, 120, 126, 126, 153, 153, 163, 163, 233, 233, 277, 281,
		285, 285, 289, 290, 296, 303, 323, 420, 422, 445, 447, 542, 544, 576, 578,
		619, 621, 639, 641, 655, 657, 658, 660, 665, 667, 671, 690, 698, 703, 705,
		707, 717, 719, 725, 772, 772, 816, 816, 855, 855, 979, 979, 984, 984, 1086,
		1097, 23, 0, 37, 37, 93, 93, 144, 144, 146, 146, 211, 213, 215, 215, 245,
		276, 281, 284, 286, 288, 291, 295, 315, 315, 446, 446, 656, 656, 672, 679,
		719, 719, 783, 783, 786, 815, 817, 854, 856, 978, 980, 983, 985, 1085,
		1087, 1089, 1113, 1113, 1900, 0, 146, 1, 0, 0, 0, 2, 152, 1, 0, 0, 0, 4,
		186, 1, 0, 0, 0, 6, 201, 1, 0, 0, 0, 8, 203, 1, 0, 0, 0, 10, 236, 1, 0,
		0, 0, 12, 238, 1, 0, 0, 0, 14, 254, 1, 0, 0, 0, 16, 256, 1, 0, 0, 0, 18,
		316, 1, 0, 0, 0, 20, 387, 1, 0, 0, 0, 22, 389, 1, 0, 0, 0, 24, 417, 1,
		0, 0, 0, 26, 425, 1, 0, 0, 0, 28, 455, 1, 0, 0, 0, 30, 619, 1, 0, 0, 0,
		32, 621, 1, 0, 0, 0, 34, 623, 1, 0, 0, 0, 36, 626, 1, 0, 0, 0, 38, 700,
		1, 0, 0, 0, 40, 723, 1, 0, 0, 0, 42, 871, 1, 0, 0, 0, 44, 876, 1, 0, 0,
		0, 46, 878, 1, 0, 0, 0, 48, 888, 1, 0, 0, 0, 50, 944, 1, 0, 0, 0, 52, 946,
		1, 0, 0, 0, 54, 952, 1, 0, 0, 0, 56, 966, 1, 0, 0, 0, 58, 979, 1, 0, 0,
		0, 60, 984, 1, 0, 0, 0, 62, 990, 1, 0, 0, 0, 64, 994, 1, 0, 0, 0, 66, 996,
		1, 0, 0, 0, 68, 1001, 1, 0, 0, 0, 70, 1012, 1, 0, 0, 0, 72, 1017, 1, 0,
		0, 0, 74, 1019, 1, 0, 0, 0, 76, 1023, 1, 0, 0, 0, 78, 1048, 1, 0, 0, 0,
		80, 1050, 1, 0, 0, 0, 82, 1053, 1, 0, 0, 0, 84, 1058, 1, 0, 0, 0, 86, 1074,
		1, 0, 0, 0, 88, 1211, 1, 0, 0, 0, 90, 1213, 1, 0, 0, 0, 92, 1246, 1, 0,
		0, 0, 94, 1251, 1, 0, 0, 0, 96, 1255, 1, 0, 0, 0, 98, 1261, 1, 0, 0, 0,
		100, 1269, 1, 0, 0, 0, 102, 1277, 1, 0, 0, 0, 104, 1285, 1, 0, 0, 0, 106,
		1331, 1, 0, 0, 0, 108, 1347, 1, 0, 0, 0, 110, 1349, 1, 0, 0, 0, 112, 1376,
		1, 0, 0, 0, 114, 1389, 1, 0, 0, 0, 116, 1400, 1, 0, 0, 0, 118, 1490, 1,
		0, 0, 0, 120, 1512, 1, 0, 0, 0, 122, 1528, 1, 0, 0, 0, 124, 1537, 1, 0,
		0, 0, 126, 1546, 1, 0, 0, 0, 128, 1548, 1, 0, 0, 0, 130, 1555, 1, 0, 0,
		0, 132, 1557, 1, 0, 0, 0, 134, 1559, 1, 0, 0, 0, 136, 1561, 1, 0, 0, 0,
		138, 1563, 1, 0, 0, 0, 140, 1565, 1, 0, 0, 0, 142, 1567, 1, 0, 0, 0, 144,
		1569, 1, 0, 0, 0, 146, 148, 3, 2, 1, 0, 147, 149, 5, 1126, 0, 0, 148, 147,
		1, 0, 0, 0, 148, 149, 1, 0, 0, 0, 149, 150, 1, 0, 0, 0, 150, 151, 5, 0,
		0, 1, 151, 1, 1, 0, 0, 0, 152, 155, 5, 32, 0, 0, 153, 154, 5, 119, 0, 0,
		154, 156, 5, 137, 0, 0, 155, 153, 1, 0, 0, 0, 155, 156, 1, 0, 0, 0, 156,
		158, 1, 0, 0, 0, 157, 159, 5, 632, 0, 0, 158, 157, 1, 0, 0, 0, 158, 159,
		1, 0, 0, 0, 159, 160, 1, 0, 0, 0, 160, 162, 5, 166, 0, 0, 161, 163, 3,
		110, 55, 0, 162, 161, 1, 0, 0, 0, 162, 163, 1, 0, 0, 0, 163, 164, 1, 0,
		0, 0, 164, 165, 3, 54, 27, 0, 165, 176, 3, 12, 6, 0, 166, 173, 3, 30, 15,
		0, 167, 169, 5, 1125, 0, 0, 168, 167, 1, 0, 0, 0, 168, 169, 1, 0, 0, 0,
		169, 170, 1, 0, 0, 0, 170, 172, 3, 30, 15, 0, 171, 168, 1, 0, 0, 0, 172,
		175, 1, 0, 0, 0, 173, 171, 1, 0, 0, 0, 173, 174, 1, 0, 0, 0, 174, 177,
		1, 0, 0, 0, 175, 173, 1, 0, 0, 0, 176, 166, 1, 0, 0, 0, 176, 177, 1, 0,
		0, 0, 177, 179, 1, 0, 0, 0, 178, 180, 3, 36, 18, 0, 179, 178, 1, 0, 0,
		0, 179, 180, 1, 0, 0, 0, 180, 3, 1, 0, 0, 0, 181, 182, 5, 24, 0, 0, 182,
		187, 5, 149, 0, 0, 183, 187, 5, 821, 0, 0, 184, 185, 5, 216, 0, 0, 185,
		187, 5, 149, 0, 0, 186, 181, 1, 0, 0, 0, 186, 183, 1, 0, 0, 0, 186, 184,
		1, 0, 0, 0, 187, 5, 1, 0, 0, 0, 188, 202, 3, 138, 69, 0, 189, 202, 5, 215,
		0, 0, 190, 202, 5, 234, 0, 0, 191, 202, 5, 235, 0, 0, 192, 202, 5, 236,
		0, 0, 193, 202, 5, 237, 0, 0, 194, 202, 5, 238, 0, 0, 195, 202, 5, 239,
		0, 0, 196, 202, 5, 240, 0, 0, 197, 202, 5, 241, 0, 0, 198, 202, 5, 242,
		0, 0, 199, 202, 5, 243, 0, 0, 200, 202, 5, 244, 0, 0, 201, 188, 1, 0, 0,
		0, 201, 189, 1, 0, 0, 0, 201, 190, 1, 0, 0, 0, 201, 191, 1, 0, 0, 0, 201,
		192, 1, 0, 0, 0, 201, 193, 1, 0, 0, 0, 201, 194, 1, 0, 0, 0, 201, 195,
		1, 0, 0, 0, 201, 196, 1, 0, 0, 0, 201, 197, 1, 0, 0, 0, 201, 198, 1, 0,
		0, 0, 201, 199, 1, 0, 0, 0, 201, 200, 1, 0, 0, 0, 202, 7, 1, 0, 0, 0, 203,
		204, 5, 181, 0, 0, 204, 205, 7, 0, 0, 0, 205, 9, 1, 0, 0, 0, 206, 208,
		5, 454, 0, 0, 207, 209, 5, 1114, 0, 0, 208, 207, 1, 0, 0, 0, 208, 209,
		1, 0, 0, 0, 209, 210, 1, 0, 0, 0, 210, 237, 3, 76, 38, 0, 211, 237, 3,
		8, 4, 0, 212, 213, 5, 186, 0, 0, 213, 214, 5, 532, 0, 0, 214, 237, 3, 68,
		34, 0, 215, 216, 5, 359, 0, 0, 216, 237, 5, 1138, 0, 0, 217, 237, 7, 1,
		0, 0, 218, 220, 5, 855, 0, 0, 219, 221, 5, 1114, 0, 0, 220, 219, 1, 0,
		0, 0, 220, 221, 1, 0, 0, 0, 221, 222, 1, 0, 0, 0, 222, 237, 5, 1138, 0,
		0, 223, 225, 5, 979, 0, 0, 224, 226, 5, 1114, 0, 0, 225, 224, 1, 0, 0,
		0, 225, 226, 1, 0, 0, 0, 226, 227, 1, 0, 0, 0, 227, 237, 5, 1138, 0, 0,
		228, 229, 5, 353, 0, 0, 229, 230, 5, 1114, 0, 0, 230, 237, 7, 2, 0, 0,
		231, 235, 5, 76, 0, 0, 232, 233, 5, 110, 0, 0, 233, 235, 5, 76, 0, 0, 234,
		231, 1, 0, 0, 0, 234, 232, 1, 0, 0, 0, 235, 237, 1, 0, 0, 0, 236, 206,
		1, 0, 0, 0, 236, 211, 1, 0, 0, 0, 236, 212, 1, 0, 0, 0, 236, 215, 1, 0,
		0, 0, 236, 217, 1, 0, 0, 0, 236, 218, 1, 0, 0, 0, 236, 223, 1, 0, 0, 0,
		236, 228, 1, 0, 0, 0, 236, 234, 1, 0, 0, 0, 237, 11, 1, 0, 0, 0, 238, 239,
		5, 1123, 0, 0, 239, 244, 3, 14, 7, 0, 240, 241, 5, 1125, 0, 0, 241, 243,
		3, 14, 7, 0, 242, 240, 1, 0, 0, 0, 243, 246, 1, 0, 0, 0, 244, 242, 1, 0,
		0, 0, 244, 245, 1, 0, 0, 0, 245, 247, 1, 0, 0, 0, 246, 244, 1, 0, 0, 0,
		247, 248, 5, 1124, 0, 0, 248, 13, 1, 0, 0, 0, 249, 250, 3, 68, 34, 0, 250,
		251, 3, 16, 8, 0, 251, 255, 1, 0, 0, 0, 252, 255, 3, 20, 10, 0, 253, 255,
		3, 28, 14, 0, 254, 249, 1, 0, 0, 0, 254, 252, 1, 0, 0, 0, 254, 253, 1,
		0, 0, 0, 255, 15, 1, 0, 0, 0, 256, 260, 3, 88, 44, 0, 257, 259, 3, 18,
		9, 0, 258, 257, 1, 0, 0, 0, 259, 262, 1, 0, 0, 0, 260, 258, 1, 0, 0, 0,
		260, 261, 1, 0, 0, 0, 261, 17, 1, 0, 0, 0, 262, 260, 1, 0, 0, 0, 263, 317,
		3, 84, 42, 0, 264, 265, 5, 40, 0, 0, 265, 317, 3, 106, 53, 0, 266, 317,
		5, 656, 0, 0, 267, 317, 5, 446, 0, 0, 268, 273, 5, 333, 0, 0, 269, 270,
		5, 114, 0, 0, 270, 271, 5, 178, 0, 0, 271, 273, 3, 108, 54, 0, 272, 268,
		1, 0, 0, 0, 272, 269, 1, 0, 0, 0, 273, 317, 1, 0, 0, 0, 274, 276, 5, 126,
		0, 0, 275, 274, 1, 0, 0, 0, 275, 276, 1, 0, 0, 0, 276, 277, 1, 0, 0, 0,
		277, 317, 5, 88, 0, 0, 278, 280, 5, 175, 0, 0, 279, 281, 5, 88, 0, 0, 280,
		279, 1, 0, 0, 0, 280, 281, 1, 0, 0, 0, 281, 317, 1, 0, 0, 0, 282, 283,
		5, 359, 0, 0, 283, 317, 5, 1138, 0, 0, 284, 285, 5, 357, 0, 0, 285, 317,
		7, 3, 0, 0, 286, 287, 5, 619, 0, 0, 287, 317, 7, 4, 0, 0, 288, 317, 3,
		22, 11, 0, 289, 290, 5, 26, 0, 0, 290, 317, 3, 64, 32, 0, 291, 292, 5,
		67, 0, 0, 292, 294, 5, 8, 0, 0, 293, 291, 1, 0, 0, 0, 293, 294, 1, 0, 0,
		0, 294, 295, 1, 0, 0, 0, 295, 296, 5, 12, 0, 0, 296, 297, 5, 1123, 0, 0,
		297, 298, 3, 114, 57, 0, 298, 300, 5, 1124, 0, 0, 299, 301, 7, 5, 0, 0,
		300, 299, 1, 0, 0, 0, 300, 301, 1, 0, 0, 0, 301, 317, 1, 0, 0, 0, 302,
		303, 5, 233, 0, 0, 303, 304, 5, 40, 0, 0, 304, 317, 5, 652, 0, 0, 305,
		307, 5, 29, 0, 0, 306, 308, 3, 68, 34, 0, 307, 306, 1, 0, 0, 0, 307, 308,
		1, 0, 0, 0, 308, 310, 1, 0, 0, 0, 309, 305, 1, 0, 0, 0, 309, 310, 1, 0,
		0, 0, 310, 311, 1, 0, 0, 0, 311, 312, 5, 25, 0, 0, 312, 313, 5, 1123, 0,
		0, 313, 314, 3, 114, 57, 0, 314, 315, 5, 1124, 0, 0, 315, 317, 1, 0, 0,
		0, 316, 263, 1, 0, 0, 0, 316, 264, 1, 0, 0, 0, 316, 266, 1, 0, 0, 0, 316,
		267, 1, 0, 0, 0, 316, 272, 1, 0, 0, 0, 316, 275, 1, 0, 0, 0, 316, 278,
		1, 0, 0, 0, 316, 282, 1, 0, 0, 0, 316, 284, 1, 0, 0, 0, 316, 286, 1, 0,
		0, 0, 316, 288, 1, 0, 0, 0, 316, 289, 1, 0, 0, 0, 316, 293, 1, 0, 0, 0,
		316, 302, 1, 0, 0, 0, 316, 309, 1, 0, 0, 0, 317, 19, 1, 0, 0, 0, 318, 320,
		5, 29, 0, 0, 319, 321, 3, 68, 34, 0, 320, 319, 1, 0, 0, 0, 320, 321, 1,
		0, 0, 0, 321, 323, 1, 0, 0, 0, 322, 318, 1, 0, 0, 0, 322, 323, 1, 0, 0,
		0, 323, 324, 1, 0, 0, 0, 324, 325, 5, 126, 0, 0, 325, 327, 5, 88, 0, 0,
		326, 328, 3, 68, 34, 0, 327, 326, 1, 0, 0, 0, 327, 328, 1, 0, 0, 0, 328,
		330, 1, 0, 0, 0, 329, 331, 3, 8, 4, 0, 330, 329, 1, 0, 0, 0, 330, 331,
		1, 0, 0, 0, 331, 332, 1, 0, 0, 0, 332, 336, 3, 104, 52, 0, 333, 335, 3,
		10, 5, 0, 334, 333, 1, 0, 0, 0, 335, 338, 1, 0, 0, 0, 336, 334, 1, 0, 0,
		0, 336, 337, 1, 0, 0, 0, 337, 388, 1, 0, 0, 0, 338, 336, 1, 0, 0, 0, 339,
		341, 5, 29, 0, 0, 340, 342, 3, 68, 34, 0, 341, 340, 1, 0, 0, 0, 341, 342,
		1, 0, 0, 0, 342, 344, 1, 0, 0, 0, 343, 339, 1, 0, 0, 0, 343, 344, 1, 0,
		0, 0, 344, 345, 1, 0, 0, 0, 345, 347, 5, 175, 0, 0, 346, 348, 7, 6, 0,
		0, 347, 346, 1, 0, 0, 0, 347, 348, 1, 0, 0, 0, 348, 350, 1, 0, 0, 0, 349,
		351, 3, 68, 34, 0, 350, 349, 1, 0, 0, 0, 350, 351, 1, 0, 0, 0, 351, 353,
		1, 0, 0, 0, 352, 354, 3, 8, 4, 0, 353, 352, 1, 0, 0, 0, 353, 354, 1, 0,
		0, 0, 354, 355, 1, 0, 0, 0, 355, 359, 3, 104, 52, 0, 356, 358, 3, 10, 5,
		0, 357, 356, 1, 0, 0, 0, 358, 361, 1, 0, 0, 0, 359, 357, 1, 0, 0, 0, 359,
		360, 1, 0, 0, 0, 360, 388, 1, 0, 0, 0, 361, 359, 1, 0, 0, 0, 362, 364,
		5, 29, 0, 0, 363, 365, 3, 68, 34, 0, 364, 363, 1, 0, 0, 0, 364, 365, 1,
		0, 0, 0, 365, 367, 1, 0, 0, 0, 366, 362, 1, 0, 0, 0, 366, 367, 1, 0, 0,
		0, 367, 368, 1, 0, 0, 0, 368, 369, 5, 64, 0, 0, 369, 371, 5, 88, 0, 0,
		370, 372, 3, 68, 34, 0, 371, 370, 1, 0, 0, 0, 371, 372, 1, 0, 0, 0, 372,
		373, 1, 0, 0, 0, 373, 374, 3, 104, 52, 0, 374, 375, 3, 22, 11, 0, 375,
		388, 1, 0, 0, 0, 376, 378, 5, 29, 0, 0, 377, 379, 3, 68, 34, 0, 378, 377,
		1, 0, 0, 0, 378, 379, 1, 0, 0, 0, 379, 381, 1, 0, 0, 0, 380, 376, 1, 0,
		0, 0, 380, 381, 1, 0, 0, 0, 381, 382, 1, 0, 0, 0, 382, 383, 5, 25, 0, 0,
		383, 384, 5, 1123, 0, 0, 384, 385, 3, 114, 57, 0, 385, 386, 5, 1124, 0,
		0, 386, 388, 1, 0, 0, 0, 387, 322, 1, 0, 0, 0, 387, 343, 1, 0, 0, 0, 387,
		366, 1, 0, 0, 0, 387, 380, 1, 0, 0, 0, 388, 21, 1, 0, 0, 0, 389, 390, 5,
		132, 0, 0, 390, 392, 3, 54, 27, 0, 391, 393, 3, 104, 52, 0, 392, 391, 1,
		0, 0, 0, 392, 393, 1, 0, 0, 0, 393, 396, 1, 0, 0, 0, 394, 395, 5, 105,
		0, 0, 395, 397, 7, 7, 0, 0, 396, 394, 1, 0, 0, 0, 396, 397, 1, 0, 0, 0,
		397, 399, 1, 0, 0, 0, 398, 400, 3, 24, 12, 0, 399, 398, 1, 0, 0, 0, 399,
		400, 1, 0, 0, 0, 400, 23, 1, 0, 0, 0, 401, 402, 5, 114, 0, 0, 402, 403,
		5, 42, 0, 0, 403, 407, 3, 26, 13, 0, 404, 405, 5, 114, 0, 0, 405, 406,
		5, 178, 0, 0, 406, 408, 3, 26, 13, 0, 407, 404, 1, 0, 0, 0, 407, 408, 1,
		0, 0, 0, 408, 418, 1, 0, 0, 0, 409, 410, 5, 114, 0, 0, 410, 411, 5, 178,
		0, 0, 411, 415, 3, 26, 13, 0, 412, 413, 5, 114, 0, 0, 413, 414, 5, 42,
		0, 0, 414, 416, 3, 26, 13, 0, 415, 412, 1, 0, 0, 0, 415, 416, 1, 0, 0,
		0, 416, 418, 1, 0, 0, 0, 417, 401, 1, 0, 0, 0, 417, 409, 1, 0, 0, 0, 418,
		25, 1, 0, 0, 0, 419, 426, 5, 140, 0, 0, 420, 426, 5, 20, 0, 0, 421, 422,
		5, 149, 0, 0, 422, 426, 5, 112, 0, 0, 423, 424, 5, 508, 0, 0, 424, 426,
		5, 324, 0, 0, 425, 419, 1, 0, 0, 0, 425, 420, 1, 0, 0, 0, 425, 421, 1,
		0, 0, 0, 425, 423, 1, 0, 0, 0, 426, 27, 1, 0, 0, 0, 427, 429, 7, 6, 0,
		0, 428, 430, 3, 68, 34, 0, 429, 428, 1, 0, 0, 0, 429, 430, 1, 0, 0, 0,
		430, 432, 1, 0, 0, 0, 431, 433, 3, 8, 4, 0, 432, 431, 1, 0, 0, 0, 432,
		433, 1, 0, 0, 0, 433, 434, 1, 0, 0, 0, 434, 438, 3, 104, 52, 0, 435, 437,
		3, 10, 5, 0, 436, 435, 1, 0, 0, 0, 437, 440, 1, 0, 0, 0, 438, 436, 1, 0,
		0, 0, 438, 439, 1, 0, 0, 0, 439, 456, 1, 0, 0, 0, 440, 438, 1, 0, 0, 0,
		441, 443, 7, 8, 0, 0, 442, 444, 7, 6, 0, 0, 443, 442, 1, 0, 0, 0, 443,
		444, 1, 0, 0, 0, 444, 446, 1, 0, 0, 0, 445, 447, 3, 68, 34, 0, 446, 445,
		1, 0, 0, 0, 446, 447, 1, 0, 0, 0, 447, 448, 1, 0, 0, 0, 448, 452, 3, 104,
		52, 0, 449, 451, 3, 10, 5, 0, 450, 449, 1, 0, 0, 0, 451, 454, 1, 0, 0,
		0, 452, 450, 1, 0, 0, 0, 452, 453, 1, 0, 0, 0, 453, 456, 1, 0, 0, 0, 454,
		452, 1, 0, 0, 0, 455, 427, 1, 0, 0, 0, 455, 441, 1, 0, 0, 0, 456, 29, 1,
		0, 0, 0, 457, 459, 5, 398, 0, 0, 458, 460, 5, 1114, 0, 0, 459, 458, 1,
		0, 0, 0, 459, 460, 1, 0, 0, 0, 460, 462, 1, 0, 0, 0, 461, 463, 3, 66, 33,
		0, 462, 461, 1, 0, 0, 0, 462, 463, 1, 0, 0, 0, 463, 620, 1, 0, 0, 0, 464,
		466, 5, 855, 0, 0, 465, 467, 5, 1114, 0, 0, 466, 465, 1, 0, 0, 0, 466,
		467, 1, 0, 0, 0, 467, 468, 1, 0, 0, 0, 468, 620, 5, 1138, 0, 0, 469, 471,
		5, 332, 0, 0, 470, 472, 5, 1114, 0, 0, 471, 470, 1, 0, 0, 0, 471, 472,
		1, 0, 0, 0, 472, 473, 1, 0, 0, 0, 473, 620, 3, 74, 37, 0, 474, 476, 5,
		333, 0, 0, 475, 477, 5, 1114, 0, 0, 476, 475, 1, 0, 0, 0, 476, 477, 1,
		0, 0, 0, 477, 478, 1, 0, 0, 0, 478, 620, 3, 74, 37, 0, 479, 481, 5, 334,
		0, 0, 480, 482, 5, 1114, 0, 0, 481, 480, 1, 0, 0, 0, 481, 482, 1, 0, 0,
		0, 482, 483, 1, 0, 0, 0, 483, 620, 3, 74, 37, 0, 484, 486, 5, 40, 0, 0,
		485, 484, 1, 0, 0, 0, 485, 486, 1, 0, 0, 0, 486, 487, 1, 0, 0, 0, 487,
		489, 3, 4, 2, 0, 488, 490, 5, 1114, 0, 0, 489, 488, 1, 0, 0, 0, 489, 490,
		1, 0, 0, 0, 490, 493, 1, 0, 0, 0, 491, 494, 3, 62, 31, 0, 492, 494, 5,
		40, 0, 0, 493, 491, 1, 0, 0, 0, 493, 492, 1, 0, 0, 0, 494, 620, 1, 0, 0,
		0, 495, 497, 7, 9, 0, 0, 496, 498, 5, 1114, 0, 0, 497, 496, 1, 0, 0, 0,
		497, 498, 1, 0, 0, 0, 498, 499, 1, 0, 0, 0, 499, 620, 7, 10, 0, 0, 500,
		502, 5, 40, 0, 0, 501, 500, 1, 0, 0, 0, 501, 502, 1, 0, 0, 0, 502, 503,
		1, 0, 0, 0, 503, 505, 5, 26, 0, 0, 504, 506, 5, 1114, 0, 0, 505, 504, 1,
		0, 0, 0, 505, 506, 1, 0, 0, 0, 506, 507, 1, 0, 0, 0, 507, 620, 3, 64, 32,
		0, 508, 510, 5, 359, 0, 0, 509, 511, 5, 1114, 0, 0, 510, 509, 1, 0, 0,
		0, 510, 511, 1, 0, 0, 0, 511, 512, 1, 0, 0, 0, 512, 620, 5, 1138, 0, 0,
		513, 515, 5, 364, 0, 0, 514, 516, 5, 1114, 0, 0, 515, 514, 1, 0, 0, 0,
		515, 516, 1, 0, 0, 0, 516, 517, 1, 0, 0, 0, 517, 620, 7, 11, 0, 0, 518,
		520, 5, 367, 0, 0, 519, 521, 5, 1114, 0, 0, 520, 519, 1, 0, 0, 0, 520,
		521, 1, 0, 0, 0, 521, 522, 1, 0, 0, 0, 522, 620, 5, 1138, 0, 0, 523, 524,
		7, 12, 0, 0, 524, 526, 5, 386, 0, 0, 525, 527, 5, 1114, 0, 0, 526, 525,
		1, 0, 0, 0, 526, 527, 1, 0, 0, 0, 527, 528, 1, 0, 0, 0, 528, 620, 5, 1138,
		0, 0, 529, 531, 5, 384, 0, 0, 530, 532, 5, 1114, 0, 0, 531, 530, 1, 0,
		0, 0, 531, 532, 1, 0, 0, 0, 532, 533, 1, 0, 0, 0, 533, 620, 7, 10, 0, 0,
		534, 536, 5, 395, 0, 0, 535, 537, 5, 1114, 0, 0, 536, 535, 1, 0, 0, 0,
		536, 537, 1, 0, 0, 0, 537, 538, 1, 0, 0, 0, 538, 620, 5, 1138, 0, 0, 539,
		540, 5, 78, 0, 0, 540, 542, 5, 386, 0, 0, 541, 543, 5, 1114, 0, 0, 542,
		541, 1, 0, 0, 0, 542, 543, 1, 0, 0, 0, 543, 544, 1, 0, 0, 0, 544, 620,
		5, 1138, 0, 0, 545, 547, 5, 442, 0, 0, 546, 548, 5, 1114, 0, 0, 547, 546,
		1, 0, 0, 0, 547, 548, 1, 0, 0, 0, 548, 549, 1, 0, 0, 0, 549, 620, 7, 13,
		0, 0, 550, 552, 5, 454, 0, 0, 551, 553, 5, 1114, 0, 0, 552, 551, 1, 0,
		0, 0, 552, 553, 1, 0, 0, 0, 553, 554, 1, 0, 0, 0, 554, 620, 3, 76, 38,
		0, 555, 557, 5, 487, 0, 0, 556, 558, 5, 1114, 0, 0, 557, 556, 1, 0, 0,
		0, 557, 558, 1, 0, 0, 0, 558, 559, 1, 0, 0, 0, 559, 620, 3, 74, 37, 0,
		560, 562, 5, 497, 0, 0, 561, 563, 5, 1114, 0, 0, 562, 561, 1, 0, 0, 0,
		562, 563, 1, 0, 0, 0, 563, 564, 1, 0, 0, 0, 564, 620, 3, 74, 37, 0, 565,
		567, 5, 530, 0, 0, 566, 568, 5, 1114, 0, 0, 567, 566, 1, 0, 0, 0, 567,
		568, 1, 0, 0, 0, 568, 569, 1, 0, 0, 0, 569, 620, 7, 14, 0, 0, 570, 572,
		5, 536, 0, 0, 571, 573, 5, 1114, 0, 0, 572, 571, 1, 0, 0, 0, 572, 573,
		1, 0, 0, 0, 573, 574, 1, 0, 0, 0, 574, 620, 5, 1138, 0, 0, 575, 577, 5,
		585, 0, 0, 576, 578, 5, 1114, 0, 0, 577, 576, 1, 0, 0, 0, 577, 578, 1,
		0, 0, 0, 578, 579, 1, 0, 0, 0, 579, 620, 7, 15, 0, 0, 580, 581, 5, 612,
		0, 0, 581, 620, 5, 636, 0, 0, 582, 584, 5, 979, 0, 0, 583, 585, 5, 1114,
		0, 0, 584, 583, 1, 0, 0, 0, 584, 585, 1, 0, 0, 0, 585, 586, 1, 0, 0, 0,
		586, 620, 5, 1138, 0, 0, 587, 589, 5, 614, 0, 0, 588, 590, 5, 1114, 0,
		0, 589, 588, 1, 0, 0, 0, 589, 590, 1, 0, 0, 0, 590, 591, 1, 0, 0, 0, 591,
		620, 7, 14, 0, 0, 592, 594, 5, 615, 0, 0, 593, 595, 5, 1114, 0, 0, 594,
		593, 1, 0, 0, 0, 594, 595, 1, 0, 0, 0, 595, 596, 1, 0, 0, 0, 596, 620,
		7, 14, 0, 0, 597, 599, 5, 616, 0, 0, 598, 600, 5, 1114, 0, 0, 599, 598,
		1, 0, 0, 0, 599, 600, 1, 0, 0, 0, 600, 601, 1, 0, 0, 0, 601, 620, 7, 16,
		0, 0, 602, 603, 5, 630, 0, 0, 603, 605, 3, 68, 34, 0, 604, 606, 3, 34,
		17, 0, 605, 604, 1, 0, 0, 0, 605, 606, 1, 0, 0, 0, 606, 620, 1, 0, 0, 0,
		607, 608, 5, 631, 0, 0, 608, 609, 5, 1114, 0, 0, 609, 620, 3, 32, 16, 0,
		610, 620, 3, 34, 17, 0, 611, 613, 5, 174, 0, 0, 612, 614, 5, 1114, 0, 0,
		613, 612, 1, 0, 0, 0, 613, 614, 1, 0, 0, 0, 614, 615, 1, 0, 0, 0, 615,
		616, 5, 1123, 0, 0, 616, 617, 3, 102, 51, 0, 617, 618, 5, 1124, 0, 0, 618,
		620, 1, 0, 0, 0, 619, 457, 1, 0, 0, 0, 619, 464, 1, 0, 0, 0, 619, 469,
		1, 0, 0, 0, 619, 474, 1, 0, 0, 0, 619, 479, 1, 0, 0, 0, 619, 485, 1, 0,
		0, 0, 619, 495, 1, 0, 0, 0, 619, 501, 1, 0, 0, 0, 619, 508, 1, 0, 0, 0,
		619, 513, 1, 0, 0, 0, 619, 518, 1, 0, 0, 0, 619, 523, 1, 0, 0, 0, 619,
		529, 1, 0, 0, 0, 619, 534, 1, 0, 0, 0, 619, 539, 1, 0, 0, 0, 619, 545,
		1, 0, 0, 0, 619, 550, 1, 0, 0, 0, 619, 555, 1, 0, 0, 0, 619, 560, 1, 0,
		0, 0, 619, 565, 1, 0, 0, 0, 619, 570, 1, 0, 0, 0, 619, 575, 1, 0, 0, 0,
		619, 580, 1, 0, 0, 0, 619, 582, 1, 0, 0, 0, 619, 587, 1, 0, 0, 0, 619,
		592, 1, 0, 0, 0, 619, 597, 1, 0, 0, 0, 619, 602, 1, 0, 0, 0, 619, 607,
		1, 0, 0, 0, 619, 610, 1, 0, 0, 0, 619, 611, 1, 0, 0, 0, 620, 31, 1, 0,
		0, 0, 621, 622, 7, 17, 0, 0, 622, 33, 1, 0, 0, 0, 623, 624, 5, 619, 0,
		0, 624, 625, 7, 4, 0, 0, 625, 35, 1, 0, 0, 0, 626, 627, 5, 125, 0, 0, 627,
		628, 5, 18, 0, 0, 628, 631, 3, 38, 19, 0, 629, 630, 5, 535, 0, 0, 630,
		632, 3, 74, 37, 0, 631, 629, 1, 0, 0, 0, 631, 632, 1, 0, 0, 0, 632, 640,
		1, 0, 0, 0, 633, 634, 5, 624, 0, 0, 634, 635, 5, 18, 0, 0, 635, 638, 3,
		40, 20, 0, 636, 637, 5, 625, 0, 0, 637, 639, 3, 74, 37, 0, 638, 636, 1,
		0, 0, 0, 638, 639, 1, 0, 0, 0, 639, 641, 1, 0, 0, 0, 640, 633, 1, 0, 0,
		0, 640, 641, 1, 0, 0, 0, 641, 653, 1, 0, 0, 0, 642, 643, 5, 1123, 0, 0,
		643, 648, 3, 42, 21, 0, 644, 645, 5, 1125, 0, 0, 645, 647, 3, 42, 21, 0,
		646, 644, 1, 0, 0, 0, 647, 650, 1, 0, 0, 0, 648, 646, 1, 0, 0, 0, 648,
		649, 1, 0, 0, 0, 649, 651, 1, 0, 0, 0, 650, 648, 1, 0, 0, 0, 651, 652,
		5, 1124, 0, 0, 652, 654, 1, 0, 0, 0, 653, 642, 1, 0, 0, 0, 653, 654, 1,
		0, 0, 0, 654, 37, 1, 0, 0, 0, 655, 657, 5, 96, 0, 0, 656, 655, 1, 0, 0,
		0, 656, 657, 1, 0, 0, 0, 657, 658, 1, 0, 0, 0, 658, 659, 5, 431, 0, 0,
		659, 660, 5, 1123, 0, 0, 660, 661, 3, 114, 57, 0, 661, 662, 5, 1124, 0,
		0, 662, 701, 1, 0, 0, 0, 663, 665, 5, 96, 0, 0, 664, 663, 1, 0, 0, 0, 664,
		665, 1, 0, 0, 0, 665, 666, 1, 0, 0, 0, 666, 670, 5, 88, 0, 0, 667, 668,
		5, 327, 0, 0, 668, 669, 5, 1114, 0, 0, 669, 671, 7, 18, 0, 0, 670, 667,
		1, 0, 0, 0, 670, 671, 1, 0, 0, 0, 671, 672, 1, 0, 0, 0, 672, 673, 5, 1123,
		0, 0, 673, 674, 3, 100, 50, 0, 674, 675, 5, 1124, 0, 0, 675, 701, 1, 0,
		0, 0, 676, 686, 5, 129, 0, 0, 677, 678, 5, 1123, 0, 0, 678, 679, 3, 114,
		57, 0, 679, 680, 5, 1124, 0, 0, 680, 687, 1, 0, 0, 0, 681, 682, 5, 356,
		0, 0, 682, 683, 5, 1123, 0, 0, 683, 684, 3, 100, 50, 0, 684, 685, 5, 1124,
		0, 0, 685, 687, 1, 0, 0, 0, 686, 677, 1, 0, 0, 0, 686, 681, 1, 0, 0, 0,
		687, 701, 1, 0, 0, 0, 688, 698, 5, 460, 0, 0, 689, 690, 5, 1123, 0, 0,
		690, 691, 3, 114, 57, 0, 691, 692, 5, 1124, 0, 0, 692, 699, 1, 0, 0, 0,
		693, 694, 5, 356, 0, 0, 694, 695, 5, 1123, 0, 0, 695, 696, 3, 100, 50,
		0, 696, 697, 5, 1124, 0, 0, 697, 699, 1, 0, 0, 0, 698, 689, 1, 0, 0, 0,
		698, 693, 1, 0, 0, 0, 699, 701, 1, 0, 0, 0, 700, 656, 1, 0, 0, 0, 700,
		664, 1, 0, 0, 0, 700, 676, 1, 0, 0, 0, 700, 688, 1, 0, 0, 0, 701, 39, 1,
		0, 0, 0, 702, 704, 5, 96, 0, 0, 703, 702, 1, 0, 0, 0, 703, 704, 1, 0, 0,
		0, 704, 705, 1, 0, 0, 0, 705, 706, 5, 431, 0, 0, 706, 707, 5, 1123, 0,
		0, 707, 708, 3, 114, 57, 0, 708, 709, 5, 1124, 0, 0, 709, 724, 1, 0, 0,
		0, 710, 712, 5, 96, 0, 0, 711, 710, 1, 0, 0, 0, 711, 712, 1, 0, 0, 0, 712,
		713, 1, 0, 0, 0, 713, 717, 5, 88, 0, 0, 714, 715, 5, 327, 0, 0, 715, 716,
		5, 1114, 0, 0, 716, 718, 7, 18, 0, 0, 717, 714, 1, 0, 0, 0, 717, 718, 1,
		0, 0, 0, 718, 719, 1, 0, 0, 0, 719, 720, 5, 1123, 0, 0, 720, 721, 3, 100,
		50, 0, 721, 722, 5, 1124, 0, 0, 722, 724, 1, 0, 0, 0, 723, 703, 1, 0, 0,
		0, 723, 711, 1, 0, 0, 0, 724, 41, 1, 0, 0, 0, 725, 726, 5, 125, 0, 0, 726,
		727, 3, 68, 34, 0, 727, 728, 5, 182, 0, 0, 728, 729, 5, 458, 0, 0, 729,
		730, 5, 634, 0, 0, 730, 731, 5, 1123, 0, 0, 731, 736, 3, 44, 22, 0, 732,
		733, 5, 1125, 0, 0, 733, 735, 3, 44, 22, 0, 734, 732, 1, 0, 0, 0, 735,
		738, 1, 0, 0, 0, 736, 734, 1, 0, 0, 0, 736, 737, 1, 0, 0, 0, 737, 739,
		1, 0, 0, 0, 738, 736, 1, 0, 0, 0, 739, 743, 5, 1124, 0, 0, 740, 742, 3,
		50, 25, 0, 741, 740, 1, 0, 0, 0, 742, 745, 1, 0, 0, 0, 743, 741, 1, 0,
		0, 0, 743, 744, 1, 0, 0, 0, 744, 757, 1, 0, 0, 0, 745, 743, 1, 0, 0, 0,
		746, 747, 5, 1123, 0, 0, 747, 752, 3, 48, 24, 0, 748, 749, 5, 1125, 0,
		0, 749, 751, 3, 48, 24, 0, 750, 748, 1, 0, 0, 0, 751, 754, 1, 0, 0, 0,
		752, 750, 1, 0, 0, 0, 752, 753, 1, 0, 0, 0, 753, 755, 1, 0, 0, 0, 754,
		752, 1, 0, 0, 0, 755, 756, 5, 1124, 0, 0, 756, 758, 1, 0, 0, 0, 757, 746,
		1, 0, 0, 0, 757, 758, 1, 0, 0, 0, 758, 872, 1, 0, 0, 0, 759, 760, 5, 125,
		0, 0, 760, 761, 3, 68, 34, 0, 761, 762, 5, 182, 0, 0, 762, 763, 5, 458,
		0, 0, 763, 764, 5, 634, 0, 0, 764, 768, 3, 44, 22, 0, 765, 767, 3, 50,
		25, 0, 766, 765, 1, 0, 0, 0, 767, 770, 1, 0, 0, 0, 768, 766, 1, 0, 0, 0,
		768, 769, 1, 0, 0, 0, 769, 782, 1, 0, 0, 0, 770, 768, 1, 0, 0, 0, 771,
		772, 5, 1123, 0, 0, 772, 777, 3, 48, 24, 0, 773, 774, 5, 1125, 0, 0, 774,
		776, 3, 48, 24, 0, 775, 773, 1, 0, 0, 0, 776, 779, 1, 0, 0, 0, 777, 775,
		1, 0, 0, 0, 777, 778, 1, 0, 0, 0, 778, 780, 1, 0, 0, 0, 779, 777, 1, 0,
		0, 0, 780, 781, 5, 1124, 0, 0, 781, 783, 1, 0, 0, 0, 782, 771, 1, 0, 0,
		0, 782, 783, 1, 0, 0, 0, 783, 872, 1, 0, 0, 0, 784, 785, 5, 125, 0, 0,
		785, 786, 3, 68, 34, 0, 786, 787, 5, 182, 0, 0, 787, 788, 5, 77, 0, 0,
		788, 789, 5, 1123, 0, 0, 789, 794, 3, 44, 22, 0, 790, 791, 5, 1125, 0,
		0, 791, 793, 3, 44, 22, 0, 792, 790, 1, 0, 0, 0, 793, 796, 1, 0, 0, 0,
		794, 792, 1, 0, 0, 0, 794, 795, 1, 0, 0, 0, 795, 797, 1, 0, 0, 0, 796,
		794, 1, 0, 0, 0, 797, 801, 5, 1124, 0, 0, 798, 800, 3, 50, 25, 0, 799,
		798, 1, 0, 0, 0, 800, 803, 1, 0, 0, 0, 801, 799, 1, 0, 0, 0, 801, 802,
		1, 0, 0, 0, 802, 815, 1, 0, 0, 0, 803, 801, 1, 0, 0, 0, 804, 805, 5, 1123,
		0, 0, 805, 810, 3, 48, 24, 0, 806, 807, 5, 1125, 0, 0, 807, 809, 3, 48,
		24, 0, 808, 806, 1, 0, 0, 0, 809, 812, 1, 0, 0, 0, 810, 808, 1, 0, 0, 0,
		810, 811, 1, 0, 0, 0, 811, 813, 1, 0, 0, 0, 812, 810, 1, 0, 0, 0, 813,
		814, 5, 1124, 0, 0, 814, 816, 1, 0, 0, 0, 815, 804, 1, 0, 0, 0, 815, 816,
		1, 0, 0, 0, 816, 872, 1, 0, 0, 0, 817, 818, 5, 125, 0, 0, 818, 819, 3,
		68, 34, 0, 819, 820, 5, 182, 0, 0, 820, 821, 5, 77, 0, 0, 821, 822, 5,
		1123, 0, 0, 822, 827, 3, 46, 23, 0, 823, 824, 5, 1125, 0, 0, 824, 826,
		3, 46, 23, 0, 825, 823, 1, 0, 0, 0, 826, 829, 1, 0, 0, 0, 827, 825, 1,
		0, 0, 0, 827, 828, 1, 0, 0, 0, 828, 830, 1, 0, 0, 0, 829, 827, 1, 0, 0,
		0, 830, 834, 5, 1124, 0, 0, 831, 833, 3, 50, 25, 0, 832, 831, 1, 0, 0,
		0, 833, 836, 1, 0, 0, 0, 834, 832, 1, 0, 0, 0, 834, 835, 1, 0, 0, 0, 835,
		848, 1, 0, 0, 0, 836, 834, 1, 0, 0, 0, 837, 838, 5, 1123, 0, 0, 838, 843,
		3, 48, 24, 0, 839, 840, 5, 1125, 0, 0, 840, 842, 3, 48, 24, 0, 841, 839,
		1, 0, 0, 0, 842, 845, 1, 0, 0, 0, 843, 841, 1, 0, 0, 0, 843, 844, 1, 0,
		0, 0, 844, 846, 1, 0, 0, 0, 845, 843, 1, 0, 0, 0, 846, 847, 5, 1124, 0,
		0, 847, 849, 1, 0, 0, 0, 848, 837, 1, 0, 0, 0, 848, 849, 1, 0, 0, 0, 849,
		872, 1, 0, 0, 0, 850, 851, 5, 125, 0, 0, 851, 855, 3, 68, 34, 0, 852, 854,
		3, 50, 25, 0, 853, 852, 1, 0, 0, 0, 854, 857, 1, 0, 0, 0, 855, 853, 1,
		0, 0, 0, 855, 856, 1, 0, 0, 0, 856, 869, 1, 0, 0, 0, 857, 855, 1, 0, 0,
		0, 858, 859, 5, 1123, 0, 0, 859, 864, 3, 48, 24, 0, 860, 861, 5, 1125,
		0, 0, 861, 863, 3, 48, 24, 0, 862, 860, 1, 0, 0, 0, 863, 866, 1, 0, 0,
		0, 864, 862, 1, 0, 0, 0, 864, 865, 1, 0, 0, 0, 865, 867, 1, 0, 0, 0, 866,
		864, 1, 0, 0, 0, 867, 868, 5, 1124, 0, 0, 868, 870, 1, 0, 0, 0, 869, 858,
		1, 0, 0, 0, 869, 870, 1, 0, 0, 0, 870, 872, 1, 0, 0, 0, 871, 725, 1, 0,
		0, 0, 871, 759, 1, 0, 0, 0, 871, 784, 1, 0, 0, 0, 871, 817, 1, 0, 0, 0,
		871, 850, 1, 0, 0, 0, 872, 43, 1, 0, 0, 0, 873, 877, 3, 86, 43, 0, 874,
		877, 3, 114, 57, 0, 875, 877, 5, 106, 0, 0, 876, 873, 1, 0, 0, 0, 876,
		874, 1, 0, 0, 0, 876, 875, 1, 0, 0, 0, 877, 45, 1, 0, 0, 0, 878, 879, 5,
		1123, 0, 0, 879, 882, 3, 44, 22, 0, 880, 881, 5, 1125, 0, 0, 881, 883,
		3, 44, 22, 0, 882, 880, 1, 0, 0, 0, 883, 884, 1, 0, 0, 0, 884, 882, 1,
		0, 0, 0, 884, 885, 1, 0, 0, 0, 885, 886, 1, 0, 0, 0, 886, 887, 5, 1124,
		0, 0, 887, 47, 1, 0, 0, 0, 888, 889, 5, 624, 0, 0, 889, 893, 3, 68, 34,
		0, 890, 892, 3, 50, 25, 0, 891, 890, 1, 0, 0, 0, 892, 895, 1, 0, 0, 0,
		893, 891, 1, 0, 0, 0, 893, 894, 1, 0, 0, 0, 894, 49, 1, 0, 0, 0, 895, 893,
		1, 0, 0, 0, 896, 898, 5, 40, 0, 0, 897, 896, 1, 0, 0, 0, 897, 898, 1, 0,
		0, 0, 898, 900, 1, 0, 0, 0, 899, 901, 5, 619, 0, 0, 900, 899, 1, 0, 0,
		0, 900, 901, 1, 0, 0, 0, 901, 902, 1, 0, 0, 0, 902, 904, 5, 398, 0, 0,
		903, 905, 5, 1114, 0, 0, 904, 903, 1, 0, 0, 0, 904, 905, 1, 0, 0, 0, 905,
		906, 1, 0, 0, 0, 906, 945, 3, 66, 33, 0, 907, 909, 5, 359, 0, 0, 908, 910,
		5, 1114, 0, 0, 909, 908, 1, 0, 0, 0, 909, 910, 1, 0, 0, 0, 910, 911, 1,
		0, 0, 0, 911, 945, 5, 1138, 0, 0, 912, 913, 5, 379, 0, 0, 913, 915, 5,
		386, 0, 0, 914, 916, 5, 1114, 0, 0, 915, 914, 1, 0, 0, 0, 915, 916, 1,
		0, 0, 0, 916, 917, 1, 0, 0, 0, 917, 945, 5, 1138, 0, 0, 918, 919, 5, 78,
		0, 0, 919, 921, 5, 386, 0, 0, 920, 922, 5, 1114, 0, 0, 921, 920, 1, 0,
		0, 0, 921, 922, 1, 0, 0, 0, 922, 923, 1, 0, 0, 0, 923, 945, 5, 1138, 0,
		0, 924, 926, 5, 487, 0, 0, 925, 927, 5, 1114, 0, 0, 926, 925, 1, 0, 0,
		0, 926, 927, 1, 0, 0, 0, 927, 928, 1, 0, 0, 0, 928, 945, 3, 74, 37, 0,
		929, 931, 5, 497, 0, 0, 930, 932, 5, 1114, 0, 0, 931, 930, 1, 0, 0, 0,
		931, 932, 1, 0, 0, 0, 932, 933, 1, 0, 0, 0, 933, 945, 3, 74, 37, 0, 934,
		936, 5, 630, 0, 0, 935, 937, 5, 1114, 0, 0, 936, 935, 1, 0, 0, 0, 936,
		937, 1, 0, 0, 0, 937, 938, 1, 0, 0, 0, 938, 945, 3, 68, 34, 0, 939, 941,
		5, 515, 0, 0, 940, 942, 5, 1114, 0, 0, 941, 940, 1, 0, 0, 0, 941, 942,
		1, 0, 0, 0, 942, 943, 1, 0, 0, 0, 943, 945, 3, 68, 34, 0, 944, 897, 1,
		0, 0, 0, 944, 907, 1, 0, 0, 0, 944, 912, 1, 0, 0, 0, 944, 918, 1, 0, 0,
		0, 944, 924, 1, 0, 0, 0, 944, 929, 1, 0, 0, 0, 944, 934, 1, 0, 0, 0, 944,
		939, 1, 0, 0, 0, 945, 51, 1, 0, 0, 0, 946, 950, 3, 68, 34, 0, 947, 951,
		5, 1145, 0, 0, 948, 949, 5, 1122, 0, 0, 949, 951, 3, 68, 34, 0, 950, 947,
		1, 0, 0, 0, 950, 948, 1, 0, 0, 0, 950, 951, 1, 0, 0, 0, 951, 53, 1, 0,
		0, 0, 952, 953, 3, 52, 26, 0, 953, 55, 1, 0, 0, 0, 954, 959, 3, 68, 34,
		0, 955, 957, 3, 72, 36, 0, 956, 958, 3, 72, 36, 0, 957, 956, 1, 0, 0, 0,
		957, 958, 1, 0, 0, 0, 958, 960, 1, 0, 0, 0, 959, 955, 1, 0, 0, 0, 959,
		960, 1, 0, 0, 0, 960, 967, 1, 0, 0, 0, 961, 962, 9, 0, 0, 0, 962, 964,
		3, 72, 36, 0, 963, 965, 3, 72, 36, 0, 964, 963, 1, 0, 0, 0, 964, 965, 1,
		0, 0, 0, 965, 967, 1, 0, 0, 0, 966, 954, 1, 0, 0, 0, 966, 961, 1, 0, 0,
		0, 967, 57, 1, 0, 0, 0, 968, 971, 3, 68, 34, 0, 969, 971, 5, 1138, 0, 0,
		970, 968, 1, 0, 0, 0, 970, 969, 1, 0, 0, 0, 971, 976, 1, 0, 0, 0, 972,
		973, 5, 1123, 0, 0, 973, 974, 3, 74, 37, 0, 974, 975, 5, 1124, 0, 0, 975,
		977, 1, 0, 0, 0, 976, 972, 1, 0, 0, 0, 976, 977, 1, 0, 0, 0, 977, 980,
		1, 0, 0, 0, 978, 980, 3, 114, 57, 0, 979, 970, 1, 0, 0, 0, 979, 978, 1,
		0, 0, 0, 980, 982, 1, 0, 0, 0, 981, 983, 7, 19, 0, 0, 982, 981, 1, 0, 0,
		0, 982, 983, 1, 0, 0, 0, 983, 59, 1, 0, 0, 0, 984, 985, 7, 20, 0, 0, 985,
		61, 1, 0, 0, 0, 986, 991, 5, 220, 0, 0, 987, 991, 3, 132, 66, 0, 988, 991,
		5, 1138, 0, 0, 989, 991, 5, 1135, 0, 0, 990, 986, 1, 0, 0, 0, 990, 987,
		1, 0, 0, 0, 990, 988, 1, 0, 0, 0, 990, 989, 1, 0, 0, 0, 991, 63, 1, 0,
		0, 0, 992, 995, 3, 68, 34, 0, 993, 995, 5, 1138, 0, 0, 994, 992, 1, 0,
		0, 0, 994, 993, 1, 0, 0, 0, 995, 65, 1, 0, 0, 0, 996, 997, 7, 21, 0, 0,
		997, 67, 1, 0, 0, 0, 998, 1002, 3, 70, 35, 0, 999, 1002, 5, 1147, 0, 0,
		1000, 1002, 5, 1135, 0, 0, 1001, 998, 1, 0, 0, 0, 1001, 999, 1, 0, 0, 0,
		1001, 1000, 1, 0, 0, 0, 1002, 69, 1, 0, 0, 0, 1003, 1013, 5, 1146, 0, 0,
		1004, 1013, 3, 132, 66, 0, 1005, 1013, 3, 134, 67, 0, 1006, 1013, 3, 66,
		33, 0, 1007, 1013, 3, 136, 68, 0, 1008, 1013, 3, 138, 69, 0, 1009, 1013,
		3, 140, 70, 0, 1010, 1013, 3, 142, 71, 0, 1011, 1013, 3, 112, 56, 0, 1012,
		1003, 1, 0, 0, 0, 1012, 1004, 1, 0, 0, 0, 1012, 1005, 1, 0, 0, 0, 1012,
		1006, 1, 0, 0, 0, 1012, 1007, 1, 0, 0, 0, 1012, 1008, 1, 0, 0, 0, 1012,
		1009, 1, 0, 0, 0, 1012, 1010, 1, 0, 0, 0, 1012, 1011, 1, 0, 0, 0, 1013,
		71, 1, 0, 0, 0, 1014, 1018, 5, 1145, 0, 0, 1015, 1016, 5, 1122, 0, 0, 1016,
		1018, 3, 68, 34, 0, 1017, 1014, 1, 0, 0, 0, 1017, 1015, 1, 0, 0, 0, 1018,
		73, 1, 0, 0, 0, 1019, 1020, 7, 22, 0, 0, 1020, 75, 1, 0, 0, 0, 1021, 1024,
		5, 1136, 0, 0, 1022, 1024, 3, 74, 37, 0, 1023, 1021, 1, 0, 0, 0, 1023,
		1022, 1, 0, 0, 0, 1024, 77, 1, 0, 0, 0, 1025, 1027, 5, 1144, 0, 0, 1026,
		1025, 1, 0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027, 1028, 1, 0, 0, 0, 1028,
		1031, 5, 1138, 0, 0, 1029, 1031, 5, 1137, 0, 0, 1030, 1026, 1, 0, 0, 0,
		1030, 1029, 1, 0, 0, 0, 1031, 1033, 1, 0, 0, 0, 1032, 1034, 5, 1138, 0,
		0, 1033, 1032, 1, 0, 0, 0, 1034, 1035, 1, 0, 0, 0, 1035, 1033, 1, 0, 0,
		0, 1035, 1036, 1, 0, 0, 0, 1036, 1049, 1, 0, 0, 0, 1037, 1039, 5, 1144,
		0, 0, 1038, 1037, 1, 0, 0, 0, 1038, 1039, 1, 0, 0, 0, 1039, 1040, 1, 0,
		0, 0, 1040, 1043, 5, 1138, 0, 0, 1041, 1043, 5, 1137, 0, 0, 1042, 1038,
		1, 0, 0, 0, 1042, 1041, 1, 0, 0, 0, 1043, 1046, 1, 0, 0, 0, 1044, 1045,
		5, 26, 0, 0, 1045, 1047, 3, 64, 32, 0, 1046, 1044, 1, 0, 0, 0, 1046, 1047,
		1, 0, 0, 0, 1047, 1049, 1, 0, 0, 0, 1048, 1030, 1, 0, 0, 0, 1048, 1042,
		1, 0, 0, 0, 1049, 79, 1, 0, 0, 0, 1050, 1051, 7, 23, 0, 0, 1051, 81, 1,
		0, 0, 0, 1052, 1054, 5, 1144, 0, 0, 1053, 1052, 1, 0, 0, 0, 1053, 1054,
		1, 0, 0, 0, 1054, 1055, 1, 0, 0, 0, 1055, 1056, 5, 1140, 0, 0, 1056, 83,
		1, 0, 0, 0, 1057, 1059, 5, 110, 0, 0, 1058, 1057, 1, 0, 0, 0, 1058, 1059,
		1, 0, 0, 0, 1059, 1060, 1, 0, 0, 0, 1060, 1061, 7, 24, 0, 0, 1061, 85,
		1, 0, 0, 0, 1062, 1075, 3, 78, 39, 0, 1063, 1075, 3, 74, 37, 0, 1064, 1065,
		5, 1111, 0, 0, 1065, 1075, 3, 74, 37, 0, 1066, 1075, 3, 82, 41, 0, 1067,
		1075, 3, 80, 40, 0, 1068, 1075, 5, 1141, 0, 0, 1069, 1075, 5, 1143, 0,
		0, 1070, 1072, 5, 110, 0, 0, 1071, 1070, 1, 0, 0, 0, 1071, 1072, 1, 0,
		0, 0, 1072, 1073, 1, 0, 0, 0, 1073, 1075, 7, 24, 0, 0, 1074, 1062, 1, 0,
		0, 0, 1074, 1063, 1, 0, 0, 0, 1074, 1064, 1, 0, 0, 0, 1074, 1066, 1, 0,
		0, 0, 1074, 1067, 1, 0, 0, 0, 1074, 1068, 1, 0, 0, 0, 1074, 1069, 1, 0,
		0, 0, 1074, 1071, 1, 0, 0, 0, 1075, 87, 1, 0, 0, 0, 1076, 1078, 7, 25,
		0, 0, 1077, 1079, 3, 94, 47, 0, 1078, 1077, 1, 0, 0, 0, 1078, 1079, 1,
		0, 0, 0, 1079, 1083, 1, 0, 0, 0, 1080, 1082, 7, 26, 0, 0, 1081, 1080, 1,
		0, 0, 0, 1082, 1085, 1, 0, 0, 0, 1083, 1081, 1, 0, 0, 0, 1083, 1084, 1,
		0, 0, 0, 1084, 1212, 1, 0, 0, 0, 1085, 1083, 1, 0, 0, 0, 1086, 1088, 7,
		27, 0, 0, 1087, 1089, 3, 98, 49, 0, 1088, 1087, 1, 0, 0, 0, 1088, 1089,
		1, 0, 0, 0, 1089, 1093, 1, 0, 0, 0, 1090, 1092, 7, 26, 0, 0, 1091, 1090,
		1, 0, 0, 0, 1092, 1095, 1, 0, 0, 0, 1093, 1091, 1, 0, 0, 0, 1093, 1094,
		1, 0, 0, 0, 1094, 1212, 1, 0, 0, 0, 1095, 1093, 1, 0, 0, 0, 1096, 1098,
		5, 203, 0, 0, 1097, 1099, 5, 204, 0, 0, 1098, 1097, 1, 0, 0, 0, 1098, 1099,
		1, 0, 0, 0, 1099, 1101, 1, 0, 0, 0, 1100, 1102, 3, 96, 48, 0, 1101, 1100,
		1, 0, 0, 0, 1101, 1102, 1, 0, 0, 0, 1102, 1106, 1, 0, 0, 0, 1103, 1105,
		7, 26, 0, 0, 1104, 1103, 1, 0, 0, 0, 1105, 1108, 1, 0, 0, 0, 1106, 1104,
		1, 0, 0, 0, 1106, 1107, 1, 0, 0, 0, 1107, 1212, 1, 0, 0, 0, 1108, 1106,
		1, 0, 0, 0, 1109, 1111, 5, 202, 0, 0, 1110, 1112, 3, 96, 48, 0, 1111, 1110,
		1, 0, 0, 0, 1111, 1112, 1, 0, 0, 0, 1112, 1116, 1, 0, 0, 0, 1113, 1115,
		7, 26, 0, 0, 1114, 1113, 1, 0, 0, 0, 1115, 1118, 1, 0, 0, 0, 1116, 1114,
		1, 0, 0, 0, 1116, 1117, 1, 0, 0, 0, 1117, 1212, 1, 0, 0, 0, 1118, 1116,
		1, 0, 0, 0, 1119, 1121, 7, 28, 0, 0, 1120, 1122, 3, 94, 47, 0, 1121, 1120,
		1, 0, 0, 0, 1121, 1122, 1, 0, 0, 0, 1122, 1212, 1, 0, 0, 0, 1123, 1212,
		5, 211, 0, 0, 1124, 1126, 7, 29, 0, 0, 1125, 1127, 5, 232, 0, 0, 1126,
		1125, 1, 0, 0, 0, 1126, 1127, 1, 0, 0, 0, 1127, 1129, 1, 0, 0, 0, 1128,
		1130, 3, 94, 47, 0, 1129, 1128, 1, 0, 0, 0, 1129, 1130, 1, 0, 0, 0, 1130,
		1132, 1, 0, 0, 0, 1131, 1133, 5, 220, 0, 0, 1132, 1131, 1, 0, 0, 0, 1132,
		1133, 1, 0, 0, 0, 1133, 1137, 1, 0, 0, 0, 1134, 1135, 3, 4, 2, 0, 1135,
		1136, 3, 62, 31, 0, 1136, 1138, 1, 0, 0, 0, 1137, 1134, 1, 0, 0, 0, 1137,
		1138, 1, 0, 0, 0, 1138, 1142, 1, 0, 0, 0, 1139, 1140, 5, 26, 0, 0, 1140,
		1143, 3, 64, 32, 0, 1141, 1143, 5, 220, 0, 0, 1142, 1139, 1, 0, 0, 0, 1142,
		1141, 1, 0, 0, 0, 1142, 1143, 1, 0, 0, 0, 1143, 1212, 1, 0, 0, 0, 1144,
		1145, 5, 219, 0, 0, 1145, 1147, 7, 30, 0, 0, 1146, 1148, 3, 94, 47, 0,
		1147, 1146, 1, 0, 0, 0, 1147, 1148, 1, 0, 0, 0, 1148, 1150, 1, 0, 0, 0,
		1149, 1151, 5, 220, 0, 0, 1150, 1149, 1, 0, 0, 0, 1150, 1151, 1, 0, 0,
		0, 1151, 1212, 1, 0, 0, 0, 1152, 1153, 5, 505, 0, 0, 1153, 1155, 5, 217,
		0, 0, 1154, 1156, 3, 94, 47, 0, 1155, 1154, 1, 0, 0, 0, 1155, 1156, 1,
		0, 0, 0, 1156, 1158, 1, 0, 0, 0, 1157, 1159, 5, 220, 0, 0, 1158, 1157,
		1, 0, 0, 0, 1158, 1159, 1, 0, 0, 0, 1159, 1212, 1, 0, 0, 0, 1160, 1161,
		5, 219, 0, 0, 1161, 1162, 7, 31, 0, 0, 1162, 1164, 5, 232, 0, 0, 1163,
		1165, 3, 94, 47, 0, 1164, 1163, 1, 0, 0, 0, 1164, 1165, 1, 0, 0, 0, 1165,
		1167, 1, 0, 0, 0, 1166, 1168, 5, 220, 0, 0, 1167, 1166, 1, 0, 0, 0, 1167,
		1168, 1, 0, 0, 0, 1168, 1212, 1, 0, 0, 0, 1169, 1171, 5, 225, 0, 0, 1170,
		1172, 5, 217, 0, 0, 1171, 1170, 1, 0, 0, 0, 1171, 1172, 1, 0, 0, 0, 1172,
		1174, 1, 0, 0, 0, 1173, 1175, 5, 220, 0, 0, 1174, 1173, 1, 0, 0, 0, 1174,
		1175, 1, 0, 0, 0, 1175, 1179, 1, 0, 0, 0, 1176, 1177, 3, 4, 2, 0, 1177,
		1178, 3, 62, 31, 0, 1178, 1180, 1, 0, 0, 0, 1179, 1176, 1, 0, 0, 0, 1179,
		1180, 1, 0, 0, 0, 1180, 1183, 1, 0, 0, 0, 1181, 1182, 5, 26, 0, 0, 1182,
		1184, 3, 64, 32, 0, 1183, 1181, 1, 0, 0, 0, 1183, 1184, 1, 0, 0, 0, 1184,
		1212, 1, 0, 0, 0, 1185, 1186, 5, 225, 0, 0, 1186, 1189, 5, 221, 0, 0, 1187,
		1189, 5, 453, 0, 0, 1188, 1185, 1, 0, 0, 0, 1188, 1187, 1, 0, 0, 0, 1189,
		1212, 1, 0, 0, 0, 1190, 1191, 7, 32, 0, 0, 1191, 1193, 3, 90, 45, 0, 1192,
		1194, 5, 220, 0, 0, 1193, 1192, 1, 0, 0, 0, 1193, 1194, 1, 0, 0, 0, 1194,
		1198, 1, 0, 0, 0, 1195, 1196, 3, 4, 2, 0, 1196, 1197, 3, 62, 31, 0, 1197,
		1199, 1, 0, 0, 0, 1198, 1195, 1, 0, 0, 0, 1198, 1199, 1, 0, 0, 0, 1199,
		1212, 1, 0, 0, 0, 1200, 1202, 7, 33, 0, 0, 1201, 1203, 3, 94, 47, 0, 1202,
		1201, 1, 0, 0, 0, 1202, 1203, 1, 0, 0, 0, 1203, 1212, 1, 0, 0, 0, 1204,
		1212, 7, 34, 0, 0, 1205, 1212, 7, 35, 0, 0, 1206, 1208, 7, 36, 0, 0, 1207,
		1209, 3, 94, 47, 0, 1208, 1207, 1, 0, 0, 0, 1208, 1209, 1, 0, 0, 0, 1209,
		1212, 1, 0, 0, 0, 1210, 1212, 7, 37, 0, 0, 1211, 1076, 1, 0, 0, 0, 1211,
		1086, 1, 0, 0, 0, 1211, 1096, 1, 0, 0, 0, 1211, 1109, 1, 0, 0, 0, 1211,
		1119, 1, 0, 0, 0, 1211, 1123, 1, 0, 0, 0, 1211, 1124, 1, 0, 0, 0, 1211,
		1144, 1, 0, 0, 0, 1211, 1152, 1, 0, 0, 0, 1211, 1160, 1, 0, 0, 0, 1211,
		1169, 1, 0, 0, 0, 1211, 1188, 1, 0, 0, 0, 1211, 1190, 1, 0, 0, 0, 1211,
		1200, 1, 0, 0, 0, 1211, 1204, 1, 0, 0, 0, 1211, 1205, 1, 0, 0, 0, 1211,
		1206, 1, 0, 0, 0, 1211, 1210, 1, 0, 0, 0, 1212, 89, 1, 0, 0, 0, 1213, 1214,
		5, 1123, 0, 0, 1214, 1219, 5, 1138, 0, 0, 1215, 1216, 5, 1125, 0, 0, 1216,
		1218, 5, 1138, 0, 0, 1217, 1215, 1, 0, 0, 0, 1218, 1221, 1, 0, 0, 0, 1219,
		1217, 1, 0, 0, 0, 1219, 1220, 1, 0, 0, 0, 1220, 1222, 1, 0, 0, 0, 1221,
		1219, 1, 0, 0, 0, 1222, 1223, 5, 1124, 0, 0, 1223, 91, 1, 0, 0, 0, 1224,
		1226, 7, 38, 0, 0, 1225, 1227, 3, 94, 47, 0, 1226, 1225, 1, 0, 0, 0, 1226,
		1227, 1, 0, 0, 0, 1227, 1247, 1, 0, 0, 0, 1228, 1230, 5, 216, 0, 0, 1229,
		1231, 3, 94, 47, 0, 1230, 1229, 1, 0, 0, 0, 1230, 1231, 1, 0, 0, 0, 1231,
		1235, 1, 0, 0, 0, 1232, 1233, 3, 4, 2, 0, 1233, 1234, 3, 62, 31, 0, 1234,
		1236, 1, 0, 0, 0, 1235, 1232, 1, 0, 0, 0, 1235, 1236, 1, 0, 0, 0, 1236,
		1247, 1, 0, 0, 0, 1237, 1247, 7, 39, 0, 0, 1238, 1240, 5, 208, 0, 0, 1239,
		1241, 3, 98, 49, 0, 1240, 1239, 1, 0, 0, 0, 1240, 1241, 1, 0, 0, 0, 1241,
		1247, 1, 0, 0, 0, 1242, 1244, 7, 40, 0, 0, 1243, 1245, 5, 200, 0, 0, 1244,
		1243, 1, 0, 0, 0, 1244, 1245, 1, 0, 0, 0, 1245, 1247, 1, 0, 0, 0, 1246,
		1224, 1, 0, 0, 0, 1246, 1228, 1, 0, 0, 0, 1246, 1237, 1, 0, 0, 0, 1246,
		1238, 1, 0, 0, 0, 1246, 1242, 1, 0, 0, 0, 1247, 1249, 1, 0, 0, 0, 1248,
		1250, 5, 11, 0, 0, 1249, 1248, 1, 0, 0, 0, 1249, 1250, 1, 0, 0, 0, 1250,
		93, 1, 0, 0, 0, 1251, 1252, 5, 1123, 0, 0, 1252, 1253, 3, 74, 37, 0, 1253,
		1254, 5, 1124, 0, 0, 1254, 95, 1, 0, 0, 0, 1255, 1256, 5, 1123, 0, 0, 1256,
		1257, 3, 74, 37, 0, 1257, 1258, 5, 1125, 0, 0, 1258, 1259, 3, 74, 37, 0,
		1259, 1260, 5, 1124, 0, 0, 1260, 97, 1, 0, 0, 0, 1261, 1262, 5, 1123, 0,
		0, 1262, 1265, 3, 74, 37, 0, 1263, 1264, 5, 1125, 0, 0, 1264, 1266, 3,
		74, 37, 0, 1265, 1263, 1, 0, 0, 0, 1265, 1266, 1, 0, 0, 0, 1266, 1267,
		1, 0, 0, 0, 1267, 1268, 5, 1124, 0, 0, 1268, 99, 1, 0, 0, 0, 1269, 1274,
		3, 68, 34, 0, 1270, 1271, 5, 1125, 0, 0, 1271, 1273, 3, 68, 34, 0, 1272,
		1270, 1, 0, 0, 0, 1273, 1276, 1, 0, 0, 0, 1274, 1272, 1, 0, 0, 0, 1274,
		1275, 1, 0, 0, 0, 1275, 101, 1, 0, 0, 0, 1276, 1274, 1, 0, 0, 0, 1277,
		1282, 3, 54, 27, 0, 1278, 1279, 5, 1125, 0, 0, 1279, 1281, 3, 54, 27, 0,
		1280, 1278, 1, 0, 0, 0, 1281, 1284, 1, 0, 0, 0, 1282, 1280, 1, 0, 0, 0,
		1282, 1283, 1, 0, 0, 0, 1283, 103, 1, 0, 0, 0, 1284, 1282, 1, 0, 0, 0,
		1285, 1286, 5, 1123, 0, 0, 1286, 1291, 3, 58, 29, 0, 1287, 1288, 5, 1125,
		0, 0, 1288, 1290, 3, 58, 29, 0, 1289, 1287, 1, 0, 0, 0, 1290, 1293, 1,
		0, 0, 0, 1291, 1289, 1, 0, 0, 0, 1291, 1292, 1, 0, 0, 0, 1292, 1294, 1,
		0, 0, 0, 1293, 1291, 1, 0, 0, 0, 1294, 1295, 5, 1124, 0, 0, 1295, 105,
		1, 0, 0, 0, 1296, 1332, 5, 112, 0, 0, 1297, 1298, 5, 22, 0, 0, 1298, 1299,
		5, 1123, 0, 0, 1299, 1300, 3, 114, 57, 0, 1300, 1301, 5, 12, 0, 0, 1301,
		1302, 3, 92, 46, 0, 1302, 1303, 5, 1124, 0, 0, 1303, 1332, 1, 0, 0, 0,
		1304, 1306, 3, 120, 60, 0, 1305, 1304, 1, 0, 0, 0, 1305, 1306, 1, 0, 0,
		0, 1306, 1307, 1, 0, 0, 0, 1307, 1332, 3, 86, 43, 0, 1308, 1312, 3, 108,
		54, 0, 1309, 1310, 5, 114, 0, 0, 1310, 1311, 5, 178, 0, 0, 1311, 1313,
		3, 108, 54, 0, 1312, 1309, 1, 0, 0, 0, 1312, 1313, 1, 0, 0, 0, 1313, 1332,
		1, 0, 0, 0, 1314, 1315, 5, 1123, 0, 0, 1315, 1316, 3, 114, 57, 0, 1316,
		1317, 5, 1124, 0, 0, 1317, 1332, 1, 0, 0, 0, 1318, 1319, 7, 41, 0, 0, 1319,
		1320, 5, 1123, 0, 0, 1320, 1321, 3, 52, 26, 0, 1321, 1322, 5, 1124, 0,
		0, 1322, 1332, 1, 0, 0, 0, 1323, 1324, 5, 1123, 0, 0, 1324, 1325, 7, 42,
		0, 0, 1325, 1326, 5, 652, 0, 0, 1326, 1327, 5, 62, 0, 0, 1327, 1328, 3,
		52, 26, 0, 1328, 1329, 5, 1124, 0, 0, 1329, 1332, 1, 0, 0, 0, 1330, 1332,
		3, 114, 57, 0, 1331, 1296, 1, 0, 0, 0, 1331, 1297, 1, 0, 0, 0, 1331, 1305,
		1, 0, 0, 0, 1331, 1308, 1, 0, 0, 0, 1331, 1314, 1, 0, 0, 0, 1331, 1318,
		1, 0, 0, 0, 1331, 1323, 1, 0, 0, 0, 1331, 1330, 1, 0, 0, 0, 1332, 107,
		1, 0, 0, 0, 1333, 1339, 7, 43, 0, 0, 1334, 1336, 5, 1123, 0, 0, 1335, 1337,
		3, 74, 37, 0, 1336, 1335, 1, 0, 0, 0, 1336, 1337, 1, 0, 0, 0, 1337, 1338,
		1, 0, 0, 0, 1338, 1340, 5, 1124, 0, 0, 1339, 1334, 1, 0, 0, 0, 1339, 1340,
		1, 0, 0, 0, 1340, 1348, 1, 0, 0, 0, 1341, 1342, 5, 314, 0, 0, 1342, 1344,
		5, 1123, 0, 0, 1343, 1345, 3, 74, 37, 0, 1344, 1343, 1, 0, 0, 0, 1344,
		1345, 1, 0, 0, 0, 1345, 1346, 1, 0, 0, 0, 1346, 1348, 5, 1124, 0, 0, 1347,
		1333, 1, 0, 0, 0, 1347, 1341, 1, 0, 0, 0, 1348, 109, 1, 0, 0, 0, 1349,
		1350, 5, 74, 0, 0, 1350, 1351, 5, 110, 0, 0, 1351, 1352, 5, 57, 0, 0, 1352,
		111, 1, 0, 0, 0, 1353, 1377, 3, 144, 72, 0, 1354, 1377, 5, 727, 0, 0, 1355,
		1377, 5, 308, 0, 0, 1356, 1377, 5, 304, 0, 0, 1357, 1377, 5, 305, 0, 0,
		1358, 1377, 5, 306, 0, 0, 1359, 1377, 5, 309, 0, 0, 1360, 1377, 5, 310,
		0, 0, 1361, 1377, 5, 311, 0, 0, 1362, 1377, 5, 74, 0, 0, 1363, 1377, 5,
		82, 0, 0, 1364, 1377, 5, 307, 0, 0, 1365, 1377, 5, 313, 0, 0, 1366, 1377,
		5, 495, 0, 0, 1367, 1377, 5, 314, 0, 0, 1368, 1377, 5, 137, 0, 0, 1369,
		1377, 5, 316, 0, 0, 1370, 1377, 5, 317, 0, 0, 1371, 1377, 5, 318, 0, 0,
		1372, 1377, 5, 319, 0, 0, 1373, 1377, 5, 320, 0, 0, 1374, 1377, 5, 321,
		0, 0, 1375, 1377, 5, 322, 0, 0, 1376, 1353, 1, 0, 0, 0, 1376, 1354, 1,
		0, 0, 0, 1376, 1355, 1, 0, 0, 0, 1376, 1356, 1, 0, 0, 0, 1376, 1357, 1,
		0, 0, 0, 1376, 1358, 1, 0, 0, 0, 1376, 1359, 1, 0, 0, 0, 1376, 1360, 1,
		0, 0, 0, 1376, 1361, 1, 0, 0, 0, 1376, 1362, 1, 0, 0, 0, 1376, 1363, 1,
		0, 0, 0, 1376, 1364, 1, 0, 0, 0, 1376, 1365, 1, 0, 0, 0, 1376, 1366, 1,
		0, 0, 0, 1376, 1367, 1, 0, 0, 0, 1376, 1368, 1, 0, 0, 0, 1376, 1369, 1,
		0, 0, 0, 1376, 1370, 1, 0, 0, 0, 1376, 1371, 1, 0, 0, 0, 1376, 1372, 1,
		0, 0, 0, 1376, 1373, 1, 0, 0, 0, 1376, 1374, 1, 0, 0, 0, 1376, 1375, 1,
		0, 0, 0, 1377, 113, 1, 0, 0, 0, 1378, 1379, 6, 57, -1, 0, 1379, 1380, 7,
		44, 0, 0, 1380, 1390, 3, 114, 57, 4, 1381, 1382, 3, 116, 58, 0, 1382, 1384,
		5, 85, 0, 0, 1383, 1385, 5, 110, 0, 0, 1384, 1383, 1, 0, 0, 0, 1384, 1385,
		1, 0, 0, 0, 1385, 1386, 1, 0, 0, 0, 1386, 1387, 7, 45, 0, 0, 1387, 1390,
		1, 0, 0, 0, 1388, 1390, 3, 116, 58, 0, 1389, 1378, 1, 0, 0, 0, 1389, 1381,
		1, 0, 0, 0, 1389, 1388, 1, 0, 0, 0, 1390, 1397, 1, 0, 0, 0, 1391, 1392,
		10, 3, 0, 0, 1392, 1393, 3, 124, 62, 0, 1393, 1394, 3, 114, 57, 4, 1394,
		1396, 1, 0, 0, 0, 1395, 1391, 1, 0, 0, 0, 1396, 1399, 1, 0, 0, 0, 1397,
		1395, 1, 0, 0, 0, 1397, 1398, 1, 0, 0, 0, 1398, 115, 1, 0, 0, 0, 1399,
		1397, 1, 0, 0, 0, 1400, 1403, 6, 58, -1, 0, 1401, 1402, 5, 1151, 0, 0,
		1402, 1404, 5, 1098, 0, 0, 1403, 1401, 1, 0, 0, 0, 1403, 1404, 1, 0, 0,
		0, 1404, 1405, 1, 0, 0, 0, 1405, 1406, 3, 118, 59, 0, 1406, 1452, 1, 0,
		0, 0, 1407, 1408, 10, 7, 0, 0, 1408, 1409, 3, 122, 61, 0, 1409, 1410, 3,
		116, 58, 8, 1410, 1451, 1, 0, 0, 0, 1411, 1413, 10, 6, 0, 0, 1412, 1414,
		5, 110, 0, 0, 1413, 1412, 1, 0, 0, 0, 1413, 1414, 1, 0, 0, 0, 1414, 1415,
		1, 0, 0, 0, 1415, 1416, 5, 15, 0, 0, 1416, 1417, 3, 116, 58, 0, 1417, 1418,
		5, 10, 0, 0, 1418, 1419, 3, 116, 58, 7, 1419, 1451, 1, 0, 0, 0, 1420, 1421,
		10, 5, 0, 0, 1421, 1422, 5, 603, 0, 0, 1422, 1423, 5, 94, 0, 0, 1423, 1451,
		3, 116, 58, 6, 1424, 1426, 10, 3, 0, 0, 1425, 1427, 5, 110, 0, 0, 1426,
		1425, 1, 0, 0, 0, 1426, 1427, 1, 0, 0, 0, 1427, 1428, 1, 0, 0, 0, 1428,
		1429, 7, 46, 0, 0, 1429, 1451, 3, 116, 58, 4, 1430, 1431, 10, 8, 0, 0,
		1431, 1432, 5, 85, 0, 0, 1432, 1451, 3, 84, 42, 0, 1433, 1435, 10, 4, 0,
		0, 1434, 1436, 5, 110, 0, 0, 1435, 1434, 1, 0, 0, 0, 1435, 1436, 1, 0,
		0, 0, 1436, 1437, 1, 0, 0, 0, 1437, 1438, 5, 94, 0, 0, 1438, 1441, 3, 116,
		58, 0, 1439, 1440, 5, 402, 0, 0, 1440, 1442, 5, 1138, 0, 0, 1441, 1439,
		1, 0, 0, 0, 1441, 1442, 1, 0, 0, 0, 1442, 1451, 1, 0, 0, 0, 1443, 1444,
		10, 1, 0, 0, 1444, 1445, 5, 492, 0, 0, 1445, 1446, 5, 520, 0, 0, 1446,
		1447, 5, 1123, 0, 0, 1447, 1448, 3, 116, 58, 0, 1448, 1449, 5, 1124, 0,
		0, 1449, 1451, 1, 0, 0, 0, 1450, 1407, 1, 0, 0, 0, 1450, 1411, 1, 0, 0,
		0, 1450, 1420, 1, 0, 0, 0, 1450, 1424, 1, 0, 0, 0, 1450, 1430, 1, 0, 0,
		0, 1450, 1433, 1, 0, 0, 0, 1450, 1443, 1, 0, 0, 0, 1451, 1454, 1, 0, 0,
		0, 1452, 1450, 1, 0, 0, 0, 1452, 1453, 1, 0, 0, 0, 1453, 117, 1, 0, 0,
		0, 1454, 1452, 1, 0, 0, 0, 1455, 1456, 6, 59, -1, 0, 1456, 1491, 3, 86,
		43, 0, 1457, 1491, 3, 56, 28, 0, 1458, 1491, 3, 60, 30, 0, 1459, 1460,
		3, 120, 60, 0, 1460, 1461, 3, 118, 59, 8, 1461, 1491, 1, 0, 0, 0, 1462,
		1463, 5, 220, 0, 0, 1463, 1491, 3, 118, 59, 7, 1464, 1465, 5, 1123, 0,
		0, 1465, 1470, 3, 114, 57, 0, 1466, 1467, 5, 1125, 0, 0, 1467, 1469, 3,
		114, 57, 0, 1468, 1466, 1, 0, 0, 0, 1469, 1472, 1, 0, 0, 0, 1470, 1468,
		1, 0, 0, 0, 1470, 1471, 1, 0, 0, 0, 1471, 1473, 1, 0, 0, 0, 1472, 1470,
		1, 0, 0, 0, 1473, 1474, 5, 1124, 0, 0, 1474, 1491, 1, 0, 0, 0, 1475, 1476,
		5, 583, 0, 0, 1476, 1477, 5, 1123, 0, 0, 1477, 1480, 3, 114, 57, 0, 1478,
		1479, 5, 1125, 0, 0, 1479, 1481, 3, 114, 57, 0, 1480, 1478, 1, 0, 0, 0,
		1481, 1482, 1, 0, 0, 0, 1482, 1480, 1, 0, 0, 0, 1482, 1483, 1, 0, 0, 0,
		1483, 1484, 1, 0, 0, 0, 1484, 1485, 5, 1124, 0, 0, 1485, 1491, 1, 0, 0,
		0, 1486, 1487, 5, 83, 0, 0, 1487, 1488, 3, 114, 57, 0, 1488, 1489, 3, 6,
		3, 0, 1489, 1491, 1, 0, 0, 0, 1490, 1455, 1, 0, 0, 0, 1490, 1457, 1, 0,
		0, 0, 1490, 1458, 1, 0, 0, 0, 1490, 1459, 1, 0, 0, 0, 1490, 1462, 1, 0,
		0, 0, 1490, 1464, 1, 0, 0, 0, 1490, 1475, 1, 0, 0, 0, 1490, 1486, 1, 0,
		0, 0, 1491, 1509, 1, 0, 0, 0, 1492, 1493, 10, 3, 0, 0, 1493, 1494, 3, 126,
		63, 0, 1494, 1495, 3, 118, 59, 4, 1495, 1508, 1, 0, 0, 0, 1496, 1497, 10,
		2, 0, 0, 1497, 1498, 3, 128, 64, 0, 1498, 1499, 3, 118, 59, 3, 1499, 1508,
		1, 0, 0, 0, 1500, 1501, 10, 1, 0, 0, 1501, 1502, 3, 130, 65, 0, 1502, 1503,
		3, 118, 59, 2, 1503, 1508, 1, 0, 0, 0, 1504, 1505, 10, 10, 0, 0, 1505,
		1506, 5, 26, 0, 0, 1506, 1508, 3, 64, 32, 0, 1507, 1492, 1, 0, 0, 0, 1507,
		1496, 1, 0, 0, 0, 1507, 1500, 1, 0, 0, 0, 1507, 1504, 1, 0, 0, 0, 1508,
		1511, 1, 0, 0, 0, 1509, 1507, 1, 0, 0, 0, 1509, 1510, 1, 0, 0, 0, 1510,
		119, 1, 0, 0, 0, 1511, 1509, 1, 0, 0, 0, 1512, 1513, 7, 47, 0, 0, 1513,
		121, 1, 0, 0, 0, 1514, 1529, 5, 1114, 0, 0, 1515, 1529, 5, 1115, 0, 0,
		1516, 1529, 5, 1116, 0, 0, 1517, 1518, 5, 1116, 0, 0, 1518, 1529, 5, 1114,
		0, 0, 1519, 1520, 5, 1115, 0, 0, 1520, 1529, 5, 1114, 0, 0, 1521, 1522,
		5, 1116, 0, 0, 1522, 1529, 5, 1115, 0, 0, 1523, 1524, 5, 1117, 0, 0, 1524,
		1529, 5, 1114, 0, 0, 1525, 1526, 5, 1116, 0, 0, 1526, 1527, 5, 1114, 0,
		0, 1527, 1529, 5, 1115, 0, 0, 1528, 1514, 1, 0, 0, 0, 1528, 1515, 1, 0,
		0, 0, 1528, 1516, 1, 0, 0, 0, 1528, 1517, 1, 0, 0, 0, 1528, 1519, 1, 0,
		0, 0, 1528, 1521, 1, 0, 0, 0, 1528, 1523, 1, 0, 0, 0, 1528, 1525, 1, 0,
		0, 0, 1529, 123, 1, 0, 0, 0, 1530, 1538, 5, 10, 0, 0, 1531, 1532, 5, 1120,
		0, 0, 1532, 1538, 5, 1120, 0, 0, 1533, 1538, 5, 188, 0, 0, 1534, 1538,
		5, 119, 0, 0, 1535, 1536, 5, 1119, 0, 0, 1536, 1538, 5, 1119, 0, 0, 1537,
		1530, 1, 0, 0, 0, 1537, 1531, 1, 0, 0, 0, 1537, 1533, 1, 0, 0, 0, 1537,
		1534, 1, 0, 0, 0, 1537, 1535, 1, 0, 0, 0, 1538, 125, 1, 0, 0, 0, 1539,
		1540, 5, 1116, 0, 0, 1540, 1547, 5, 1116, 0, 0, 1541, 1542, 5, 1115, 0,
		0, 1542, 1547, 5, 1115, 0, 0, 1543, 1547, 5, 1120, 0, 0, 1544, 1547, 5,
		1121, 0, 0, 1545, 1547, 5, 1119, 0, 0, 1546, 1539, 1, 0, 0, 0, 1546, 1541,
		1, 0, 0, 0, 1546, 1543, 1, 0, 0, 0, 1546, 1544, 1, 0, 0, 0, 1546, 1545,
		1, 0, 0, 0, 1547, 127, 1, 0, 0, 0, 1548, 1549, 7, 48, 0, 0, 1549, 129,
		1, 0, 0, 0, 1550, 1551, 5, 1111, 0, 0, 1551, 1556, 5, 1115, 0, 0, 1552,
		1553, 5, 1111, 0, 0, 1553, 1554, 5, 1115, 0, 0, 1554, 1556, 5, 1115, 0,
		0, 1555, 1550, 1, 0, 0, 0, 1555, 1552, 1, 0, 0, 0, 1556, 131, 1, 0, 0,
		0, 1557, 1558, 7, 49, 0, 0, 1558, 133, 1, 0, 0, 0, 1559, 1560, 7, 50, 0,
		0, 1560, 135, 1, 0, 0, 0, 1561, 1562, 7, 51, 0, 0, 1562, 137, 1, 0, 0,
		0, 1563, 1564, 7, 52, 0, 0, 1564, 139, 1, 0, 0, 0, 1565, 1566, 7, 53, 0,
		0, 1566, 141, 1, 0, 0, 0, 1567, 1568, 7, 54, 0, 0, 1568, 143, 1, 0, 0,
		0, 1569, 1570, 7, 55, 0, 0, 1570, 145, 1, 0, 0, 0, 234, 148, 155, 158,
		162, 168, 173, 176, 179, 186, 201, 208, 220, 225, 234, 236, 244, 254, 260,
		272, 275, 280, 293, 300, 307, 309, 316, 320, 322, 327, 330, 336, 341, 343,
		347, 350, 353, 359, 364, 366, 371, 378, 380, 387, 392, 396, 399, 407, 415,
		417, 425, 429, 432, 438, 443, 446, 452, 455, 459, 462, 466, 471, 476, 481,
		485, 489, 493, 497, 501, 505, 510, 515, 520, 526, 531, 536, 542, 547, 552,
		557, 562, 567, 572, 577, 584, 589, 594, 599, 605, 613, 619, 631, 638, 640,
		648, 653, 656, 664, 670, 686, 698, 700, 703, 711, 717, 723, 736, 743, 752,
		757, 768, 777, 782, 794, 801, 810, 815, 827, 834, 843, 848, 855, 864, 869,
		871, 876, 884, 893, 897, 900, 904, 909, 915, 921, 926, 931, 936, 941, 944,
		950, 957, 959, 964, 966, 970, 976, 979, 982, 990, 994, 1001, 1012, 1017,
		1023, 1026, 1030, 1035, 1038, 1042, 1046, 1048, 1053, 1058, 1071, 1074,
		1078, 1083, 1088, 1093, 1098, 1101, 1106, 1111, 1116, 1121, 1126, 1129,
		1132, 1137, 1142, 1147, 1150, 1155, 1158, 1164, 1167, 1171, 1174, 1179,
		1183, 1188, 1193, 1198, 1202, 1208, 1211, 1219, 1226, 1230, 1235, 1240,
		1244, 1246, 1249, 1265, 1274, 1282, 1291, 1305, 1312, 1331, 1336, 1339,
		1344, 1347, 1376, 1384, 1389, 1397, 1403, 1413, 1426, 1435, 1441, 1450,
		1452, 1470, 1482, 1490, 1507, 1509, 1528, 1537, 1546, 1555,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// StmtParserInit initializes any static state used to implement StmtParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewStmtParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func StmtParserInit() {
	staticData := &stmtparserParserStaticData
	staticData.once.Do(stmtparserParserInit)
}

// NewStmtParser produces a new parser instance for the optional input antlr.TokenStream.
func NewStmtParser(input antlr.TokenStream) *StmtParser {
	StmtParserInit()
	this := new(StmtParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &stmtparserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "java-escape"

	return this
}

// StmtParser tokens.
const (
	StmtParserEOF                               = antlr.TokenEOF
	StmtParserSPACE                             = 1
	StmtParserSPEC_MYSQL_COMMENT                = 2
	StmtParserCOMMENT_INPUT                     = 3
	StmtParserLINE_COMMENT                      = 4
	StmtParserADD                               = 5
	StmtParserALL                               = 6
	StmtParserALTER                             = 7
	StmtParserALWAYS                            = 8
	StmtParserANALYZE                           = 9
	StmtParserAND                               = 10
	StmtParserARRAY                             = 11
	StmtParserAS                                = 12
	StmtParserASC                               = 13
	StmtParserBEFORE                            = 14
	StmtParserBETWEEN                           = 15
	StmtParserBOTH                              = 16
	StmtParserBUCKETS                           = 17
	StmtParserBY                                = 18
	StmtParserCALL                              = 19
	StmtParserCASCADE                           = 20
	StmtParserCASE                              = 21
	StmtParserCAST                              = 22
	StmtParserCHANGE                            = 23
	StmtParserCHARACTER                         = 24
	StmtParserCHECK                             = 25
	StmtParserCOLLATE                           = 26
	StmtParserCOLUMN                            = 27
	StmtParserCONDITION                         = 28
	StmtParserCONSTRAINT                        = 29
	StmtParserCONTINUE                          = 30
	StmtParserCONVERT                           = 31
	StmtParserCREATE                            = 32
	StmtParserCROSS                             = 33
	StmtParserCURRENT                           = 34
	StmtParserCURRENT_USER                      = 35
	StmtParserCURSOR                            = 36
	StmtParserDATABASE                          = 37
	StmtParserDATABASES                         = 38
	StmtParserDECLARE                           = 39
	StmtParserDEFAULT                           = 40
	StmtParserDELAYED                           = 41
	StmtParserDELETE                            = 42
	StmtParserDESC                              = 43
	StmtParserDESCRIBE                          = 44
	StmtParserDETERMINISTIC                     = 45
	StmtParserDIAGNOSTICS                       = 46
	StmtParserDISTINCT                          = 47
	StmtParserDISTINCTROW                       = 48
	StmtParserDROP                              = 49
	StmtParserEACH                              = 50
	StmtParserELSE                              = 51
	StmtParserELSEIF                            = 52
	StmtParserEMPTY                             = 53
	StmtParserENCLOSED                          = 54
	StmtParserESCAPED                           = 55
	StmtParserEXCEPT                            = 56
	StmtParserEXISTS                            = 57
	StmtParserEXIT                              = 58
	StmtParserEXPLAIN                           = 59
	StmtParserFALSE                             = 60
	StmtParserFETCH                             = 61
	StmtParserFOR                               = 62
	StmtParserFORCE                             = 63
	StmtParserFOREIGN                           = 64
	StmtParserFROM                              = 65
	StmtParserFULLTEXT                          = 66
	StmtParserGENERATED                         = 67
	StmtParserGET                               = 68
	StmtParserGRANT                             = 69
	StmtParserGROUP                             = 70
	StmtParserHAVING                            = 71
	StmtParserHIGH_PRIORITY                     = 72
	StmtParserHISTOGRAM                         = 73
	StmtParserIF                                = 74
	StmtParserIGNORE                            = 75
	StmtParserIGNORED                           = 76
	StmtParserIN                                = 77
	StmtParserINDEX                             = 78
	StmtParserINFILE                            = 79
	StmtParserINNER                             = 80
	StmtParserINOUT                             = 81
	StmtParserINSERT                            = 82
	StmtParserINTERVAL                          = 83
	StmtParserINTO                              = 84
	StmtParserIS                                = 85
	StmtParserITERATE                           = 86
	StmtParserJOIN                              = 87
	StmtParserKEY                               = 88
	StmtParserKEYS                              = 89
	StmtParserKILL                              = 90
	StmtParserLEADING                           = 91
	StmtParserLEAVE                             = 92
	StmtParserLEFT                              = 93
	StmtParserLIKE                              = 94
	StmtParserLIMIT                             = 95
	StmtParserLINEAR                            = 96
	StmtParserLINES                             = 97
	StmtParserLOAD                              = 98
	StmtParserLOCK                              = 99
	StmtParserLOCKED                            = 100
	StmtParserLOOP                              = 101
	StmtParserLOW_PRIORITY                      = 102
	StmtParserMASTER_BIND                       = 103
	StmtParserMASTER_SSL_VERIFY_SERVER_CERT     = 104
	StmtParserMATCH                             = 105
	StmtParserMAXVALUE                          = 106
	StmtParserMINVALUE                          = 107
	StmtParserMODIFIES                          = 108
	StmtParserNATURAL                           = 109
	StmtParserNOT                               = 110
	StmtParserNO_WRITE_TO_BINLOG                = 111
	StmtParserNULL_LITERAL                      = 112
	StmtParserNUMBER                            = 113
	StmtParserON                                = 114
	StmtParserOPTIMIZE                          = 115
	StmtParserOPTION                            = 116
	StmtParserOPTIONAL                          = 117
	StmtParserOPTIONALLY                        = 118
	StmtParserOR                                = 119
	StmtParserORDER                             = 120
	StmtParserOUT                               = 121
	StmtParserOVER                              = 122
	StmtParserOUTER                             = 123
	StmtParserOUTFILE                           = 124
	StmtParserPARTITION                         = 125
	StmtParserPRIMARY                           = 126
	StmtParserPROCEDURE                         = 127
	StmtParserPURGE                             = 128
	StmtParserRANGE                             = 129
	StmtParserREAD                              = 130
	StmtParserREADS                             = 131
	StmtParserREFERENCES                        = 132
	StmtParserREGEXP                            = 133
	StmtParserRELEASE                           = 134
	StmtParserRENAME                            = 135
	StmtParserREPEAT                            = 136
	StmtParserREPLACE                           = 137
	StmtParserREQUIRE                           = 138
	StmtParserRESIGNAL                          = 139
	StmtParserRESTRICT                          = 140
	StmtParserRETAIN                            = 141
	StmtParserRETURN                            = 142
	StmtParserREVOKE                            = 143
	StmtParserRIGHT                             = 144
	StmtParserRLIKE                             = 145
	StmtParserSCHEMA                            = 146
	StmtParserSCHEMAS                           = 147
	StmtParserSELECT                            = 148
	StmtParserSET                               = 149
	StmtParserSEPARATOR                         = 150
	StmtParserSHOW                              = 151
	StmtParserSIGNAL                            = 152
	StmtParserSKIP_                             = 153
	StmtParserSPATIAL                           = 154
	StmtParserSQL                               = 155
	StmtParserSQLEXCEPTION                      = 156
	StmtParserSQLSTATE                          = 157
	StmtParserSQLWARNING                        = 158
	StmtParserSQL_BIG_RESULT                    = 159
	StmtParserSQL_CALC_FOUND_ROWS               = 160
	StmtParserSQL_SMALL_RESULT                  = 161
	StmtParserSSL                               = 162
	StmtParserSTACKED                           = 163
	StmtParserSTARTING                          = 164
	StmtParserSTRAIGHT_JOIN                     = 165
	StmtParserTABLE                             = 166
	StmtParserTERMINATED                        = 167
	StmtParserTHEN                              = 168
	StmtParserTO                                = 169
	StmtParserTRAILING                          = 170
	StmtParserTRIGGER                           = 171
	StmtParserTRUE                              = 172
	StmtParserUNDO                              = 173
	StmtParserUNION                             = 174
	StmtParserUNIQUE                            = 175
	StmtParserUNLOCK                            = 176
	StmtParserUNSIGNED                          = 177
	StmtParserUPDATE                            = 178
	StmtParserUSAGE                             = 179
	StmtParserUSE                               = 180
	StmtParserUSING                             = 181
	StmtParserVALUES                            = 182
	StmtParserWHEN                              = 183
	StmtParserWHERE                             = 184
	StmtParserWHILE                             = 185
	StmtParserWITH                              = 186
	StmtParserWRITE                             = 187
	StmtParserXOR                               = 188
	StmtParserZEROFILL                          = 189
	StmtParserTINYINT                           = 190
	StmtParserSMALLINT                          = 191
	StmtParserMEDIUMINT                         = 192
	StmtParserMIDDLEINT                         = 193
	StmtParserINT                               = 194
	StmtParserINT1                              = 195
	StmtParserINT2                              = 196
	StmtParserINT3                              = 197
	StmtParserINT4                              = 198
	StmtParserINT8                              = 199
	StmtParserINTEGER                           = 200
	StmtParserBIGINT                            = 201
	StmtParserREAL                              = 202
	StmtParserDOUBLE                            = 203
	StmtParserPRECISION                         = 204
	StmtParserFLOAT                             = 205
	StmtParserFLOAT4                            = 206
	StmtParserFLOAT8                            = 207
	StmtParserDECIMAL                           = 208
	StmtParserDEC                               = 209
	StmtParserNUMERIC                           = 210
	StmtParserDATE                              = 211
	StmtParserTIME                              = 212
	StmtParserTIMESTAMP                         = 213
	StmtParserDATETIME                          = 214
	StmtParserYEAR                              = 215
	StmtParserCHAR                              = 216
	StmtParserVARCHAR                           = 217
	StmtParserNVARCHAR                          = 218
	StmtParserNATIONAL                          = 219
	StmtParserBINARY                            = 220
	StmtParserVARBINARY                         = 221
	StmtParserTINYBLOB                          = 222
	StmtParserBLOB                              = 223
	StmtParserMEDIUMBLOB                        = 224
	StmtParserLONG                              = 225
	StmtParserLONGBLOB                          = 226
	StmtParserTINYTEXT                          = 227
	StmtParserTEXT                              = 228
	StmtParserMEDIUMTEXT                        = 229
	StmtParserLONGTEXT                          = 230
	StmtParserENUM                              = 231
	StmtParserVARYING                           = 232
	StmtParserSERIAL                            = 233
	StmtParserYEAR_MONTH                        = 234
	StmtParserDAY_HOUR                          = 235
	StmtParserDAY_MINUTE                        = 236
	StmtParserDAY_SECOND                        = 237
	StmtParserHOUR_MINUTE                       = 238
	StmtParserHOUR_SECOND                       = 239
	StmtParserMINUTE_SECOND                     = 240
	StmtParserSECOND_MICROSECOND                = 241
	StmtParserMINUTE_MICROSECOND                = 242
	StmtParserHOUR_MICROSECOND                  = 243
	StmtParserDAY_MICROSECOND                   = 244
	StmtParserJSON_ARRAY                        = 245
	StmtParserJSON_OBJECT                       = 246
	StmtParserJSON_QUOTE                        = 247
	StmtParserJSON_CONTAINS                     = 248
	StmtParserJSON_CONTAINS_PATH                = 249
	StmtParserJSON_EXTRACT                      = 250
	StmtParserJSON_KEYS                         = 251
	StmtParserJSON_OVERLAPS                     = 252
	StmtParserJSON_SEARCH                       = 253
	StmtParserJSON_VALUE                        = 254
	StmtParserJSON_ARRAY_APPEND                 = 255
	StmtParserJSON_ARRAY_INSERT                 = 256
	StmtParserJSON_INSERT                       = 257
	StmtParserJSON_MERGE                        = 258
	StmtParserJSON_MERGE_PATCH                  = 259
	StmtParserJSON_MERGE_PRESERVE               = 260
	StmtParserJSON_REMOVE                       = 261
	StmtParserJSON_REPLACE                      = 262
	StmtParserJSON_SET                          = 263
	StmtParserJSON_UNQUOTE                      = 264
	StmtParserJSON_DEPTH                        = 265
	StmtParserJSON_LENGTH                       = 266
	StmtParserJSON_TYPE                         = 267
	StmtParserJSON_VALID                        = 268
	StmtParserJSON_TABLE                        = 269
	StmtParserJSON_SCHEMA_VALID                 = 270
	StmtParserJSON_SCHEMA_VALIDATION_REPORT     = 271
	StmtParserJSON_PRETTY                       = 272
	StmtParserJSON_STORAGE_FREE                 = 273
	StmtParserJSON_STORAGE_SIZE                 = 274
	StmtParserJSON_ARRAYAGG                     = 275
	StmtParserJSON_OBJECTAGG                    = 276
	StmtParserAVG                               = 277
	StmtParserBIT_AND                           = 278
	StmtParserBIT_OR                            = 279
	StmtParserBIT_XOR                           = 280
	StmtParserCOUNT                             = 281
	StmtParserCUME_DIST                         = 282
	StmtParserDENSE_RANK                        = 283
	StmtParserFIRST_VALUE                       = 284
	StmtParserGROUP_CONCAT                      = 285
	StmtParserLAG                               = 286
	StmtParserLAST_VALUE                        = 287
	StmtParserLEAD                              = 288
	StmtParserMAX                               = 289
	StmtParserMIN                               = 290
	StmtParserNTILE                             = 291
	StmtParserNTH_VALUE                         = 292
	StmtParserPERCENT_RANK                      = 293
	StmtParserRANK                              = 294
	StmtParserROW_NUMBER                        = 295
	StmtParserSTD                               = 296
	StmtParserSTDDEV                            = 297
	StmtParserSTDDEV_POP                        = 298
	StmtParserSTDDEV_SAMP                       = 299
	StmtParserSUM                               = 300
	StmtParserVAR_POP                           = 301
	StmtParserVAR_SAMP                          = 302
	StmtParserVARIANCE                          = 303
	StmtParserCURRENT_DATE                      = 304
	StmtParserCURRENT_TIME                      = 305
	StmtParserCURRENT_TIMESTAMP                 = 306
	StmtParserLOCALTIME                         = 307
	StmtParserCURDATE                           = 308
	StmtParserCURTIME                           = 309
	StmtParserDATE_ADD                          = 310
	StmtParserDATE_SUB                          = 311
	StmtParserEXTRACT                           = 312
	StmtParserLOCALTIMESTAMP                    = 313
	StmtParserNOW                               = 314
	StmtParserPOSITION                          = 315
	StmtParserSUBSTR                            = 316
	StmtParserSUBSTRING                         = 317
	StmtParserSYSDATE                           = 318
	StmtParserTRIM                              = 319
	StmtParserUTC_DATE                          = 320
	StmtParserUTC_TIME                          = 321
	StmtParserUTC_TIMESTAMP                     = 322
	StmtParserACCOUNT                           = 323
	StmtParserACTION                            = 324
	StmtParserAFTER                             = 325
	StmtParserAGGREGATE                         = 326
	StmtParserALGORITHM                         = 327
	StmtParserANY                               = 328
	StmtParserAT                                = 329
	StmtParserAUTHORS                           = 330
	StmtParserAUTOCOMMIT                        = 331
	StmtParserAUTOEXTEND_SIZE                   = 332
	StmtParserAUTO_INCREMENT                    = 333
	StmtParserAVG_ROW_LENGTH                    = 334
	StmtParserBEGIN                             = 335
	StmtParserBINLOG                            = 336
	StmtParserBIT                               = 337
	StmtParserBLOCK                             = 338
	StmtParserBOOL                              = 339
	StmtParserBOOLEAN                           = 340
	StmtParserBTREE                             = 341
	StmtParserCACHE                             = 342
	StmtParserCASCADED                          = 343
	StmtParserCHAIN                             = 344
	StmtParserCHANGED                           = 345
	StmtParserCHANNEL                           = 346
	StmtParserCHECKSUM                          = 347
	StmtParserPAGE_CHECKSUM                     = 348
	StmtParserCIPHER                            = 349
	StmtParserCLASS_ORIGIN                      = 350
	StmtParserCLIENT                            = 351
	StmtParserCLOSE                             = 352
	StmtParserCLUSTERING                        = 353
	StmtParserCOALESCE                          = 354
	StmtParserCODE                              = 355
	StmtParserCOLUMNS                           = 356
	StmtParserCOLUMN_FORMAT                     = 357
	StmtParserCOLUMN_NAME                       = 358
	StmtParserCOMMENT                           = 359
	StmtParserCOMMIT                            = 360
	StmtParserCOMPACT                           = 361
	StmtParserCOMPLETION                        = 362
	StmtParserCOMPRESSED                        = 363
	StmtParserCOMPRESSION                       = 364
	StmtParserCONCURRENT                        = 365
	StmtParserCONNECT                           = 366
	StmtParserCONNECTION                        = 367
	StmtParserCONSISTENT                        = 368
	StmtParserCONSTRAINT_CATALOG                = 369
	StmtParserCONSTRAINT_SCHEMA                 = 370
	StmtParserCONSTRAINT_NAME                   = 371
	StmtParserCONTAINS                          = 372
	StmtParserCONTEXT                           = 373
	StmtParserCONTRIBUTORS                      = 374
	StmtParserCOPY                              = 375
	StmtParserCPU                               = 376
	StmtParserCYCLE                             = 377
	StmtParserCURSOR_NAME                       = 378
	StmtParserDATA                              = 379
	StmtParserDATAFILE                          = 380
	StmtParserDEALLOCATE                        = 381
	StmtParserDEFAULT_AUTH                      = 382
	StmtParserDEFINER                           = 383
	StmtParserDELAY_KEY_WRITE                   = 384
	StmtParserDES_KEY_FILE                      = 385
	StmtParserDIRECTORY                         = 386
	StmtParserDISABLE                           = 387
	StmtParserDISCARD                           = 388
	StmtParserDISK                              = 389
	StmtParserDO                                = 390
	StmtParserDUMPFILE                          = 391
	StmtParserDUPLICATE                         = 392
	StmtParserDYNAMIC                           = 393
	StmtParserENABLE                            = 394
	StmtParserENCRYPTION                        = 395
	StmtParserEND                               = 396
	StmtParserENDS                              = 397
	StmtParserENGINE                            = 398
	StmtParserENGINES                           = 399
	StmtParserERROR                             = 400
	StmtParserERRORS                            = 401
	StmtParserESCAPE                            = 402
	StmtParserEVEN                              = 403
	StmtParserEVENT                             = 404
	StmtParserEVENTS                            = 405
	StmtParserEVERY                             = 406
	StmtParserEXCHANGE                          = 407
	StmtParserEXCLUSIVE                         = 408
	StmtParserEXPIRE                            = 409
	StmtParserEXPORT                            = 410
	StmtParserEXTENDED                          = 411
	StmtParserEXTENT_SIZE                       = 412
	StmtParserFAST                              = 413
	StmtParserFAULTS                            = 414
	StmtParserFIELDS                            = 415
	StmtParserFILE_BLOCK_SIZE                   = 416
	StmtParserFILTER                            = 417
	StmtParserFIRST                             = 418
	StmtParserFIXED                             = 419
	StmtParserFLUSH                             = 420
	StmtParserFOLLOWING                         = 421
	StmtParserFOLLOWS                           = 422
	StmtParserFOUND                             = 423
	StmtParserFULL                              = 424
	StmtParserFUNCTION                          = 425
	StmtParserGENERAL                           = 426
	StmtParserGLOBAL                            = 427
	StmtParserGRANTS                            = 428
	StmtParserGROUP_REPLICATION                 = 429
	StmtParserHANDLER                           = 430
	StmtParserHASH                              = 431
	StmtParserHELP                              = 432
	StmtParserHOST                              = 433
	StmtParserHOSTS                             = 434
	StmtParserIDENTIFIED                        = 435
	StmtParserIGNORE_SERVER_IDS                 = 436
	StmtParserIMPORT                            = 437
	StmtParserINCREMENT                         = 438
	StmtParserINDEXES                           = 439
	StmtParserINITIAL_SIZE                      = 440
	StmtParserINPLACE                           = 441
	StmtParserINSERT_METHOD                     = 442
	StmtParserINSTALL                           = 443
	StmtParserINSTANCE                          = 444
	StmtParserINSTANT                           = 445
	StmtParserINVISIBLE                         = 446
	StmtParserINVOKER                           = 447
	StmtParserIO                                = 448
	StmtParserIO_THREAD                         = 449
	StmtParserIPC                               = 450
	StmtParserISOLATION                         = 451
	StmtParserISSUER                            = 452
	StmtParserJSON                              = 453
	StmtParserKEY_BLOCK_SIZE                    = 454
	StmtParserLANGUAGE                          = 455
	StmtParserLAST                              = 456
	StmtParserLEAVES                            = 457
	StmtParserLESS                              = 458
	StmtParserLEVEL                             = 459
	StmtParserLIST                              = 460
	StmtParserLOCAL                             = 461
	StmtParserLOGFILE                           = 462
	StmtParserLOGS                              = 463
	StmtParserMASTER                            = 464
	StmtParserMASTER_AUTO_POSITION              = 465
	StmtParserMASTER_CONNECT_RETRY              = 466
	StmtParserMASTER_DELAY                      = 467
	StmtParserMASTER_HEARTBEAT_PERIOD           = 468
	StmtParserMASTER_HOST                       = 469
	StmtParserMASTER_LOG_FILE                   = 470
	StmtParserMASTER_LOG_POS                    = 471
	StmtParserMASTER_PASSWORD                   = 472
	StmtParserMASTER_PORT                       = 473
	StmtParserMASTER_RETRY_COUNT                = 474
	StmtParserMASTER_SSL                        = 475
	StmtParserMASTER_SSL_CA                     = 476
	StmtParserMASTER_SSL_CAPATH                 = 477
	StmtParserMASTER_SSL_CERT                   = 478
	StmtParserMASTER_SSL_CIPHER                 = 479
	StmtParserMASTER_SSL_CRL                    = 480
	StmtParserMASTER_SSL_CRLPATH                = 481
	StmtParserMASTER_SSL_KEY                    = 482
	StmtParserMASTER_TLS_VERSION                = 483
	StmtParserMASTER_USER                       = 484
	StmtParserMAX_CONNECTIONS_PER_HOUR          = 485
	StmtParserMAX_QUERIES_PER_HOUR              = 486
	StmtParserMAX_ROWS                          = 487
	StmtParserMAX_SIZE                          = 488
	StmtParserMAX_UPDATES_PER_HOUR              = 489
	StmtParserMAX_USER_CONNECTIONS              = 490
	StmtParserMEDIUM                            = 491
	StmtParserMEMBER                            = 492
	StmtParserMERGE                             = 493
	StmtParserMESSAGE_TEXT                      = 494
	StmtParserMID                               = 495
	StmtParserMIGRATE                           = 496
	StmtParserMIN_ROWS                          = 497
	StmtParserMODE                              = 498
	StmtParserMODIFY                            = 499
	StmtParserMUTEX                             = 500
	StmtParserMYSQL                             = 501
	StmtParserMYSQL_ERRNO                       = 502
	StmtParserNAME                              = 503
	StmtParserNAMES                             = 504
	StmtParserNCHAR                             = 505
	StmtParserNEVER                             = 506
	StmtParserNEXT                              = 507
	StmtParserNO                                = 508
	StmtParserNOCACHE                           = 509
	StmtParserNOCOPY                            = 510
	StmtParserNOCYCLE                           = 511
	StmtParserNOMAXVALUE                        = 512
	StmtParserNOMINVALUE                        = 513
	StmtParserNOWAIT                            = 514
	StmtParserNODEGROUP                         = 515
	StmtParserNONE                              = 516
	StmtParserODBC                              = 517
	StmtParserOFFLINE                           = 518
	StmtParserOFFSET                            = 519
	StmtParserOF                                = 520
	StmtParserOJ                                = 521
	StmtParserOLD_PASSWORD                      = 522
	StmtParserONE                               = 523
	StmtParserONLINE                            = 524
	StmtParserONLY                              = 525
	StmtParserOPEN                              = 526
	StmtParserOPTIMIZER_COSTS                   = 527
	StmtParserOPTIONS                           = 528
	StmtParserOWNER                             = 529
	StmtParserPACK_KEYS                         = 530
	StmtParserPAGE                              = 531
	StmtParserPARSER                            = 532
	StmtParserPARTIAL                           = 533
	StmtParserPARTITIONING                      = 534
	StmtParserPARTITIONS                        = 535
	StmtParserPASSWORD                          = 536
	StmtParserPHASE                             = 537
	StmtParserPLUGIN                            = 538
	StmtParserPLUGIN_DIR                        = 539
	StmtParserPLUGINS                           = 540
	StmtParserPORT                              = 541
	StmtParserPRECEDES                          = 542
	StmtParserPRECEDING                         = 543
	StmtParserPREPARE                           = 544
	StmtParserPRESERVE                          = 545
	StmtParserPREV                              = 546
	StmtParserPROCESSLIST                       = 547
	StmtParserPROFILE                           = 548
	StmtParserPROFILES                          = 549
	StmtParserPROXY                             = 550
	StmtParserQUERY                             = 551
	StmtParserQUICK                             = 552
	StmtParserREBUILD                           = 553
	StmtParserRECOVER                           = 554
	StmtParserRECURSIVE                         = 555
	StmtParserREDO_BUFFER_SIZE                  = 556
	StmtParserREDUNDANT                         = 557
	StmtParserRELAY                             = 558
	StmtParserRELAY_LOG_FILE                    = 559
	StmtParserRELAY_LOG_POS                     = 560
	StmtParserRELAYLOG                          = 561
	StmtParserREMOVE                            = 562
	StmtParserREORGANIZE                        = 563
	StmtParserREPAIR                            = 564
	StmtParserREPLICATE_DO_DB                   = 565
	StmtParserREPLICATE_DO_TABLE                = 566
	StmtParserREPLICATE_IGNORE_DB               = 567
	StmtParserREPLICATE_IGNORE_TABLE            = 568
	StmtParserREPLICATE_REWRITE_DB              = 569
	StmtParserREPLICATE_WILD_DO_TABLE           = 570
	StmtParserREPLICATE_WILD_IGNORE_TABLE       = 571
	StmtParserREPLICATION                       = 572
	StmtParserRESET                             = 573
	StmtParserRESTART                           = 574
	StmtParserRESUME                            = 575
	StmtParserRETURNED_SQLSTATE                 = 576
	StmtParserRETURNING                         = 577
	StmtParserRETURNS                           = 578
	StmtParserROLE                              = 579
	StmtParserROLLBACK                          = 580
	StmtParserROLLUP                            = 581
	StmtParserROTATE                            = 582
	StmtParserROW                               = 583
	StmtParserROWS                              = 584
	StmtParserROW_FORMAT                        = 585
	StmtParserRTREE                             = 586
	StmtParserSAVEPOINT                         = 587
	StmtParserSCHEDULE                          = 588
	StmtParserSECURITY                          = 589
	StmtParserSEQUENCE                          = 590
	StmtParserSERVER                            = 591
	StmtParserSESSION                           = 592
	StmtParserSHARE                             = 593
	StmtParserSHARED                            = 594
	StmtParserSIGNED                            = 595
	StmtParserSIMPLE                            = 596
	StmtParserSLAVE                             = 597
	StmtParserSLOW                              = 598
	StmtParserSNAPSHOT                          = 599
	StmtParserSOCKET                            = 600
	StmtParserSOME                              = 601
	StmtParserSONAME                            = 602
	StmtParserSOUNDS                            = 603
	StmtParserSOURCE                            = 604
	StmtParserSQL_AFTER_GTIDS                   = 605
	StmtParserSQL_AFTER_MTS_GAPS                = 606
	StmtParserSQL_BEFORE_GTIDS                  = 607
	StmtParserSQL_BUFFER_RESULT                 = 608
	StmtParserSQL_CACHE                         = 609
	StmtParserSQL_NO_CACHE                      = 610
	StmtParserSQL_THREAD                        = 611
	StmtParserSTART                             = 612
	StmtParserSTARTS                            = 613
	StmtParserSTATS_AUTO_RECALC                 = 614
	StmtParserSTATS_PERSISTENT                  = 615
	StmtParserSTATS_SAMPLE_PAGES                = 616
	StmtParserSTATUS                            = 617
	StmtParserSTOP                              = 618
	StmtParserSTORAGE                           = 619
	StmtParserSTORED                            = 620
	StmtParserSTRING                            = 621
	StmtParserSUBCLASS_ORIGIN                   = 622
	StmtParserSUBJECT                           = 623
	StmtParserSUBPARTITION                      = 624
	StmtParserSUBPARTITIONS                     = 625
	StmtParserSUSPEND                           = 626
	StmtParserSWAPS                             = 627
	StmtParserSWITCHES                          = 628
	StmtParserTABLE_NAME                        = 629
	StmtParserTABLESPACE                        = 630
	StmtParserTABLE_TYPE                        = 631
	StmtParserTEMPORARY                         = 632
	StmtParserTEMPTABLE                         = 633
	StmtParserTHAN                              = 634
	StmtParserTRADITIONAL                       = 635
	StmtParserTRANSACTION                       = 636
	StmtParserTRANSACTIONAL                     = 637
	StmtParserTRIGGERS                          = 638
	StmtParserTRUNCATE                          = 639
	StmtParserUNBOUNDED                         = 640
	StmtParserUNDEFINED                         = 641
	StmtParserUNDOFILE                          = 642
	StmtParserUNDO_BUFFER_SIZE                  = 643
	StmtParserUNINSTALL                         = 644
	StmtParserUNKNOWN                           = 645
	StmtParserUNTIL                             = 646
	StmtParserUPGRADE                           = 647
	StmtParserUSER                              = 648
	StmtParserUSE_FRM                           = 649
	StmtParserUSER_RESOURCES                    = 650
	StmtParserVALIDATION                        = 651
	StmtParserVALUE                             = 652
	StmtParserVARIABLES                         = 653
	StmtParserVIEW                              = 654
	StmtParserVIRTUAL                           = 655
	StmtParserVISIBLE                           = 656
	StmtParserWAIT                              = 657
	StmtParserWARNINGS                          = 658
	StmtParserWINDOW                            = 659
	StmtParserWITHOUT                           = 660
	StmtParserWORK                              = 661
	StmtParserWRAPPER                           = 662
	StmtParserX509                              = 663
	StmtParserXA                                = 664
	StmtParserXML                               = 665
	StmtParserYES                               = 666
	StmtParserEUR                               = 667
	StmtParserUSA                               = 668
	StmtParserJIS                               = 669
	StmtParserISO                               = 670
	StmtParserINTERNAL                          = 671
	StmtParserQUARTER                           = 672
	StmtParserMONTH                             = 673
	StmtParserDAY                               = 674
	StmtParserHOUR                              = 675
	StmtParserMINUTE                            = 676
	StmtParserWEEK                              = 677
	StmtParserSECOND                            = 678
	StmtParserMICROSECOND                       = 679
	StmtParserTABLES                            = 680
	StmtParserROUTINE                           = 681
	StmtParserEXECUTE                           = 682
	StmtParserFILE                              = 683
	StmtParserPROCESS                           = 684
	StmtParserRELOAD                            = 685
	StmtParserSHUTDOWN                          = 686
	StmtParserSUPER                             = 687
	StmtParserPRIVILEGES                        = 688
	StmtParserAPPLICATION_PASSWORD_ADMIN        = 689
	StmtParserAUDIT_ADMIN                       = 690
	StmtParserBACKUP_ADMIN                      = 691
	StmtParserBINLOG_ADMIN                      = 692
	StmtParserBINLOG_ENCRYPTION_ADMIN           = 693
	StmtParserCLONE_ADMIN                       = 694
	StmtParserCONNECTION_ADMIN                  = 695
	StmtParserENCRYPTION_KEY_ADMIN              = 696
	StmtParserFIREWALL_ADMIN                    = 697
	StmtParserFIREWALL_USER                     = 698
	StmtParserFLUSH_OPTIMIZER_COSTS             = 699
	StmtParserFLUSH_STATUS                      = 700
	StmtParserFLUSH_TABLES                      = 701
	StmtParserFLUSH_USER_RESOURCES              = 702
	StmtParserADMIN                             = 703
	StmtParserGROUP_REPLICATION_ADMIN           = 704
	StmtParserINNODB_REDO_LOG_ARCHIVE           = 705
	StmtParserINNODB_REDO_LOG_ENABLE            = 706
	StmtParserINVOKE                            = 707
	StmtParserLAMBDA                            = 708
	StmtParserNDB_STORED_USER                   = 709
	StmtParserPASSWORDLESS_USER_ADMIN           = 710
	StmtParserPERSIST_RO_VARIABLES_ADMIN        = 711
	StmtParserREPLICATION_APPLIER               = 712
	StmtParserREPLICATION_SLAVE_ADMIN           = 713
	StmtParserRESOURCE_GROUP_ADMIN              = 714
	StmtParserRESOURCE_GROUP_USER               = 715
	StmtParserROLE_ADMIN                        = 716
	StmtParserS3                                = 717
	StmtParserSERVICE_CONNECTION_ADMIN          = 718
	StmtParserSESSION_VARIABLES_ADMIN           = 719
	StmtParserSET_USER_ID                       = 720
	StmtParserSHOW_ROUTINE                      = 721
	StmtParserSYSTEM_VARIABLES_ADMIN            = 722
	StmtParserTABLE_ENCRYPTION_ADMIN            = 723
	StmtParserVERSION_TOKEN_ADMIN               = 724
	StmtParserXA_RECOVER_ADMIN                  = 725
	StmtParserARMSCII8                          = 726
	StmtParserASCII                             = 727
	StmtParserBIG5                              = 728
	StmtParserCP1250                            = 729
	StmtParserCP1251                            = 730
	StmtParserCP1256                            = 731
	StmtParserCP1257                            = 732
	StmtParserCP850                             = 733
	StmtParserCP852                             = 734
	StmtParserCP866                             = 735
	StmtParserCP932                             = 736
	StmtParserDEC8                              = 737
	StmtParserEUCJPMS                           = 738
	StmtParserEUCKR                             = 739
	StmtParserGB18030                           = 740
	StmtParserGB2312                            = 741
	StmtParserGBK                               = 742
	StmtParserGEOSTD8                           = 743
	StmtParserGREEK                             = 744
	StmtParserHEBREW                            = 745
	StmtParserHP8                               = 746
	StmtParserKEYBCS2                           = 747
	StmtParserKOI8R                             = 748
	StmtParserKOI8U                             = 749
	StmtParserLATIN1                            = 750
	StmtParserLATIN2                            = 751
	StmtParserLATIN5                            = 752
	StmtParserLATIN7                            = 753
	StmtParserMACCE                             = 754
	StmtParserMACROMAN                          = 755
	StmtParserSJIS                              = 756
	StmtParserSWE7                              = 757
	StmtParserTIS620                            = 758
	StmtParserUCS2                              = 759
	StmtParserUJIS                              = 760
	StmtParserUTF16                             = 761
	StmtParserUTF16LE                           = 762
	StmtParserUTF32                             = 763
	StmtParserUTF8                              = 764
	StmtParserUTF8MB3                           = 765
	StmtParserUTF8MB4                           = 766
	StmtParserARCHIVE                           = 767
	StmtParserBLACKHOLE                         = 768
	StmtParserCSV                               = 769
	StmtParserFEDERATED                         = 770
	StmtParserINNODB                            = 771
	StmtParserMEMORY                            = 772
	StmtParserMRG_MYISAM                        = 773
	StmtParserMYISAM                            = 774
	StmtParserNDB                               = 775
	StmtParserNDBCLUSTER                        = 776
	StmtParserPERFORMANCE_SCHEMA                = 777
	StmtParserTOKUDB                            = 778
	StmtParserREPEATABLE                        = 779
	StmtParserCOMMITTED                         = 780
	StmtParserUNCOMMITTED                       = 781
	StmtParserSERIALIZABLE                      = 782
	StmtParserGEOMETRYCOLLECTION                = 783
	StmtParserGEOMCOLLECTION                    = 784
	StmtParserGEOMETRY                          = 785
	StmtParserLINESTRING                        = 786
	StmtParserMULTILINESTRING                   = 787
	StmtParserMULTIPOINT                        = 788
	StmtParserMULTIPOLYGON                      = 789
	StmtParserPOINT                             = 790
	StmtParserPOLYGON                           = 791
	StmtParserABS                               = 792
	StmtParserACOS                              = 793
	StmtParserADDDATE                           = 794
	StmtParserADDTIME                           = 795
	StmtParserAES_DECRYPT                       = 796
	StmtParserAES_ENCRYPT                       = 797
	StmtParserAREA                              = 798
	StmtParserASBINARY                          = 799
	StmtParserASIN                              = 800
	StmtParserASTEXT                            = 801
	StmtParserASWKB                             = 802
	StmtParserASWKT                             = 803
	StmtParserASYMMETRIC_DECRYPT                = 804
	StmtParserASYMMETRIC_DERIVE                 = 805
	StmtParserASYMMETRIC_ENCRYPT                = 806
	StmtParserASYMMETRIC_SIGN                   = 807
	StmtParserASYMMETRIC_VERIFY                 = 808
	StmtParserATAN                              = 809
	StmtParserATAN2                             = 810
	StmtParserBENCHMARK                         = 811
	StmtParserBIN                               = 812
	StmtParserBIT_COUNT                         = 813
	StmtParserBIT_LENGTH                        = 814
	StmtParserBUFFER                            = 815
	StmtParserCATALOG_NAME                      = 816
	StmtParserCEIL                              = 817
	StmtParserCEILING                           = 818
	StmtParserCENTROID                          = 819
	StmtParserCHARACTER_LENGTH                  = 820
	StmtParserCHARSET                           = 821
	StmtParserCHAR_LENGTH                       = 822
	StmtParserCOERCIBILITY                      = 823
	StmtParserCOLLATION                         = 824
	StmtParserCOMPRESS                          = 825
	StmtParserCONCAT                            = 826
	StmtParserCONCAT_WS                         = 827
	StmtParserCONNECTION_ID                     = 828
	StmtParserCONV                              = 829
	StmtParserCONVERT_TZ                        = 830
	StmtParserCOS                               = 831
	StmtParserCOT                               = 832
	StmtParserCRC32                             = 833
	StmtParserCREATE_ASYMMETRIC_PRIV_KEY        = 834
	StmtParserCREATE_ASYMMETRIC_PUB_KEY         = 835
	StmtParserCREATE_DH_PARAMETERS              = 836
	StmtParserCREATE_DIGEST                     = 837
	StmtParserCROSSES                           = 838
	StmtParserDATEDIFF                          = 839
	StmtParserDATE_FORMAT                       = 840
	StmtParserDAYNAME                           = 841
	StmtParserDAYOFMONTH                        = 842
	StmtParserDAYOFWEEK                         = 843
	StmtParserDAYOFYEAR                         = 844
	StmtParserDECODE                            = 845
	StmtParserDEGREES                           = 846
	StmtParserDES_DECRYPT                       = 847
	StmtParserDES_ENCRYPT                       = 848
	StmtParserDIMENSION                         = 849
	StmtParserDISJOINT                          = 850
	StmtParserELT                               = 851
	StmtParserENCODE                            = 852
	StmtParserENCRYPT                           = 853
	StmtParserENDPOINT                          = 854
	StmtParserENGINE_ATTRIBUTE                  = 855
	StmtParserENVELOPE                          = 856
	StmtParserEQUALS                            = 857
	StmtParserEXP                               = 858
	StmtParserEXPORT_SET                        = 859
	StmtParserEXTERIORRING                      = 860
	StmtParserEXTRACTVALUE                      = 861
	StmtParserFIELD                             = 862
	StmtParserFIND_IN_SET                       = 863
	StmtParserFLOOR                             = 864
	StmtParserFORMAT                            = 865
	StmtParserFOUND_ROWS                        = 866
	StmtParserFROM_BASE64                       = 867
	StmtParserFROM_DAYS                         = 868
	StmtParserFROM_UNIXTIME                     = 869
	StmtParserGEOMCOLLFROMTEXT                  = 870
	StmtParserGEOMCOLLFROMWKB                   = 871
	StmtParserGEOMETRYCOLLECTIONFROMTEXT        = 872
	StmtParserGEOMETRYCOLLECTIONFROMWKB         = 873
	StmtParserGEOMETRYFROMTEXT                  = 874
	StmtParserGEOMETRYFROMWKB                   = 875
	StmtParserGEOMETRYN                         = 876
	StmtParserGEOMETRYTYPE                      = 877
	StmtParserGEOMFROMTEXT                      = 878
	StmtParserGEOMFROMWKB                       = 879
	StmtParserGET_FORMAT                        = 880
	StmtParserGET_LOCK                          = 881
	StmtParserGLENGTH                           = 882
	StmtParserGREATEST                          = 883
	StmtParserGTID_SUBSET                       = 884
	StmtParserGTID_SUBTRACT                     = 885
	StmtParserHEX                               = 886
	StmtParserIFNULL                            = 887
	StmtParserINET6_ATON                        = 888
	StmtParserINET6_NTOA                        = 889
	StmtParserINET_ATON                         = 890
	StmtParserINET_NTOA                         = 891
	StmtParserINSTR                             = 892
	StmtParserINTERIORRINGN                     = 893
	StmtParserINTERSECTS                        = 894
	StmtParserISCLOSED                          = 895
	StmtParserISEMPTY                           = 896
	StmtParserISNULL                            = 897
	StmtParserISSIMPLE                          = 898
	StmtParserIS_FREE_LOCK                      = 899
	StmtParserIS_IPV4                           = 900
	StmtParserIS_IPV4_COMPAT                    = 901
	StmtParserIS_IPV4_MAPPED                    = 902
	StmtParserIS_IPV6                           = 903
	StmtParserIS_USED_LOCK                      = 904
	StmtParserLAST_INSERT_ID                    = 905
	StmtParserLCASE                             = 906
	StmtParserLEAST                             = 907
	StmtParserLENGTH                            = 908
	StmtParserLINEFROMTEXT                      = 909
	StmtParserLINEFROMWKB                       = 910
	StmtParserLINESTRINGFROMTEXT                = 911
	StmtParserLINESTRINGFROMWKB                 = 912
	StmtParserLN                                = 913
	StmtParserLOAD_FILE                         = 914
	StmtParserLOCATE                            = 915
	StmtParserLOG                               = 916
	StmtParserLOG10                             = 917
	StmtParserLOG2                              = 918
	StmtParserLOWER                             = 919
	StmtParserLPAD                              = 920
	StmtParserLTRIM                             = 921
	StmtParserMAKEDATE                          = 922
	StmtParserMAKETIME                          = 923
	StmtParserMAKE_SET                          = 924
	StmtParserMASTER_POS_WAIT                   = 925
	StmtParserMBRCONTAINS                       = 926
	StmtParserMBRDISJOINT                       = 927
	StmtParserMBREQUAL                          = 928
	StmtParserMBRINTERSECTS                     = 929
	StmtParserMBROVERLAPS                       = 930
	StmtParserMBRTOUCHES                        = 931
	StmtParserMBRWITHIN                         = 932
	StmtParserMD5                               = 933
	StmtParserMLINEFROMTEXT                     = 934
	StmtParserMLINEFROMWKB                      = 935
	StmtParserMONTHNAME                         = 936
	StmtParserMPOINTFROMTEXT                    = 937
	StmtParserMPOINTFROMWKB                     = 938
	StmtParserMPOLYFROMTEXT                     = 939
	StmtParserMPOLYFROMWKB                      = 940
	StmtParserMULTILINESTRINGFROMTEXT           = 941
	StmtParserMULTILINESTRINGFROMWKB            = 942
	StmtParserMULTIPOINTFROMTEXT                = 943
	StmtParserMULTIPOINTFROMWKB                 = 944
	StmtParserMULTIPOLYGONFROMTEXT              = 945
	StmtParserMULTIPOLYGONFROMWKB               = 946
	StmtParserNAME_CONST                        = 947
	StmtParserNULLIF                            = 948
	StmtParserNUMGEOMETRIES                     = 949
	StmtParserNUMINTERIORRINGS                  = 950
	StmtParserNUMPOINTS                         = 951
	StmtParserOCT                               = 952
	StmtParserOCTET_LENGTH                      = 953
	StmtParserORD                               = 954
	StmtParserOVERLAPS                          = 955
	StmtParserPERIOD_ADD                        = 956
	StmtParserPERIOD_DIFF                       = 957
	StmtParserPI                                = 958
	StmtParserPOINTFROMTEXT                     = 959
	StmtParserPOINTFROMWKB                      = 960
	StmtParserPOINTN                            = 961
	StmtParserPOLYFROMTEXT                      = 962
	StmtParserPOLYFROMWKB                       = 963
	StmtParserPOLYGONFROMTEXT                   = 964
	StmtParserPOLYGONFROMWKB                    = 965
	StmtParserPOW                               = 966
	StmtParserPOWER                             = 967
	StmtParserQUOTE                             = 968
	StmtParserRADIANS                           = 969
	StmtParserRAND                              = 970
	StmtParserRANDOM_BYTES                      = 971
	StmtParserRELEASE_LOCK                      = 972
	StmtParserREVERSE                           = 973
	StmtParserROUND                             = 974
	StmtParserROW_COUNT                         = 975
	StmtParserRPAD                              = 976
	StmtParserRTRIM                             = 977
	StmtParserSEC_TO_TIME                       = 978
	StmtParserSECONDARY_ENGINE_ATTRIBUTE        = 979
	StmtParserSESSION_USER                      = 980
	StmtParserSHA                               = 981
	StmtParserSHA1                              = 982
	StmtParserSHA2                              = 983
	StmtParserSCHEMA_NAME                       = 984
	StmtParserSIGN                              = 985
	StmtParserSIN                               = 986
	StmtParserSLEEP                             = 987
	StmtParserSOUNDEX                           = 988
	StmtParserSQL_THREAD_WAIT_AFTER_GTIDS       = 989
	StmtParserSQRT                              = 990
	StmtParserSRID                              = 991
	StmtParserSTARTPOINT                        = 992
	StmtParserSTRCMP                            = 993
	StmtParserSTR_TO_DATE                       = 994
	StmtParserST_AREA                           = 995
	StmtParserST_ASBINARY                       = 996
	StmtParserST_ASTEXT                         = 997
	StmtParserST_ASWKB                          = 998
	StmtParserST_ASWKT                          = 999
	StmtParserST_BUFFER                         = 1000
	StmtParserST_CENTROID                       = 1001
	StmtParserST_CONTAINS                       = 1002
	StmtParserST_CROSSES                        = 1003
	StmtParserST_DIFFERENCE                     = 1004
	StmtParserST_DIMENSION                      = 1005
	StmtParserST_DISJOINT                       = 1006
	StmtParserST_DISTANCE                       = 1007
	StmtParserST_ENDPOINT                       = 1008
	StmtParserST_ENVELOPE                       = 1009
	StmtParserST_EQUALS                         = 1010
	StmtParserST_EXTERIORRING                   = 1011
	StmtParserST_GEOMCOLLFROMTEXT               = 1012
	StmtParserST_GEOMCOLLFROMTXT                = 1013
	StmtParserST_GEOMCOLLFROMWKB                = 1014
	StmtParserST_GEOMETRYCOLLECTIONFROMTEXT     = 1015
	StmtParserST_GEOMETRYCOLLECTIONFROMWKB      = 1016
	StmtParserST_GEOMETRYFROMTEXT               = 1017
	StmtParserST_GEOMETRYFROMWKB                = 1018
	StmtParserST_GEOMETRYN                      = 1019
	StmtParserST_GEOMETRYTYPE                   = 1020
	StmtParserST_GEOMFROMTEXT                   = 1021
	StmtParserST_GEOMFROMWKB                    = 1022
	StmtParserST_INTERIORRINGN                  = 1023
	StmtParserST_INTERSECTION                   = 1024
	StmtParserST_INTERSECTS                     = 1025
	StmtParserST_ISCLOSED                       = 1026
	StmtParserST_ISEMPTY                        = 1027
	StmtParserST_ISSIMPLE                       = 1028
	StmtParserST_LINEFROMTEXT                   = 1029
	StmtParserST_LINEFROMWKB                    = 1030
	StmtParserST_LINESTRINGFROMTEXT             = 1031
	StmtParserST_LINESTRINGFROMWKB              = 1032
	StmtParserST_NUMGEOMETRIES                  = 1033
	StmtParserST_NUMINTERIORRING                = 1034
	StmtParserST_NUMINTERIORRINGS               = 1035
	StmtParserST_NUMPOINTS                      = 1036
	StmtParserST_OVERLAPS                       = 1037
	StmtParserST_POINTFROMTEXT                  = 1038
	StmtParserST_POINTFROMWKB                   = 1039
	StmtParserST_POINTN                         = 1040
	StmtParserST_POLYFROMTEXT                   = 1041
	StmtParserST_POLYFROMWKB                    = 1042
	StmtParserST_POLYGONFROMTEXT                = 1043
	StmtParserST_POLYGONFROMWKB                 = 1044
	StmtParserST_SRID                           = 1045
	StmtParserST_STARTPOINT                     = 1046
	StmtParserST_SYMDIFFERENCE                  = 1047
	StmtParserST_TOUCHES                        = 1048
	StmtParserST_UNION                          = 1049
	StmtParserST_WITHIN                         = 1050
	StmtParserST_X                              = 1051
	StmtParserST_Y                              = 1052
	StmtParserSUBDATE                           = 1053
	StmtParserSUBSTRING_INDEX                   = 1054
	StmtParserSUBTIME                           = 1055
	StmtParserSYSTEM_USER                       = 1056
	StmtParserTAN                               = 1057
	StmtParserTIMEDIFF                          = 1058
	StmtParserTIMESTAMPADD                      = 1059
	StmtParserTIMESTAMPDIFF                     = 1060
	StmtParserTIME_FORMAT                       = 1061
	StmtParserTIME_TO_SEC                       = 1062
	StmtParserTOUCHES                           = 1063
	StmtParserTO_BASE64                         = 1064
	StmtParserTO_DAYS                           = 1065
	StmtParserTO_SECONDS                        = 1066
	StmtParserUCASE                             = 1067
	StmtParserUNCOMPRESS                        = 1068
	StmtParserUNCOMPRESSED_LENGTH               = 1069
	StmtParserUNHEX                             = 1070
	StmtParserUNIX_TIMESTAMP                    = 1071
	StmtParserUPDATEXML                         = 1072
	StmtParserUPPER                             = 1073
	StmtParserUUID                              = 1074
	StmtParserUUID_SHORT                        = 1075
	StmtParserVALIDATE_PASSWORD_STRENGTH        = 1076
	StmtParserVERSION                           = 1077
	StmtParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS = 1078
	StmtParserWEEKDAY                           = 1079
	StmtParserWEEKOFYEAR                        = 1080
	StmtParserWEIGHT_STRING                     = 1081
	StmtParserWITHIN                            = 1082
	StmtParserYEARWEEK                          = 1083
	StmtParserY_FUNCTION                        = 1084
	StmtParserX_FUNCTION                        = 1085
	StmtParserVIA                               = 1086
	StmtParserLASTVAL                           = 1087
	StmtParserNEXTVAL                           = 1088
	StmtParserSETVAL                            = 1089
	StmtParserPREVIOUS                          = 1090
	StmtParserPERSISTENT                        = 1091
	StmtParserBINLOG_MONITOR                    = 1092
	StmtParserBINLOG_REPLAY                     = 1093
	StmtParserFEDERATED_ADMIN                   = 1094
	StmtParserREAD_ONLY_ADMIN                   = 1095
	StmtParserREPLICA                           = 1096
	StmtParserREPLICATION_MASTER_ADMIN          = 1097
	StmtParserVAR_ASSIGN                        = 1098
	StmtParserPLUS_ASSIGN                       = 1099
	StmtParserMINUS_ASSIGN                      = 1100
	StmtParserMULT_ASSIGN                       = 1101
	StmtParserDIV_ASSIGN                        = 1102
	StmtParserMOD_ASSIGN                        = 1103
	StmtParserAND_ASSIGN                        = 1104
	StmtParserXOR_ASSIGN                        = 1105
	StmtParserOR_ASSIGN                         = 1106
	StmtParserSTAR                              = 1107
	StmtParserDIVIDE                            = 1108
	StmtParserMODULE                            = 1109
	StmtParserPLUS                              = 1110
	StmtParserMINUS                             = 1111
	StmtParserDIV                               = 1112
	StmtParserMOD                               = 1113
	StmtParserEQUAL_SYMBOL                      = 1114
	StmtParserGREATER_SYMBOL                    = 1115
	StmtParserLESS_SYMBOL                       = 1116
	StmtParserEXCLAMATION_SYMBOL                = 1117
	StmtParserBIT_NOT_OP                        = 1118
	StmtParserBIT_OR_OP                         = 1119
	StmtParserBIT_AND_OP                        = 1120
	StmtParserBIT_XOR_OP                        = 1121
	StmtParserDOT                               = 1122
	StmtParserLR_BRACKET                        = 1123
	StmtParserRR_BRACKET                        = 1124
	StmtParserCOMMA                             = 1125
	StmtParserSEMI                              = 1126
	StmtParserAT_SIGN                           = 1127
	StmtParserZERO_DECIMAL                      = 1128
	StmtParserONE_DECIMAL                       = 1129
	StmtParserTWO_DECIMAL                       = 1130
	StmtParserSINGLE_QUOTE_SYMB                 = 1131
	StmtParserDOUBLE_QUOTE_SYMB                 = 1132
	StmtParserREVERSE_QUOTE_SYMB                = 1133
	StmtParserCOLON_SYMB                        = 1134
	StmtParserCHARSET_REVERSE_QOUTE_STRING      = 1135
	StmtParserFILESIZE_LITERAL                  = 1136
	StmtParserSTART_NATIONAL_STRING_LITERAL     = 1137
	StmtParserSTRING_LITERAL                    = 1138
	StmtParserDECIMAL_LITERAL                   = 1139
	StmtParserHEXADECIMAL_LITERAL               = 1140
	StmtParserREAL_LITERAL                      = 1141
	StmtParserNULL_SPEC_LITERAL                 = 1142
	StmtParserBIT_STRING                        = 1143
	StmtParserSTRING_CHARSET_NAME               = 1144
	StmtParserDOT_ID                            = 1145
	StmtParserID                                = 1146
	StmtParserREVERSE_QUOTE_ID                  = 1147
	StmtParserSTRING_USER_NAME                  = 1148
	StmtParserIP_ADDRESS                        = 1149
	StmtParserSTRING_USER_NAME_MARIADB          = 1150
	StmtParserLOCAL_ID                          = 1151
	StmtParserGLOBAL_ID                         = 1152
	StmtParserERROR_RECONGNIGION                = 1153
)

// StmtParser rules.
const (
	StmtParserRULE_prog                           = 0
	StmtParserRULE_sqlStatement                   = 1
	StmtParserRULE_charSet                        = 2
	StmtParserRULE_intervalType                   = 3
	StmtParserRULE_indexType                      = 4
	StmtParserRULE_indexOption                    = 5
	StmtParserRULE_createDefinitions              = 6
	StmtParserRULE_createDefinition               = 7
	StmtParserRULE_columnDefinition               = 8
	StmtParserRULE_columnConstraint               = 9
	StmtParserRULE_tableConstraint                = 10
	StmtParserRULE_referenceDefinition            = 11
	StmtParserRULE_referenceAction                = 12
	StmtParserRULE_referenceControlType           = 13
	StmtParserRULE_indexColumnDefinition          = 14
	StmtParserRULE_tableOption                    = 15
	StmtParserRULE_tableType                      = 16
	StmtParserRULE_tablespaceStorage              = 17
	StmtParserRULE_partitionDefinitions           = 18
	StmtParserRULE_partitionFunctionDefinition    = 19
	StmtParserRULE_subpartitionFunctionDefinition = 20
	StmtParserRULE_partitionDefinition            = 21
	StmtParserRULE_partitionDefinerAtom           = 22
	StmtParserRULE_partitionDefinerVector         = 23
	StmtParserRULE_subpartitionDefinition         = 24
	StmtParserRULE_partitionOption                = 25
	StmtParserRULE_fullId                         = 26
	StmtParserRULE_tableName                      = 27
	StmtParserRULE_fullColumnName                 = 28
	StmtParserRULE_indexColumnName                = 29
	StmtParserRULE_mysqlVariable                  = 30
	StmtParserRULE_charsetName                    = 31
	StmtParserRULE_collationName                  = 32
	StmtParserRULE_engineName                     = 33
	StmtParserRULE_uid                            = 34
	StmtParserRULE_simpleId                       = 35
	StmtParserRULE_dottedId                       = 36
	StmtParserRULE_decimalLiteral                 = 37
	StmtParserRULE_fileSizeLiteral                = 38
	StmtParserRULE_stringLiteral                  = 39
	StmtParserRULE_booleanLiteral                 = 40
	StmtParserRULE_hexadecimalLiteral             = 41
	StmtParserRULE_nullNotnull                    = 42
	StmtParserRULE_constant                       = 43
	StmtParserRULE_dataType                       = 44
	StmtParserRULE_collectionOptions              = 45
	StmtParserRULE_convertedDataType              = 46
	StmtParserRULE_lengthOneDimension             = 47
	StmtParserRULE_lengthTwoDimension             = 48
	StmtParserRULE_lengthTwoOptionalDimension     = 49
	StmtParserRULE_uidList                        = 50
	StmtParserRULE_tables                         = 51
	StmtParserRULE_indexColumnNames               = 52
	StmtParserRULE_defaultValue                   = 53
	StmtParserRULE_currentTimestamp               = 54
	StmtParserRULE_ifNotExists                    = 55
	StmtParserRULE_scalarFunctionName             = 56
	StmtParserRULE_expression                     = 57
	StmtParserRULE_predicate                      = 58
	StmtParserRULE_expressionAtom                 = 59
	StmtParserRULE_unaryOperator                  = 60
	StmtParserRULE_comparisonOperator             = 61
	StmtParserRULE_logicalOperator                = 62
	StmtParserRULE_bitOperator                    = 63
	StmtParserRULE_mathOperator                   = 64
	StmtParserRULE_jsonOperator                   = 65
	StmtParserRULE_charsetNameBase                = 66
	StmtParserRULE_transactionLevelBase           = 67
	StmtParserRULE_privilegesBase                 = 68
	StmtParserRULE_intervalTypeBase               = 69
	StmtParserRULE_dataTypeBase                   = 70
	StmtParserRULE_keywordsCanBeId                = 71
	StmtParserRULE_functionNameBase               = 72
)

// IProgContext is an interface to support dynamic dispatch.
type IProgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgContext differentiates from other interfaces.
	IsProgContext()
}

type ProgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgContext() *ProgContext {
	var p = new(ProgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_prog
	return p
}

func (*ProgContext) IsProgContext() {}

func NewProgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgContext {
	var p = new(ProgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_prog

	return p
}

func (s *ProgContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgContext) SqlStatement() ISqlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementContext)
}

func (s *ProgContext) EOF() antlr.TerminalNode {
	return s.GetToken(StmtParserEOF, 0)
}

func (s *ProgContext) SEMI() antlr.TerminalNode {
	return s.GetToken(StmtParserSEMI, 0)
}

func (s *ProgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterProg(s)
	}
}

func (s *ProgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitProg(s)
	}
}

func (p *StmtParser) Prog() (localctx IProgContext) {
	this := p
	_ = this

	localctx = NewProgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, StmtParserRULE_prog)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(146)
		p.SqlStatement()
	}
	p.SetState(148)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserSEMI {
		{
			p.SetState(147)
			p.Match(StmtParserSEMI)
		}

	}
	{
		p.SetState(150)
		p.Match(StmtParserEOF)
	}

	return localctx
}

// ISqlStatementContext is an interface to support dynamic dispatch.
type ISqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSqlStatementContext differentiates from other interfaces.
	IsSqlStatementContext()
}

type SqlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementContext() *SqlStatementContext {
	var p = new(SqlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_sqlStatement
	return p
}

func (*SqlStatementContext) IsSqlStatementContext() {}

func NewSqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementContext {
	var p = new(SqlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_sqlStatement

	return p
}

func (s *SqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StmtParserCREATE, 0)
}

func (s *SqlStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserTABLE, 0)
}

func (s *SqlStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *SqlStatementContext) CreateDefinitions() ICreateDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionsContext)
}

func (s *SqlStatementContext) OR() antlr.TerminalNode {
	return s.GetToken(StmtParserOR, 0)
}

func (s *SqlStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLACE, 0)
}

func (s *SqlStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StmtParserTEMPORARY, 0)
}

func (s *SqlStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *SqlStatementContext) AllTableOption() []ITableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableOptionContext); ok {
			len++
		}
	}

	tst := make([]ITableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableOptionContext); ok {
			tst[i] = t.(ITableOptionContext)
			i++
		}
	}

	return tst
}

func (s *SqlStatementContext) TableOption(i int) ITableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionContext)
}

func (s *SqlStatementContext) PartitionDefinitions() IPartitionDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionsContext)
}

func (s *SqlStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *SqlStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *SqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSqlStatement(s)
	}
}

func (s *SqlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSqlStatement(s)
	}
}

func (p *StmtParser) SqlStatement() (localctx ISqlStatementContext) {
	this := p
	_ = this

	localctx = NewSqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, StmtParserRULE_sqlStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(152)
		p.Match(StmtParserCREATE)
	}
	p.SetState(155)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserOR {
		{
			p.SetState(153)
			p.Match(StmtParserOR)
		}
		{
			p.SetState(154)
			p.Match(StmtParserREPLACE)
		}

	}
	p.SetState(158)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserTEMPORARY {
		{
			p.SetState(157)
			p.Match(StmtParserTEMPORARY)
		}

	}
	{
		p.SetState(160)
		p.Match(StmtParserTABLE)
	}
	p.SetState(162)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(161)
			p.IfNotExists()
		}

	}
	{
		p.SetState(164)
		p.TableName()
	}
	{
		p.SetState(165)
		p.CreateDefinitions()
	}
	p.SetState(176)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&18014398509547525) != 0 || _la == StmtParserUNION || _la == StmtParserCHAR || (int64((_la-332)) & ^0x3f) == 0 && ((int64(1)<<(_la-332))&-9218727660950028281) != 0 || (int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&72075186223972353) != 0 || (int64((_la-487)) & ^0x3f) == 0 && ((int64(1)<<(_la-487))&571746046444545) != 0 || (int64((_la-585)) & ^0x3f) == 0 && ((int64(1)<<(_la-585))&105574188449793) != 0 || _la == StmtParserCHARSET || _la == StmtParserENGINE_ATTRIBUTE || _la == StmtParserSECONDARY_ENGINE_ATTRIBUTE {
		{
			p.SetState(166)
			p.TableOption()
		}
		p.SetState(173)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&18014398509547525) != 0 || _la == StmtParserUNION || _la == StmtParserCHAR || (int64((_la-332)) & ^0x3f) == 0 && ((int64(1)<<(_la-332))&-9218727660950028281) != 0 || (int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&72075186223972353) != 0 || (int64((_la-487)) & ^0x3f) == 0 && ((int64(1)<<(_la-487))&571746046444545) != 0 || (int64((_la-585)) & ^0x3f) == 0 && ((int64(1)<<(_la-585))&105574188449793) != 0 || _la == StmtParserCHARSET || _la == StmtParserENGINE_ATTRIBUTE || _la == StmtParserSECONDARY_ENGINE_ATTRIBUTE || _la == StmtParserCOMMA {
			p.SetState(168)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == StmtParserCOMMA {
				{
					p.SetState(167)
					p.Match(StmtParserCOMMA)
				}

			}
			{
				p.SetState(170)
				p.TableOption()
			}

			p.SetState(175)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(179)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserPARTITION {
		{
			p.SetState(178)
			p.PartitionDefinitions()
		}

	}

	return localctx
}

// ICharSetContext is an interface to support dynamic dispatch.
type ICharSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharSetContext differentiates from other interfaces.
	IsCharSetContext()
}

type CharSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharSetContext() *CharSetContext {
	var p = new(CharSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_charSet
	return p
}

func (*CharSetContext) IsCharSetContext() {}

func NewCharSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharSetContext {
	var p = new(CharSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_charSet

	return p
}

func (s *CharSetContext) GetParser() antlr.Parser { return s.parser }

func (s *CharSetContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(StmtParserCHARACTER, 0)
}

func (s *CharSetContext) SET() antlr.TerminalNode {
	return s.GetToken(StmtParserSET, 0)
}

func (s *CharSetContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(StmtParserCHARSET, 0)
}

func (s *CharSetContext) CHAR() antlr.TerminalNode {
	return s.GetToken(StmtParserCHAR, 0)
}

func (s *CharSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCharSet(s)
	}
}

func (s *CharSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCharSet(s)
	}
}

func (p *StmtParser) CharSet() (localctx ICharSetContext) {
	this := p
	_ = this

	localctx = NewCharSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, StmtParserRULE_charSet)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(186)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case StmtParserCHARACTER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(181)
			p.Match(StmtParserCHARACTER)
		}
		{
			p.SetState(182)
			p.Match(StmtParserSET)
		}

	case StmtParserCHARSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(183)
			p.Match(StmtParserCHARSET)
		}

	case StmtParserCHAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(184)
			p.Match(StmtParserCHAR)
		}
		{
			p.SetState(185)
			p.Match(StmtParserSET)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIntervalTypeContext is an interface to support dynamic dispatch.
type IIntervalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntervalTypeContext differentiates from other interfaces.
	IsIntervalTypeContext()
}

type IntervalTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalTypeContext() *IntervalTypeContext {
	var p = new(IntervalTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_intervalType
	return p
}

func (*IntervalTypeContext) IsIntervalTypeContext() {}

func NewIntervalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalTypeContext {
	var p = new(IntervalTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_intervalType

	return p
}

func (s *IntervalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalTypeContext) IntervalTypeBase() IIntervalTypeBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeBaseContext)
}

func (s *IntervalTypeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserYEAR, 0)
}

func (s *IntervalTypeContext) YEAR_MONTH() antlr.TerminalNode {
	return s.GetToken(StmtParserYEAR_MONTH, 0)
}

func (s *IntervalTypeContext) DAY_HOUR() antlr.TerminalNode {
	return s.GetToken(StmtParserDAY_HOUR, 0)
}

func (s *IntervalTypeContext) DAY_MINUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserDAY_MINUTE, 0)
}

func (s *IntervalTypeContext) DAY_SECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserDAY_SECOND, 0)
}

func (s *IntervalTypeContext) HOUR_MINUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserHOUR_MINUTE, 0)
}

func (s *IntervalTypeContext) HOUR_SECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserHOUR_SECOND, 0)
}

func (s *IntervalTypeContext) MINUTE_SECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserMINUTE_SECOND, 0)
}

func (s *IntervalTypeContext) SECOND_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserSECOND_MICROSECOND, 0)
}

func (s *IntervalTypeContext) MINUTE_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserMINUTE_MICROSECOND, 0)
}

func (s *IntervalTypeContext) HOUR_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserHOUR_MICROSECOND, 0)
}

func (s *IntervalTypeContext) DAY_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserDAY_MICROSECOND, 0)
}

func (s *IntervalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIntervalType(s)
	}
}

func (s *IntervalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIntervalType(s)
	}
}

func (p *StmtParser) IntervalType() (localctx IIntervalTypeContext) {
	this := p
	_ = this

	localctx = NewIntervalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, StmtParserRULE_intervalType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(201)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case StmtParserQUARTER, StmtParserMONTH, StmtParserDAY, StmtParserHOUR, StmtParserMINUTE, StmtParserWEEK, StmtParserSECOND, StmtParserMICROSECOND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(188)
			p.IntervalTypeBase()
		}

	case StmtParserYEAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(189)
			p.Match(StmtParserYEAR)
		}

	case StmtParserYEAR_MONTH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(190)
			p.Match(StmtParserYEAR_MONTH)
		}

	case StmtParserDAY_HOUR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(191)
			p.Match(StmtParserDAY_HOUR)
		}

	case StmtParserDAY_MINUTE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(192)
			p.Match(StmtParserDAY_MINUTE)
		}

	case StmtParserDAY_SECOND:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(193)
			p.Match(StmtParserDAY_SECOND)
		}

	case StmtParserHOUR_MINUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(194)
			p.Match(StmtParserHOUR_MINUTE)
		}

	case StmtParserHOUR_SECOND:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(195)
			p.Match(StmtParserHOUR_SECOND)
		}

	case StmtParserMINUTE_SECOND:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(196)
			p.Match(StmtParserMINUTE_SECOND)
		}

	case StmtParserSECOND_MICROSECOND:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(197)
			p.Match(StmtParserSECOND_MICROSECOND)
		}

	case StmtParserMINUTE_MICROSECOND:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(198)
			p.Match(StmtParserMINUTE_MICROSECOND)
		}

	case StmtParserHOUR_MICROSECOND:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(199)
			p.Match(StmtParserHOUR_MICROSECOND)
		}

	case StmtParserDAY_MICROSECOND:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(200)
			p.Match(StmtParserDAY_MICROSECOND)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIndexTypeContext is an interface to support dynamic dispatch.
type IIndexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexTypeContext differentiates from other interfaces.
	IsIndexTypeContext()
}

type IndexTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexTypeContext() *IndexTypeContext {
	var p = new(IndexTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_indexType
	return p
}

func (*IndexTypeContext) IsIndexTypeContext() {}

func NewIndexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeContext {
	var p = new(IndexTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_indexType

	return p
}

func (s *IndexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeContext) USING() antlr.TerminalNode {
	return s.GetToken(StmtParserUSING, 0)
}

func (s *IndexTypeContext) BTREE() antlr.TerminalNode {
	return s.GetToken(StmtParserBTREE, 0)
}

func (s *IndexTypeContext) HASH() antlr.TerminalNode {
	return s.GetToken(StmtParserHASH, 0)
}

func (s *IndexTypeContext) RTREE() antlr.TerminalNode {
	return s.GetToken(StmtParserRTREE, 0)
}

func (s *IndexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIndexType(s)
	}
}

func (s *IndexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIndexType(s)
	}
}

func (p *StmtParser) IndexType() (localctx IIndexTypeContext) {
	this := p
	_ = this

	localctx = NewIndexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, StmtParserRULE_indexType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(203)
		p.Match(StmtParserUSING)
	}
	{
		p.SetState(204)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserBTREE || _la == StmtParserHASH || _la == StmtParserRTREE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIndexOptionContext is an interface to support dynamic dispatch.
type IIndexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexOptionContext differentiates from other interfaces.
	IsIndexOptionContext()
}

type IndexOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexOptionContext() *IndexOptionContext {
	var p = new(IndexOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_indexOption
	return p
}

func (*IndexOptionContext) IsIndexOptionContext() {}

func NewIndexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexOptionContext {
	var p = new(IndexOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_indexOption

	return p
}

func (s *IndexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexOptionContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY_BLOCK_SIZE, 0)
}

func (s *IndexOptionContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *IndexOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *IndexOptionContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *IndexOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(StmtParserWITH, 0)
}

func (s *IndexOptionContext) PARSER() antlr.TerminalNode {
	return s.GetToken(StmtParserPARSER, 0)
}

func (s *IndexOptionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *IndexOptionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMENT, 0)
}

func (s *IndexOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *IndexOptionContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(StmtParserVISIBLE, 0)
}

func (s *IndexOptionContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(StmtParserINVISIBLE, 0)
}

func (s *IndexOptionContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserENGINE_ATTRIBUTE, 0)
}

func (s *IndexOptionContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *IndexOptionContext) CLUSTERING() antlr.TerminalNode {
	return s.GetToken(StmtParserCLUSTERING, 0)
}

func (s *IndexOptionContext) YES() antlr.TerminalNode {
	return s.GetToken(StmtParserYES, 0)
}

func (s *IndexOptionContext) NO() antlr.TerminalNode {
	return s.GetToken(StmtParserNO, 0)
}

func (s *IndexOptionContext) IGNORED() antlr.TerminalNode {
	return s.GetToken(StmtParserIGNORED, 0)
}

func (s *IndexOptionContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *IndexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIndexOption(s)
	}
}

func (s *IndexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIndexOption(s)
	}
}

func (p *StmtParser) IndexOption() (localctx IIndexOptionContext) {
	this := p
	_ = this

	localctx = NewIndexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, StmtParserRULE_indexOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(236)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case StmtParserKEY_BLOCK_SIZE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(206)
			p.Match(StmtParserKEY_BLOCK_SIZE)
		}
		p.SetState(208)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(207)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(210)
			p.FileSizeLiteral()
		}

	case StmtParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(211)
			p.IndexType()
		}

	case StmtParserWITH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(212)
			p.Match(StmtParserWITH)
		}
		{
			p.SetState(213)
			p.Match(StmtParserPARSER)
		}
		{
			p.SetState(214)
			p.Uid()
		}

	case StmtParserCOMMENT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(215)
			p.Match(StmtParserCOMMENT)
		}
		{
			p.SetState(216)
			p.Match(StmtParserSTRING_LITERAL)
		}

	case StmtParserINVISIBLE, StmtParserVISIBLE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(217)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserINVISIBLE || _la == StmtParserVISIBLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case StmtParserENGINE_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(218)
			p.Match(StmtParserENGINE_ATTRIBUTE)
		}
		p.SetState(220)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(219)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(222)
			p.Match(StmtParserSTRING_LITERAL)
		}

	case StmtParserSECONDARY_ENGINE_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(223)
			p.Match(StmtParserSECONDARY_ENGINE_ATTRIBUTE)
		}
		p.SetState(225)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(224)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(227)
			p.Match(StmtParserSTRING_LITERAL)
		}

	case StmtParserCLUSTERING:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(228)
			p.Match(StmtParserCLUSTERING)
		}
		{
			p.SetState(229)
			p.Match(StmtParserEQUAL_SYMBOL)
		}
		{
			p.SetState(230)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserNO || _la == StmtParserYES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case StmtParserIGNORED, StmtParserNOT:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(234)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case StmtParserIGNORED:
			{
				p.SetState(231)
				p.Match(StmtParserIGNORED)
			}

		case StmtParserNOT:
			{
				p.SetState(232)
				p.Match(StmtParserNOT)
			}
			{
				p.SetState(233)
				p.Match(StmtParserIGNORED)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICreateDefinitionsContext is an interface to support dynamic dispatch.
type ICreateDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateDefinitionsContext differentiates from other interfaces.
	IsCreateDefinitionsContext()
}

type CreateDefinitionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDefinitionsContext() *CreateDefinitionsContext {
	var p = new(CreateDefinitionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_createDefinitions
	return p
}

func (*CreateDefinitionsContext) IsCreateDefinitionsContext() {}

func NewCreateDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDefinitionsContext {
	var p = new(CreateDefinitionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_createDefinitions

	return p
}

func (s *CreateDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDefinitionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *CreateDefinitionsContext) AllCreateDefinition() []ICreateDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDefinitionContext); ok {
			tst[i] = t.(ICreateDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *CreateDefinitionsContext) CreateDefinition(i int) ICreateDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionContext)
}

func (s *CreateDefinitionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *CreateDefinitionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *CreateDefinitionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *CreateDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCreateDefinitions(s)
	}
}

func (s *CreateDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCreateDefinitions(s)
	}
}

func (p *StmtParser) CreateDefinitions() (localctx ICreateDefinitionsContext) {
	this := p
	_ = this

	localctx = NewCreateDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, StmtParserRULE_createDefinitions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(238)
		p.Match(StmtParserLR_BRACKET)
	}
	{
		p.SetState(239)
		p.CreateDefinition()
	}
	p.SetState(244)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == StmtParserCOMMA {
		{
			p.SetState(240)
			p.Match(StmtParserCOMMA)
		}
		{
			p.SetState(241)
			p.CreateDefinition()
		}

		p.SetState(246)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(247)
		p.Match(StmtParserRR_BRACKET)
	}

	return localctx
}

// ICreateDefinitionContext is an interface to support dynamic dispatch.
type ICreateDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateDefinitionContext differentiates from other interfaces.
	IsCreateDefinitionContext()
}

type CreateDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDefinitionContext() *CreateDefinitionContext {
	var p = new(CreateDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_createDefinition
	return p
}

func (*CreateDefinitionContext) IsCreateDefinitionContext() {}

func NewCreateDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDefinitionContext {
	var p = new(CreateDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_createDefinition

	return p
}

func (s *CreateDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDefinitionContext) CopyFrom(ctx *CreateDefinitionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *CreateDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ColumnDeclarationContext struct {
	*CreateDefinitionContext
}

func NewColumnDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnDeclarationContext {
	var p = new(ColumnDeclarationContext)

	p.CreateDefinitionContext = NewEmptyCreateDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CreateDefinitionContext))

	return p
}

func (s *ColumnDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDeclarationContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ColumnDeclarationContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *ColumnDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterColumnDeclaration(s)
	}
}

func (s *ColumnDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitColumnDeclaration(s)
	}
}

type ConstraintDeclarationContext struct {
	*CreateDefinitionContext
}

func NewConstraintDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstraintDeclarationContext {
	var p = new(ConstraintDeclarationContext)

	p.CreateDefinitionContext = NewEmptyCreateDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CreateDefinitionContext))

	return p
}

func (s *ConstraintDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintDeclarationContext) TableConstraint() ITableConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableConstraintContext)
}

func (s *ConstraintDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterConstraintDeclaration(s)
	}
}

func (s *ConstraintDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitConstraintDeclaration(s)
	}
}

type IndexDeclarationContext struct {
	*CreateDefinitionContext
}

func NewIndexDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexDeclarationContext {
	var p = new(IndexDeclarationContext)

	p.CreateDefinitionContext = NewEmptyCreateDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CreateDefinitionContext))

	return p
}

func (s *IndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexDeclarationContext) IndexColumnDefinition() IIndexColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnDefinitionContext)
}

func (s *IndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIndexDeclaration(s)
	}
}

func (s *IndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIndexDeclaration(s)
	}
}

func (p *StmtParser) CreateDefinition() (localctx ICreateDefinitionContext) {
	this := p
	_ = this

	localctx = NewCreateDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, StmtParserRULE_createDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(254)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		localctx = NewColumnDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(249)
			p.Uid()
		}
		{
			p.SetState(250)
			p.ColumnDefinition()
		}

	case 2:
		localctx = NewConstraintDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(252)
			p.TableConstraint()
		}

	case 3:
		localctx = NewIndexDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(253)
			p.IndexColumnDefinition()
		}

	}

	return localctx
}

// IColumnDefinitionContext is an interface to support dynamic dispatch.
type IColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnDefinitionContext differentiates from other interfaces.
	IsColumnDefinitionContext()
}

type ColumnDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionContext() *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_columnDefinition
	return p
}

func (*ColumnDefinitionContext) IsColumnDefinitionContext() {}

func NewColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_columnDefinition

	return p
}

func (s *ColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ColumnDefinitionContext) AllColumnConstraint() []IColumnConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnConstraintContext); ok {
			len++
		}
	}

	tst := make([]IColumnConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnConstraintContext); ok {
			tst[i] = t.(IColumnConstraintContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefinitionContext) ColumnConstraint(i int) IColumnConstraintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintContext)
}

func (s *ColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitColumnDefinition(s)
	}
}

func (p *StmtParser) ColumnDefinition() (localctx IColumnDefinitionContext) {
	this := p
	_ = this

	localctx = NewColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, StmtParserRULE_columnDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(256)
		p.DataType()
	}
	p.SetState(260)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-12)) & ^0x3f) == 0 && ((int64(1)<<(_la-12))&36028797287555073) != 0 || (int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&17867152031745) != 0 || _la == StmtParserUNIQUE || _la == StmtParserSERIAL || (int64((_la-333)) & ^0x3f) == 0 && ((int64(1)<<(_la-333))&83886081) != 0 || _la == StmtParserINVISIBLE || _la == StmtParserSTORAGE || _la == StmtParserVISIBLE || _la == StmtParserNULL_SPEC_LITERAL {
		{
			p.SetState(257)
			p.ColumnConstraint()
		}

		p.SetState(262)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IColumnConstraintContext is an interface to support dynamic dispatch.
type IColumnConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnConstraintContext differentiates from other interfaces.
	IsColumnConstraintContext()
}

type ColumnConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnConstraintContext() *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_columnConstraint
	return p
}

func (*ColumnConstraintContext) IsColumnConstraintContext() {}

func NewColumnConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_columnConstraint

	return p
}

func (s *ColumnConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnConstraintContext) CopyFrom(ctx *ColumnConstraintContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StorageColumnConstraintContext struct {
	*ColumnConstraintContext
	storageval antlr.Token
}

func NewStorageColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StorageColumnConstraintContext {
	var p = new(StorageColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *StorageColumnConstraintContext) GetStorageval() antlr.Token { return s.storageval }

func (s *StorageColumnConstraintContext) SetStorageval(v antlr.Token) { s.storageval = v }

func (s *StorageColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageColumnConstraintContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StmtParserSTORAGE, 0)
}

func (s *StorageColumnConstraintContext) DISK() antlr.TerminalNode {
	return s.GetToken(StmtParserDISK, 0)
}

func (s *StorageColumnConstraintContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(StmtParserMEMORY, 0)
}

func (s *StorageColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *StorageColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterStorageColumnConstraint(s)
	}
}

func (s *StorageColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitStorageColumnConstraint(s)
	}
}

type VisibilityColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewVisibilityColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VisibilityColumnConstraintContext {
	var p = new(VisibilityColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *VisibilityColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VisibilityColumnConstraintContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(StmtParserVISIBLE, 0)
}

func (s *VisibilityColumnConstraintContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(StmtParserINVISIBLE, 0)
}

func (s *VisibilityColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterVisibilityColumnConstraint(s)
	}
}

func (s *VisibilityColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitVisibilityColumnConstraint(s)
	}
}

type AutoIncrementColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewAutoIncrementColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AutoIncrementColumnConstraintContext {
	var p = new(AutoIncrementColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *AutoIncrementColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AutoIncrementColumnConstraintContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(StmtParserAUTO_INCREMENT, 0)
}

func (s *AutoIncrementColumnConstraintContext) ON() antlr.TerminalNode {
	return s.GetToken(StmtParserON, 0)
}

func (s *AutoIncrementColumnConstraintContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(StmtParserUPDATE, 0)
}

func (s *AutoIncrementColumnConstraintContext) CurrentTimestamp() ICurrentTimestampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentTimestampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentTimestampContext)
}

func (s *AutoIncrementColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterAutoIncrementColumnConstraint(s)
	}
}

func (s *AutoIncrementColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitAutoIncrementColumnConstraint(s)
	}
}

type CommentColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewCommentColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentColumnConstraintContext {
	var p = new(CommentColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *CommentColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentColumnConstraintContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMENT, 0)
}

func (s *CommentColumnConstraintContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *CommentColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCommentColumnConstraint(s)
	}
}

func (s *CommentColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCommentColumnConstraint(s)
	}
}

type UniqueKeyColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewUniqueKeyColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UniqueKeyColumnConstraintContext {
	var p = new(UniqueKeyColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *UniqueKeyColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueKeyColumnConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(StmtParserUNIQUE, 0)
}

func (s *UniqueKeyColumnConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY, 0)
}

func (s *UniqueKeyColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterUniqueKeyColumnConstraint(s)
	}
}

func (s *UniqueKeyColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitUniqueKeyColumnConstraint(s)
	}
}

type SerialDefaultColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewSerialDefaultColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SerialDefaultColumnConstraintContext {
	var p = new(SerialDefaultColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *SerialDefaultColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SerialDefaultColumnConstraintContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSERIAL, 0)
}

func (s *SerialDefaultColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *SerialDefaultColumnConstraintContext) VALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserVALUE, 0)
}

func (s *SerialDefaultColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSerialDefaultColumnConstraint(s)
	}
}

func (s *SerialDefaultColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSerialDefaultColumnConstraint(s)
	}
}

type GeneratedColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewGeneratedColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GeneratedColumnConstraintContext {
	var p = new(GeneratedColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *GeneratedColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratedColumnConstraintContext) AS() antlr.TerminalNode {
	return s.GetToken(StmtParserAS, 0)
}

func (s *GeneratedColumnConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *GeneratedColumnConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GeneratedColumnConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *GeneratedColumnConstraintContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(StmtParserGENERATED, 0)
}

func (s *GeneratedColumnConstraintContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(StmtParserALWAYS, 0)
}

func (s *GeneratedColumnConstraintContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(StmtParserVIRTUAL, 0)
}

func (s *GeneratedColumnConstraintContext) STORED() antlr.TerminalNode {
	return s.GetToken(StmtParserSTORED, 0)
}

func (s *GeneratedColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterGeneratedColumnConstraint(s)
	}
}

func (s *GeneratedColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitGeneratedColumnConstraint(s)
	}
}

type FormatColumnConstraintContext struct {
	*ColumnConstraintContext
	colformat antlr.Token
}

func NewFormatColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FormatColumnConstraintContext {
	var p = new(FormatColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *FormatColumnConstraintContext) GetColformat() antlr.Token { return s.colformat }

func (s *FormatColumnConstraintContext) SetColformat(v antlr.Token) { s.colformat = v }

func (s *FormatColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormatColumnConstraintContext) COLUMN_FORMAT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLUMN_FORMAT, 0)
}

func (s *FormatColumnConstraintContext) FIXED() antlr.TerminalNode {
	return s.GetToken(StmtParserFIXED, 0)
}

func (s *FormatColumnConstraintContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(StmtParserDYNAMIC, 0)
}

func (s *FormatColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *FormatColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterFormatColumnConstraint(s)
	}
}

func (s *FormatColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitFormatColumnConstraint(s)
	}
}

type CollateColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewCollateColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateColumnConstraintContext {
	var p = new(CollateColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *CollateColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateColumnConstraintContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLLATE, 0)
}

func (s *CollateColumnConstraintContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *CollateColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCollateColumnConstraint(s)
	}
}

func (s *CollateColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCollateColumnConstraint(s)
	}
}

type PrimaryKeyColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewPrimaryKeyColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryKeyColumnConstraintContext {
	var p = new(PrimaryKeyColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *PrimaryKeyColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyColumnConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY, 0)
}

func (s *PrimaryKeyColumnConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(StmtParserPRIMARY, 0)
}

func (s *PrimaryKeyColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPrimaryKeyColumnConstraint(s)
	}
}

func (s *PrimaryKeyColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPrimaryKeyColumnConstraint(s)
	}
}

type CheckColumnConstraintContext struct {
	*ColumnConstraintContext
	name IUidContext
}

func NewCheckColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CheckColumnConstraintContext {
	var p = new(CheckColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *CheckColumnConstraintContext) GetName() IUidContext { return s.name }

func (s *CheckColumnConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *CheckColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckColumnConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(StmtParserCHECK, 0)
}

func (s *CheckColumnConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *CheckColumnConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CheckColumnConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *CheckColumnConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONSTRAINT, 0)
}

func (s *CheckColumnConstraintContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CheckColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCheckColumnConstraint(s)
	}
}

func (s *CheckColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCheckColumnConstraint(s)
	}
}

type NullColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewNullColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullColumnConstraintContext {
	var p = new(NullColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *NullColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullColumnConstraintContext) NullNotnull() INullNotnullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullNotnullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullNotnullContext)
}

func (s *NullColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterNullColumnConstraint(s)
	}
}

func (s *NullColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitNullColumnConstraint(s)
	}
}

type DefaultColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewDefaultColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefaultColumnConstraintContext {
	var p = new(DefaultColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *DefaultColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *DefaultColumnConstraintContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *DefaultColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterDefaultColumnConstraint(s)
	}
}

func (s *DefaultColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitDefaultColumnConstraint(s)
	}
}

type ReferenceColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewReferenceColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReferenceColumnConstraintContext {
	var p = new(ReferenceColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *ReferenceColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceColumnConstraintContext) ReferenceDefinition() IReferenceDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceDefinitionContext)
}

func (s *ReferenceColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterReferenceColumnConstraint(s)
	}
}

func (s *ReferenceColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitReferenceColumnConstraint(s)
	}
}

func (p *StmtParser) ColumnConstraint() (localctx IColumnConstraintContext) {
	this := p
	_ = this

	localctx = NewColumnConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, StmtParserRULE_columnConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(316)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case StmtParserNOT, StmtParserNULL_LITERAL, StmtParserNULL_SPEC_LITERAL:
		localctx = NewNullColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(263)
			p.NullNotnull()
		}

	case StmtParserDEFAULT:
		localctx = NewDefaultColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(264)
			p.Match(StmtParserDEFAULT)
		}
		{
			p.SetState(265)
			p.DefaultValue()
		}

	case StmtParserVISIBLE:
		localctx = NewVisibilityColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(266)
			p.Match(StmtParserVISIBLE)
		}

	case StmtParserINVISIBLE:
		localctx = NewVisibilityColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(267)
			p.Match(StmtParserINVISIBLE)
		}

	case StmtParserON, StmtParserAUTO_INCREMENT:
		localctx = NewAutoIncrementColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(272)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case StmtParserAUTO_INCREMENT:
			{
				p.SetState(268)
				p.Match(StmtParserAUTO_INCREMENT)
			}

		case StmtParserON:
			{
				p.SetState(269)
				p.Match(StmtParserON)
			}
			{
				p.SetState(270)
				p.Match(StmtParserUPDATE)
			}
			{
				p.SetState(271)
				p.CurrentTimestamp()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case StmtParserKEY, StmtParserPRIMARY:
		localctx = NewPrimaryKeyColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(275)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserPRIMARY {
			{
				p.SetState(274)
				p.Match(StmtParserPRIMARY)
			}

		}
		{
			p.SetState(277)
			p.Match(StmtParserKEY)
		}

	case StmtParserUNIQUE:
		localctx = NewUniqueKeyColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(278)
			p.Match(StmtParserUNIQUE)
		}
		p.SetState(280)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(279)
				p.Match(StmtParserKEY)
			}

		}

	case StmtParserCOMMENT:
		localctx = NewCommentColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(282)
			p.Match(StmtParserCOMMENT)
		}
		{
			p.SetState(283)
			p.Match(StmtParserSTRING_LITERAL)
		}

	case StmtParserCOLUMN_FORMAT:
		localctx = NewFormatColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(284)
			p.Match(StmtParserCOLUMN_FORMAT)
		}
		{
			p.SetState(285)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FormatColumnConstraintContext).colformat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserDEFAULT || _la == StmtParserDYNAMIC || _la == StmtParserFIXED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FormatColumnConstraintContext).colformat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case StmtParserSTORAGE:
		localctx = NewStorageColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(286)
			p.Match(StmtParserSTORAGE)
		}
		{
			p.SetState(287)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StorageColumnConstraintContext).storageval = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserDEFAULT || _la == StmtParserDISK || _la == StmtParserMEMORY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StorageColumnConstraintContext).storageval = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case StmtParserREFERENCES:
		localctx = NewReferenceColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(288)
			p.ReferenceDefinition()
		}

	case StmtParserCOLLATE:
		localctx = NewCollateColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(289)
			p.Match(StmtParserCOLLATE)
		}
		{
			p.SetState(290)
			p.CollationName()
		}

	case StmtParserAS, StmtParserGENERATED:
		localctx = NewGeneratedColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		p.SetState(293)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserGENERATED {
			{
				p.SetState(291)
				p.Match(StmtParserGENERATED)
			}
			{
				p.SetState(292)
				p.Match(StmtParserALWAYS)
			}

		}
		{
			p.SetState(295)
			p.Match(StmtParserAS)
		}
		{
			p.SetState(296)
			p.Match(StmtParserLR_BRACKET)
		}
		{
			p.SetState(297)
			p.expression(0)
		}
		{
			p.SetState(298)
			p.Match(StmtParserRR_BRACKET)
		}
		p.SetState(300)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserSTORED || _la == StmtParserVIRTUAL {
			{
				p.SetState(299)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StmtParserSTORED || _la == StmtParserVIRTUAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case StmtParserSERIAL:
		localctx = NewSerialDefaultColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(302)
			p.Match(StmtParserSERIAL)
		}
		{
			p.SetState(303)
			p.Match(StmtParserDEFAULT)
		}
		{
			p.SetState(304)
			p.Match(StmtParserVALUE)
		}

	case StmtParserCHECK, StmtParserCONSTRAINT:
		localctx = NewCheckColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		p.SetState(309)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCONSTRAINT {
			{
				p.SetState(305)
				p.Match(StmtParserCONSTRAINT)
			}
			p.SetState(307)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72129216912687104) != 0 || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&73333234766712913) != 0 || (int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&67175041) != 0 || (int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17174494689) != 0 || (int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-137438953473) != 0 || (int64((_la-339)) & ^0x3f) == 0 && ((int64(1)<<(_la-339))&-1) != 0 || (int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&-262145) != 0 || (int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&-1) != 0 || (int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&-70368744181761) != 0 || (int64((_la-595)) & ^0x3f) == 0 && ((int64(1)<<(_la-595))&-35184405643265) != 0 || (int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-288308991769968705) != 0 || (int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-3458764513820540929) != 0 || (int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-1) != 0 || (int64((_la-852)) & ^0x3f) == 0 && ((int64(1)<<(_la-852))&-1) != 0 || (int64((_la-916)) & ^0x3f) == 0 && ((int64(1)<<(_la-916))&-1) != 0 || (int64((_la-980)) & ^0x3f) == 0 && ((int64(1)<<(_la-980))&-1) != 0 || (int64((_la-1044)) & ^0x3f) == 0 && ((int64(1)<<(_la-1044))&18014398509481983) != 0 || (int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&25807552513) != 0 {
				{
					p.SetState(306)

					var _x = p.Uid()

					localctx.(*CheckColumnConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(311)
			p.Match(StmtParserCHECK)
		}
		{
			p.SetState(312)
			p.Match(StmtParserLR_BRACKET)
		}
		{
			p.SetState(313)
			p.expression(0)
		}
		{
			p.SetState(314)
			p.Match(StmtParserRR_BRACKET)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITableConstraintContext is an interface to support dynamic dispatch.
type ITableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableConstraintContext differentiates from other interfaces.
	IsTableConstraintContext()
}

type TableConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableConstraintContext() *TableConstraintContext {
	var p = new(TableConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_tableConstraint
	return p
}

func (*TableConstraintContext) IsTableConstraintContext() {}

func NewTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableConstraintContext {
	var p = new(TableConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_tableConstraint

	return p
}

func (s *TableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TableConstraintContext) CopyFrom(ctx *TableConstraintContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UniqueKeyTableConstraintContext struct {
	*TableConstraintContext
	name        IUidContext
	indexFormat antlr.Token
	index       IUidContext
}

func NewUniqueKeyTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UniqueKeyTableConstraintContext {
	var p = new(UniqueKeyTableConstraintContext)

	p.TableConstraintContext = NewEmptyTableConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableConstraintContext))

	return p
}

func (s *UniqueKeyTableConstraintContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *UniqueKeyTableConstraintContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *UniqueKeyTableConstraintContext) GetName() IUidContext { return s.name }

func (s *UniqueKeyTableConstraintContext) GetIndex() IUidContext { return s.index }

func (s *UniqueKeyTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *UniqueKeyTableConstraintContext) SetIndex(v IUidContext) { s.index = v }

func (s *UniqueKeyTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueKeyTableConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(StmtParserUNIQUE, 0)
}

func (s *UniqueKeyTableConstraintContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *UniqueKeyTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONSTRAINT, 0)
}

func (s *UniqueKeyTableConstraintContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *UniqueKeyTableConstraintContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *UniqueKeyTableConstraintContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *UniqueKeyTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *UniqueKeyTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UniqueKeyTableConstraintContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StmtParserINDEX, 0)
}

func (s *UniqueKeyTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY, 0)
}

func (s *UniqueKeyTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterUniqueKeyTableConstraint(s)
	}
}

func (s *UniqueKeyTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitUniqueKeyTableConstraint(s)
	}
}

type CheckTableConstraintContext struct {
	*TableConstraintContext
	name IUidContext
}

func NewCheckTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CheckTableConstraintContext {
	var p = new(CheckTableConstraintContext)

	p.TableConstraintContext = NewEmptyTableConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableConstraintContext))

	return p
}

func (s *CheckTableConstraintContext) GetName() IUidContext { return s.name }

func (s *CheckTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *CheckTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckTableConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(StmtParserCHECK, 0)
}

func (s *CheckTableConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *CheckTableConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CheckTableConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *CheckTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONSTRAINT, 0)
}

func (s *CheckTableConstraintContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CheckTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCheckTableConstraint(s)
	}
}

func (s *CheckTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCheckTableConstraint(s)
	}
}

type PrimaryKeyTableConstraintContext struct {
	*TableConstraintContext
	name  IUidContext
	index IUidContext
}

func NewPrimaryKeyTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryKeyTableConstraintContext {
	var p = new(PrimaryKeyTableConstraintContext)

	p.TableConstraintContext = NewEmptyTableConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableConstraintContext))

	return p
}

func (s *PrimaryKeyTableConstraintContext) GetName() IUidContext { return s.name }

func (s *PrimaryKeyTableConstraintContext) GetIndex() IUidContext { return s.index }

func (s *PrimaryKeyTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *PrimaryKeyTableConstraintContext) SetIndex(v IUidContext) { s.index = v }

func (s *PrimaryKeyTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyTableConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(StmtParserPRIMARY, 0)
}

func (s *PrimaryKeyTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY, 0)
}

func (s *PrimaryKeyTableConstraintContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *PrimaryKeyTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONSTRAINT, 0)
}

func (s *PrimaryKeyTableConstraintContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *PrimaryKeyTableConstraintContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *PrimaryKeyTableConstraintContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *PrimaryKeyTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *PrimaryKeyTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PrimaryKeyTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPrimaryKeyTableConstraint(s)
	}
}

func (s *PrimaryKeyTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPrimaryKeyTableConstraint(s)
	}
}

type ForeignKeyTableConstraintContext struct {
	*TableConstraintContext
	name  IUidContext
	index IUidContext
}

func NewForeignKeyTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForeignKeyTableConstraintContext {
	var p = new(ForeignKeyTableConstraintContext)

	p.TableConstraintContext = NewEmptyTableConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableConstraintContext))

	return p
}

func (s *ForeignKeyTableConstraintContext) GetName() IUidContext { return s.name }

func (s *ForeignKeyTableConstraintContext) GetIndex() IUidContext { return s.index }

func (s *ForeignKeyTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *ForeignKeyTableConstraintContext) SetIndex(v IUidContext) { s.index = v }

func (s *ForeignKeyTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeignKeyTableConstraintContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(StmtParserFOREIGN, 0)
}

func (s *ForeignKeyTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY, 0)
}

func (s *ForeignKeyTableConstraintContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *ForeignKeyTableConstraintContext) ReferenceDefinition() IReferenceDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceDefinitionContext)
}

func (s *ForeignKeyTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONSTRAINT, 0)
}

func (s *ForeignKeyTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *ForeignKeyTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ForeignKeyTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterForeignKeyTableConstraint(s)
	}
}

func (s *ForeignKeyTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitForeignKeyTableConstraint(s)
	}
}

func (p *StmtParser) TableConstraint() (localctx ITableConstraintContext) {
	this := p
	_ = this

	localctx = NewTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, StmtParserRULE_tableConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(387)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPrimaryKeyTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(322)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCONSTRAINT {
			{
				p.SetState(318)
				p.Match(StmtParserCONSTRAINT)
			}
			p.SetState(320)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(319)

					var _x = p.Uid()

					localctx.(*PrimaryKeyTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(324)
			p.Match(StmtParserPRIMARY)
		}
		{
			p.SetState(325)
			p.Match(StmtParserKEY)
		}
		p.SetState(327)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72129216912687104) != 0 || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&73333234766712913) != 0 || (int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&67175041) != 0 || (int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17174494689) != 0 || (int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-137438953473) != 0 || (int64((_la-339)) & ^0x3f) == 0 && ((int64(1)<<(_la-339))&-1) != 0 || (int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&-262145) != 0 || (int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&-1) != 0 || (int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&-70368744181761) != 0 || (int64((_la-595)) & ^0x3f) == 0 && ((int64(1)<<(_la-595))&-35184405643265) != 0 || (int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-288308991769968705) != 0 || (int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-3458764513820540929) != 0 || (int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-1) != 0 || (int64((_la-852)) & ^0x3f) == 0 && ((int64(1)<<(_la-852))&-1) != 0 || (int64((_la-916)) & ^0x3f) == 0 && ((int64(1)<<(_la-916))&-1) != 0 || (int64((_la-980)) & ^0x3f) == 0 && ((int64(1)<<(_la-980))&-1) != 0 || (int64((_la-1044)) & ^0x3f) == 0 && ((int64(1)<<(_la-1044))&18014398509481983) != 0 || (int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&25807552513) != 0 {
			{
				p.SetState(326)

				var _x = p.Uid()

				localctx.(*PrimaryKeyTableConstraintContext).index = _x
			}

		}
		p.SetState(330)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserUSING {
			{
				p.SetState(329)
				p.IndexType()
			}

		}
		{
			p.SetState(332)
			p.IndexColumnNames()
		}
		p.SetState(336)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserIGNORED || _la == StmtParserNOT || _la == StmtParserUSING || _la == StmtParserWITH || _la == StmtParserCLUSTERING || _la == StmtParserCOMMENT || _la == StmtParserINVISIBLE || _la == StmtParserKEY_BLOCK_SIZE || _la == StmtParserVISIBLE || _la == StmtParserENGINE_ATTRIBUTE || _la == StmtParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(333)
				p.IndexOption()
			}

			p.SetState(338)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewUniqueKeyTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(343)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCONSTRAINT {
			{
				p.SetState(339)
				p.Match(StmtParserCONSTRAINT)
			}
			p.SetState(341)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72129216912687104) != 0 || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&73333234766712913) != 0 || (int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&67175041) != 0 || (int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17174494689) != 0 || (int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-137438953473) != 0 || (int64((_la-339)) & ^0x3f) == 0 && ((int64(1)<<(_la-339))&-1) != 0 || (int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&-262145) != 0 || (int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&-1) != 0 || (int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&-70368744181761) != 0 || (int64((_la-595)) & ^0x3f) == 0 && ((int64(1)<<(_la-595))&-35184405643265) != 0 || (int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-288308991769968705) != 0 || (int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-3458764513820540929) != 0 || (int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-1) != 0 || (int64((_la-852)) & ^0x3f) == 0 && ((int64(1)<<(_la-852))&-1) != 0 || (int64((_la-916)) & ^0x3f) == 0 && ((int64(1)<<(_la-916))&-1) != 0 || (int64((_la-980)) & ^0x3f) == 0 && ((int64(1)<<(_la-980))&-1) != 0 || (int64((_la-1044)) & ^0x3f) == 0 && ((int64(1)<<(_la-1044))&18014398509481983) != 0 || (int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&25807552513) != 0 {
				{
					p.SetState(340)

					var _x = p.Uid()

					localctx.(*UniqueKeyTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(345)
			p.Match(StmtParserUNIQUE)
		}
		p.SetState(347)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserINDEX || _la == StmtParserKEY {
			{
				p.SetState(346)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*UniqueKeyTableConstraintContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == StmtParserINDEX || _la == StmtParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*UniqueKeyTableConstraintContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(350)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72129216912687104) != 0 || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&73333234766712913) != 0 || (int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&67175041) != 0 || (int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17174494689) != 0 || (int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-137438953473) != 0 || (int64((_la-339)) & ^0x3f) == 0 && ((int64(1)<<(_la-339))&-1) != 0 || (int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&-262145) != 0 || (int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&-1) != 0 || (int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&-70368744181761) != 0 || (int64((_la-595)) & ^0x3f) == 0 && ((int64(1)<<(_la-595))&-35184405643265) != 0 || (int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-288308991769968705) != 0 || (int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-3458764513820540929) != 0 || (int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-1) != 0 || (int64((_la-852)) & ^0x3f) == 0 && ((int64(1)<<(_la-852))&-1) != 0 || (int64((_la-916)) & ^0x3f) == 0 && ((int64(1)<<(_la-916))&-1) != 0 || (int64((_la-980)) & ^0x3f) == 0 && ((int64(1)<<(_la-980))&-1) != 0 || (int64((_la-1044)) & ^0x3f) == 0 && ((int64(1)<<(_la-1044))&18014398509481983) != 0 || (int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&25807552513) != 0 {
			{
				p.SetState(349)

				var _x = p.Uid()

				localctx.(*UniqueKeyTableConstraintContext).index = _x
			}

		}
		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserUSING {
			{
				p.SetState(352)
				p.IndexType()
			}

		}
		{
			p.SetState(355)
			p.IndexColumnNames()
		}
		p.SetState(359)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserIGNORED || _la == StmtParserNOT || _la == StmtParserUSING || _la == StmtParserWITH || _la == StmtParserCLUSTERING || _la == StmtParserCOMMENT || _la == StmtParserINVISIBLE || _la == StmtParserKEY_BLOCK_SIZE || _la == StmtParserVISIBLE || _la == StmtParserENGINE_ATTRIBUTE || _la == StmtParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(356)
				p.IndexOption()
			}

			p.SetState(361)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewForeignKeyTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(366)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCONSTRAINT {
			{
				p.SetState(362)
				p.Match(StmtParserCONSTRAINT)
			}
			p.SetState(364)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72129216912687104) != 0 || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&73333234766712913) != 0 || (int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&67175041) != 0 || (int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17174494689) != 0 || (int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-137438953473) != 0 || (int64((_la-339)) & ^0x3f) == 0 && ((int64(1)<<(_la-339))&-1) != 0 || (int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&-262145) != 0 || (int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&-1) != 0 || (int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&-70368744181761) != 0 || (int64((_la-595)) & ^0x3f) == 0 && ((int64(1)<<(_la-595))&-35184405643265) != 0 || (int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-288308991769968705) != 0 || (int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-3458764513820540929) != 0 || (int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-1) != 0 || (int64((_la-852)) & ^0x3f) == 0 && ((int64(1)<<(_la-852))&-1) != 0 || (int64((_la-916)) & ^0x3f) == 0 && ((int64(1)<<(_la-916))&-1) != 0 || (int64((_la-980)) & ^0x3f) == 0 && ((int64(1)<<(_la-980))&-1) != 0 || (int64((_la-1044)) & ^0x3f) == 0 && ((int64(1)<<(_la-1044))&18014398509481983) != 0 || (int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&25807552513) != 0 {
				{
					p.SetState(363)

					var _x = p.Uid()

					localctx.(*ForeignKeyTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(368)
			p.Match(StmtParserFOREIGN)
		}
		{
			p.SetState(369)
			p.Match(StmtParserKEY)
		}
		p.SetState(371)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72129216912687104) != 0 || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&73333234766712913) != 0 || (int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&67175041) != 0 || (int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17174494689) != 0 || (int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-137438953473) != 0 || (int64((_la-339)) & ^0x3f) == 0 && ((int64(1)<<(_la-339))&-1) != 0 || (int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&-262145) != 0 || (int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&-1) != 0 || (int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&-70368744181761) != 0 || (int64((_la-595)) & ^0x3f) == 0 && ((int64(1)<<(_la-595))&-35184405643265) != 0 || (int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-288308991769968705) != 0 || (int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-3458764513820540929) != 0 || (int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-1) != 0 || (int64((_la-852)) & ^0x3f) == 0 && ((int64(1)<<(_la-852))&-1) != 0 || (int64((_la-916)) & ^0x3f) == 0 && ((int64(1)<<(_la-916))&-1) != 0 || (int64((_la-980)) & ^0x3f) == 0 && ((int64(1)<<(_la-980))&-1) != 0 || (int64((_la-1044)) & ^0x3f) == 0 && ((int64(1)<<(_la-1044))&18014398509481983) != 0 || (int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&25807552513) != 0 {
			{
				p.SetState(370)

				var _x = p.Uid()

				localctx.(*ForeignKeyTableConstraintContext).index = _x
			}

		}
		{
			p.SetState(373)
			p.IndexColumnNames()
		}
		{
			p.SetState(374)
			p.ReferenceDefinition()
		}

	case 4:
		localctx = NewCheckTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(380)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCONSTRAINT {
			{
				p.SetState(376)
				p.Match(StmtParserCONSTRAINT)
			}
			p.SetState(378)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72129216912687104) != 0 || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&73333234766712913) != 0 || (int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&67175041) != 0 || (int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17174494689) != 0 || (int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-137438953473) != 0 || (int64((_la-339)) & ^0x3f) == 0 && ((int64(1)<<(_la-339))&-1) != 0 || (int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&-262145) != 0 || (int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&-1) != 0 || (int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&-70368744181761) != 0 || (int64((_la-595)) & ^0x3f) == 0 && ((int64(1)<<(_la-595))&-35184405643265) != 0 || (int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-288308991769968705) != 0 || (int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-3458764513820540929) != 0 || (int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-1) != 0 || (int64((_la-852)) & ^0x3f) == 0 && ((int64(1)<<(_la-852))&-1) != 0 || (int64((_la-916)) & ^0x3f) == 0 && ((int64(1)<<(_la-916))&-1) != 0 || (int64((_la-980)) & ^0x3f) == 0 && ((int64(1)<<(_la-980))&-1) != 0 || (int64((_la-1044)) & ^0x3f) == 0 && ((int64(1)<<(_la-1044))&18014398509481983) != 0 || (int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&25807552513) != 0 {
				{
					p.SetState(377)

					var _x = p.Uid()

					localctx.(*CheckTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(382)
			p.Match(StmtParserCHECK)
		}
		{
			p.SetState(383)
			p.Match(StmtParserLR_BRACKET)
		}
		{
			p.SetState(384)
			p.expression(0)
		}
		{
			p.SetState(385)
			p.Match(StmtParserRR_BRACKET)
		}

	}

	return localctx
}

// IReferenceDefinitionContext is an interface to support dynamic dispatch.
type IReferenceDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMatchType returns the matchType token.
	GetMatchType() antlr.Token

	// SetMatchType sets the matchType token.
	SetMatchType(antlr.Token)

	// IsReferenceDefinitionContext differentiates from other interfaces.
	IsReferenceDefinitionContext()
}

type ReferenceDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	matchType antlr.Token
}

func NewEmptyReferenceDefinitionContext() *ReferenceDefinitionContext {
	var p = new(ReferenceDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_referenceDefinition
	return p
}

func (*ReferenceDefinitionContext) IsReferenceDefinitionContext() {}

func NewReferenceDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceDefinitionContext {
	var p = new(ReferenceDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_referenceDefinition

	return p
}

func (s *ReferenceDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceDefinitionContext) GetMatchType() antlr.Token { return s.matchType }

func (s *ReferenceDefinitionContext) SetMatchType(v antlr.Token) { s.matchType = v }

func (s *ReferenceDefinitionContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(StmtParserREFERENCES, 0)
}

func (s *ReferenceDefinitionContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ReferenceDefinitionContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *ReferenceDefinitionContext) MATCH() antlr.TerminalNode {
	return s.GetToken(StmtParserMATCH, 0)
}

func (s *ReferenceDefinitionContext) ReferenceAction() IReferenceActionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceActionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceActionContext)
}

func (s *ReferenceDefinitionContext) FULL() antlr.TerminalNode {
	return s.GetToken(StmtParserFULL, 0)
}

func (s *ReferenceDefinitionContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTIAL, 0)
}

func (s *ReferenceDefinitionContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(StmtParserSIMPLE, 0)
}

func (s *ReferenceDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterReferenceDefinition(s)
	}
}

func (s *ReferenceDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitReferenceDefinition(s)
	}
}

func (p *StmtParser) ReferenceDefinition() (localctx IReferenceDefinitionContext) {
	this := p
	_ = this

	localctx = NewReferenceDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, StmtParserRULE_referenceDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(389)
		p.Match(StmtParserREFERENCES)
	}
	{
		p.SetState(390)
		p.TableName()
	}
	p.SetState(392)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserLR_BRACKET {
		{
			p.SetState(391)
			p.IndexColumnNames()
		}

	}
	p.SetState(396)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserMATCH {
		{
			p.SetState(394)
			p.Match(StmtParserMATCH)
		}
		{
			p.SetState(395)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ReferenceDefinitionContext).matchType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserFULL || _la == StmtParserPARTIAL || _la == StmtParserSIMPLE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ReferenceDefinitionContext).matchType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(399)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(398)
			p.ReferenceAction()
		}

	}

	return localctx
}

// IReferenceActionContext is an interface to support dynamic dispatch.
type IReferenceActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOnDelete returns the onDelete rule contexts.
	GetOnDelete() IReferenceControlTypeContext

	// GetOnUpdate returns the onUpdate rule contexts.
	GetOnUpdate() IReferenceControlTypeContext

	// SetOnDelete sets the onDelete rule contexts.
	SetOnDelete(IReferenceControlTypeContext)

	// SetOnUpdate sets the onUpdate rule contexts.
	SetOnUpdate(IReferenceControlTypeContext)

	// IsReferenceActionContext differentiates from other interfaces.
	IsReferenceActionContext()
}

type ReferenceActionContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	onDelete IReferenceControlTypeContext
	onUpdate IReferenceControlTypeContext
}

func NewEmptyReferenceActionContext() *ReferenceActionContext {
	var p = new(ReferenceActionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_referenceAction
	return p
}

func (*ReferenceActionContext) IsReferenceActionContext() {}

func NewReferenceActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceActionContext {
	var p = new(ReferenceActionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_referenceAction

	return p
}

func (s *ReferenceActionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceActionContext) GetOnDelete() IReferenceControlTypeContext { return s.onDelete }

func (s *ReferenceActionContext) GetOnUpdate() IReferenceControlTypeContext { return s.onUpdate }

func (s *ReferenceActionContext) SetOnDelete(v IReferenceControlTypeContext) { s.onDelete = v }

func (s *ReferenceActionContext) SetOnUpdate(v IReferenceControlTypeContext) { s.onUpdate = v }

func (s *ReferenceActionContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(StmtParserON)
}

func (s *ReferenceActionContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserON, i)
}

func (s *ReferenceActionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(StmtParserDELETE, 0)
}

func (s *ReferenceActionContext) AllReferenceControlType() []IReferenceControlTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReferenceControlTypeContext); ok {
			len++
		}
	}

	tst := make([]IReferenceControlTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReferenceControlTypeContext); ok {
			tst[i] = t.(IReferenceControlTypeContext)
			i++
		}
	}

	return tst
}

func (s *ReferenceActionContext) ReferenceControlType(i int) IReferenceControlTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceControlTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceControlTypeContext)
}

func (s *ReferenceActionContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(StmtParserUPDATE, 0)
}

func (s *ReferenceActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterReferenceAction(s)
	}
}

func (s *ReferenceActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitReferenceAction(s)
	}
}

func (p *StmtParser) ReferenceAction() (localctx IReferenceActionContext) {
	this := p
	_ = this

	localctx = NewReferenceActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, StmtParserRULE_referenceAction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(417)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(401)
			p.Match(StmtParserON)
		}
		{
			p.SetState(402)
			p.Match(StmtParserDELETE)
		}
		{
			p.SetState(403)

			var _x = p.ReferenceControlType()

			localctx.(*ReferenceActionContext).onDelete = _x
		}
		p.SetState(407)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(404)
				p.Match(StmtParserON)
			}
			{
				p.SetState(405)
				p.Match(StmtParserUPDATE)
			}
			{
				p.SetState(406)

				var _x = p.ReferenceControlType()

				localctx.(*ReferenceActionContext).onUpdate = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(409)
			p.Match(StmtParserON)
		}
		{
			p.SetState(410)
			p.Match(StmtParserUPDATE)
		}
		{
			p.SetState(411)

			var _x = p.ReferenceControlType()

			localctx.(*ReferenceActionContext).onUpdate = _x
		}
		p.SetState(415)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(412)
				p.Match(StmtParserON)
			}
			{
				p.SetState(413)
				p.Match(StmtParserDELETE)
			}
			{
				p.SetState(414)

				var _x = p.ReferenceControlType()

				localctx.(*ReferenceActionContext).onDelete = _x
			}

		}

	}

	return localctx
}

// IReferenceControlTypeContext is an interface to support dynamic dispatch.
type IReferenceControlTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceControlTypeContext differentiates from other interfaces.
	IsReferenceControlTypeContext()
}

type ReferenceControlTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceControlTypeContext() *ReferenceControlTypeContext {
	var p = new(ReferenceControlTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_referenceControlType
	return p
}

func (*ReferenceControlTypeContext) IsReferenceControlTypeContext() {}

func NewReferenceControlTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceControlTypeContext {
	var p = new(ReferenceControlTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_referenceControlType

	return p
}

func (s *ReferenceControlTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceControlTypeContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(StmtParserRESTRICT, 0)
}

func (s *ReferenceControlTypeContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(StmtParserCASCADE, 0)
}

func (s *ReferenceControlTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(StmtParserSET, 0)
}

func (s *ReferenceControlTypeContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNULL_LITERAL, 0)
}

func (s *ReferenceControlTypeContext) NO() antlr.TerminalNode {
	return s.GetToken(StmtParserNO, 0)
}

func (s *ReferenceControlTypeContext) ACTION() antlr.TerminalNode {
	return s.GetToken(StmtParserACTION, 0)
}

func (s *ReferenceControlTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceControlTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceControlTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterReferenceControlType(s)
	}
}

func (s *ReferenceControlTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitReferenceControlType(s)
	}
}

func (p *StmtParser) ReferenceControlType() (localctx IReferenceControlTypeContext) {
	this := p
	_ = this

	localctx = NewReferenceControlTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, StmtParserRULE_referenceControlType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(425)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case StmtParserRESTRICT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(419)
			p.Match(StmtParserRESTRICT)
		}

	case StmtParserCASCADE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(420)
			p.Match(StmtParserCASCADE)
		}

	case StmtParserSET:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(421)
			p.Match(StmtParserSET)
		}
		{
			p.SetState(422)
			p.Match(StmtParserNULL_LITERAL)
		}

	case StmtParserNO:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(423)
			p.Match(StmtParserNO)
		}
		{
			p.SetState(424)
			p.Match(StmtParserACTION)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIndexColumnDefinitionContext is an interface to support dynamic dispatch.
type IIndexColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexColumnDefinitionContext differentiates from other interfaces.
	IsIndexColumnDefinitionContext()
}

type IndexColumnDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexColumnDefinitionContext() *IndexColumnDefinitionContext {
	var p = new(IndexColumnDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_indexColumnDefinition
	return p
}

func (*IndexColumnDefinitionContext) IsIndexColumnDefinitionContext() {}

func NewIndexColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnDefinitionContext {
	var p = new(IndexColumnDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_indexColumnDefinition

	return p
}

func (s *IndexColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnDefinitionContext) CopyFrom(ctx *IndexColumnDefinitionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *IndexColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SpecialIndexDeclarationContext struct {
	*IndexColumnDefinitionContext
	indexFormat antlr.Token
}

func NewSpecialIndexDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialIndexDeclarationContext {
	var p = new(SpecialIndexDeclarationContext)

	p.IndexColumnDefinitionContext = NewEmptyIndexColumnDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IndexColumnDefinitionContext))

	return p
}

func (s *SpecialIndexDeclarationContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *SpecialIndexDeclarationContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *SpecialIndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialIndexDeclarationContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *SpecialIndexDeclarationContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserFULLTEXT, 0)
}

func (s *SpecialIndexDeclarationContext) SPATIAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSPATIAL, 0)
}

func (s *SpecialIndexDeclarationContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SpecialIndexDeclarationContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *SpecialIndexDeclarationContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *SpecialIndexDeclarationContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StmtParserINDEX, 0)
}

func (s *SpecialIndexDeclarationContext) KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY, 0)
}

func (s *SpecialIndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSpecialIndexDeclaration(s)
	}
}

func (s *SpecialIndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSpecialIndexDeclaration(s)
	}
}

type SimpleIndexDeclarationContext struct {
	*IndexColumnDefinitionContext
	indexFormat antlr.Token
}

func NewSimpleIndexDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleIndexDeclarationContext {
	var p = new(SimpleIndexDeclarationContext)

	p.IndexColumnDefinitionContext = NewEmptyIndexColumnDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IndexColumnDefinitionContext))

	return p
}

func (s *SimpleIndexDeclarationContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *SimpleIndexDeclarationContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *SimpleIndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIndexDeclarationContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *SimpleIndexDeclarationContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StmtParserINDEX, 0)
}

func (s *SimpleIndexDeclarationContext) KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY, 0)
}

func (s *SimpleIndexDeclarationContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SimpleIndexDeclarationContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *SimpleIndexDeclarationContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleIndexDeclarationContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *SimpleIndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSimpleIndexDeclaration(s)
	}
}

func (s *SimpleIndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSimpleIndexDeclaration(s)
	}
}

func (p *StmtParser) IndexColumnDefinition() (localctx IIndexColumnDefinitionContext) {
	this := p
	_ = this

	localctx = NewIndexColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, StmtParserRULE_indexColumnDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(455)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case StmtParserINDEX, StmtParserKEY:
		localctx = NewSimpleIndexDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(427)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SimpleIndexDeclarationContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserINDEX || _la == StmtParserKEY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SimpleIndexDeclarationContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(429)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72129216912687104) != 0 || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&73333234766712913) != 0 || (int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&67175041) != 0 || (int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17174494689) != 0 || (int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-137438953473) != 0 || (int64((_la-339)) & ^0x3f) == 0 && ((int64(1)<<(_la-339))&-1) != 0 || (int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&-262145) != 0 || (int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&-1) != 0 || (int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&-70368744181761) != 0 || (int64((_la-595)) & ^0x3f) == 0 && ((int64(1)<<(_la-595))&-35184405643265) != 0 || (int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-288308991769968705) != 0 || (int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-3458764513820540929) != 0 || (int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-1) != 0 || (int64((_la-852)) & ^0x3f) == 0 && ((int64(1)<<(_la-852))&-1) != 0 || (int64((_la-916)) & ^0x3f) == 0 && ((int64(1)<<(_la-916))&-1) != 0 || (int64((_la-980)) & ^0x3f) == 0 && ((int64(1)<<(_la-980))&-1) != 0 || (int64((_la-1044)) & ^0x3f) == 0 && ((int64(1)<<(_la-1044))&18014398509481983) != 0 || (int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&25807552513) != 0 {
			{
				p.SetState(428)
				p.Uid()
			}

		}
		p.SetState(432)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserUSING {
			{
				p.SetState(431)
				p.IndexType()
			}

		}
		{
			p.SetState(434)
			p.IndexColumnNames()
		}
		p.SetState(438)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserIGNORED || _la == StmtParserNOT || _la == StmtParserUSING || _la == StmtParserWITH || _la == StmtParserCLUSTERING || _la == StmtParserCOMMENT || _la == StmtParserINVISIBLE || _la == StmtParserKEY_BLOCK_SIZE || _la == StmtParserVISIBLE || _la == StmtParserENGINE_ATTRIBUTE || _la == StmtParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(435)
				p.IndexOption()
			}

			p.SetState(440)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case StmtParserFULLTEXT, StmtParserSPATIAL:
		localctx = NewSpecialIndexDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(441)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserFULLTEXT || _la == StmtParserSPATIAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(443)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserINDEX || _la == StmtParserKEY {
			{
				p.SetState(442)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SpecialIndexDeclarationContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == StmtParserINDEX || _la == StmtParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SpecialIndexDeclarationContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(446)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72129216912687104) != 0 || (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&73333234766712913) != 0 || (int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&67175041) != 0 || (int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17174494689) != 0 || (int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&-137438953473) != 0 || (int64((_la-339)) & ^0x3f) == 0 && ((int64(1)<<(_la-339))&-1) != 0 || (int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&-262145) != 0 || (int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&-1) != 0 || (int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&-70368744181761) != 0 || (int64((_la-595)) & ^0x3f) == 0 && ((int64(1)<<(_la-595))&-35184405643265) != 0 || (int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-288308991769968705) != 0 || (int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-3458764513820540929) != 0 || (int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-1) != 0 || (int64((_la-852)) & ^0x3f) == 0 && ((int64(1)<<(_la-852))&-1) != 0 || (int64((_la-916)) & ^0x3f) == 0 && ((int64(1)<<(_la-916))&-1) != 0 || (int64((_la-980)) & ^0x3f) == 0 && ((int64(1)<<(_la-980))&-1) != 0 || (int64((_la-1044)) & ^0x3f) == 0 && ((int64(1)<<(_la-1044))&18014398509481983) != 0 || (int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&25807552513) != 0 {
			{
				p.SetState(445)
				p.Uid()
			}

		}
		{
			p.SetState(448)
			p.IndexColumnNames()
		}
		p.SetState(452)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserIGNORED || _la == StmtParserNOT || _la == StmtParserUSING || _la == StmtParserWITH || _la == StmtParserCLUSTERING || _la == StmtParserCOMMENT || _la == StmtParserINVISIBLE || _la == StmtParserKEY_BLOCK_SIZE || _la == StmtParserVISIBLE || _la == StmtParserENGINE_ATTRIBUTE || _la == StmtParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(449)
				p.IndexOption()
			}

			p.SetState(454)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITableOptionContext is an interface to support dynamic dispatch.
type ITableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableOptionContext differentiates from other interfaces.
	IsTableOptionContext()
}

type TableOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOptionContext() *TableOptionContext {
	var p = new(TableOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_tableOption
	return p
}

func (*TableOptionContext) IsTableOptionContext() {}

func NewTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOptionContext {
	var p = new(TableOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_tableOption

	return p
}

func (s *TableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOptionContext) CopyFrom(ctx *TableOptionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableOptionEngineContext struct {
	*TableOptionContext
}

func NewTableOptionEngineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEngineContext {
	var p = new(TableOptionEngineContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEngineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEngineContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(StmtParserENGINE, 0)
}

func (s *TableOptionEngineContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEngineContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *TableOptionEngineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionEngine(s)
	}
}

func (s *TableOptionEngineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionEngine(s)
	}
}

type TableOptionMaxRowsContext struct {
	*TableOptionContext
}

func NewTableOptionMaxRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionMaxRowsContext {
	var p = new(TableOptionMaxRowsContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionMaxRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionMaxRowsContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(StmtParserMAX_ROWS, 0)
}

func (s *TableOptionMaxRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionMaxRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionMaxRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionMaxRows(s)
	}
}

func (s *TableOptionMaxRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionMaxRows(s)
	}
}

type TableOptionCollateContext struct {
	*TableOptionContext
}

func NewTableOptionCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCollateContext {
	var p = new(TableOptionCollateContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCollateContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLLATE, 0)
}

func (s *TableOptionCollateContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *TableOptionCollateContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *TableOptionCollateContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionCollate(s)
	}
}

func (s *TableOptionCollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionCollate(s)
	}
}

type TableOptionPersistentContext struct {
	*TableOptionContext
	extBoolValue antlr.Token
}

func NewTableOptionPersistentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPersistentContext {
	var p = new(TableOptionPersistentContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPersistentContext) GetExtBoolValue() antlr.Token { return s.extBoolValue }

func (s *TableOptionPersistentContext) SetExtBoolValue(v antlr.Token) { s.extBoolValue = v }

func (s *TableOptionPersistentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPersistentContext) STATS_PERSISTENT() antlr.TerminalNode {
	return s.GetToken(StmtParserSTATS_PERSISTENT, 0)
}

func (s *TableOptionPersistentContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *TableOptionPersistentContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserZERO_DECIMAL, 0)
}

func (s *TableOptionPersistentContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserONE_DECIMAL, 0)
}

func (s *TableOptionPersistentContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPersistentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionPersistent(s)
	}
}

func (s *TableOptionPersistentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionPersistent(s)
	}
}

type TableOptionTablespaceContext struct {
	*TableOptionContext
}

func NewTableOptionTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionTablespaceContext {
	var p = new(TableOptionTablespaceContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(StmtParserTABLESPACE, 0)
}

func (s *TableOptionTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *TableOptionTablespaceContext) TablespaceStorage() ITablespaceStorageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceStorageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceStorageContext)
}

func (s *TableOptionTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionTablespace(s)
	}
}

func (s *TableOptionTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionTablespace(s)
	}
}

type TableOptionAutoextendSizeContext struct {
	*TableOptionContext
}

func NewTableOptionAutoextendSizeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionAutoextendSizeContext {
	var p = new(TableOptionAutoextendSizeContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionAutoextendSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionAutoextendSizeContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserAUTOEXTEND_SIZE, 0)
}

func (s *TableOptionAutoextendSizeContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionAutoextendSizeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionAutoextendSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionAutoextendSize(s)
	}
}

func (s *TableOptionAutoextendSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionAutoextendSize(s)
	}
}

type TableOptionStartTransactionContext struct {
	*TableOptionContext
}

func NewTableOptionStartTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionStartTransactionContext {
	var p = new(TableOptionStartTransactionContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionStartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionStartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(StmtParserSTART, 0)
}

func (s *TableOptionStartTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(StmtParserTRANSACTION, 0)
}

func (s *TableOptionStartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionStartTransaction(s)
	}
}

func (s *TableOptionStartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionStartTransaction(s)
	}
}

type TableOptionPackKeysContext struct {
	*TableOptionContext
	extBoolValue antlr.Token
}

func NewTableOptionPackKeysContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPackKeysContext {
	var p = new(TableOptionPackKeysContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPackKeysContext) GetExtBoolValue() antlr.Token { return s.extBoolValue }

func (s *TableOptionPackKeysContext) SetExtBoolValue(v antlr.Token) { s.extBoolValue = v }

func (s *TableOptionPackKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPackKeysContext) PACK_KEYS() antlr.TerminalNode {
	return s.GetToken(StmtParserPACK_KEYS, 0)
}

func (s *TableOptionPackKeysContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserZERO_DECIMAL, 0)
}

func (s *TableOptionPackKeysContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserONE_DECIMAL, 0)
}

func (s *TableOptionPackKeysContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *TableOptionPackKeysContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPackKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionPackKeys(s)
	}
}

func (s *TableOptionPackKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionPackKeys(s)
	}
}

type TableOptionPasswordContext struct {
	*TableOptionContext
}

func NewTableOptionPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPasswordContext {
	var p = new(TableOptionPasswordContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPasswordContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(StmtParserPASSWORD, 0)
}

func (s *TableOptionPasswordContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *TableOptionPasswordContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionPassword(s)
	}
}

func (s *TableOptionPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionPassword(s)
	}
}

type TableOptionUnionContext struct {
	*TableOptionContext
}

func NewTableOptionUnionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionUnionContext {
	var p = new(TableOptionUnionContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionUnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionUnionContext) UNION() antlr.TerminalNode {
	return s.GetToken(StmtParserUNION, 0)
}

func (s *TableOptionUnionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *TableOptionUnionContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *TableOptionUnionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *TableOptionUnionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionUnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionUnion(s)
	}
}

func (s *TableOptionUnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionUnion(s)
	}
}

type TableOptionSamplePageContext struct {
	*TableOptionContext
	extValue antlr.Token
}

func NewTableOptionSamplePageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionSamplePageContext {
	var p = new(TableOptionSamplePageContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionSamplePageContext) GetExtValue() antlr.Token { return s.extValue }

func (s *TableOptionSamplePageContext) SetExtValue(v antlr.Token) { s.extValue = v }

func (s *TableOptionSamplePageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionSamplePageContext) STATS_SAMPLE_PAGES() antlr.TerminalNode {
	return s.GetToken(StmtParserSTATS_SAMPLE_PAGES, 0)
}

func (s *TableOptionSamplePageContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *TableOptionSamplePageContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserDECIMAL_LITERAL, 0)
}

func (s *TableOptionSamplePageContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionSamplePageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionSamplePage(s)
	}
}

func (s *TableOptionSamplePageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionSamplePage(s)
	}
}

type TableOptionCharsetContext struct {
	*TableOptionContext
}

func NewTableOptionCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCharsetContext {
	var p = new(TableOptionCharsetContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCharsetContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *TableOptionCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *TableOptionCharsetContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(StmtParserDEFAULT)
}

func (s *TableOptionCharsetContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, i)
}

func (s *TableOptionCharsetContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionCharset(s)
	}
}

func (s *TableOptionCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionCharset(s)
	}
}

type TableOptionIndexDirectoryContext struct {
	*TableOptionContext
}

func NewTableOptionIndexDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionIndexDirectoryContext {
	var p = new(TableOptionIndexDirectoryContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionIndexDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionIndexDirectoryContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StmtParserINDEX, 0)
}

func (s *TableOptionIndexDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(StmtParserDIRECTORY, 0)
}

func (s *TableOptionIndexDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *TableOptionIndexDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionIndexDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionIndexDirectory(s)
	}
}

func (s *TableOptionIndexDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionIndexDirectory(s)
	}
}

type TableOptionTableTypeContext struct {
	*TableOptionContext
}

func NewTableOptionTableTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionTableTypeContext {
	var p = new(TableOptionTableTypeContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionTableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionTableTypeContext) TABLE_TYPE() antlr.TerminalNode {
	return s.GetToken(StmtParserTABLE_TYPE, 0)
}

func (s *TableOptionTableTypeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionTableTypeContext) TableType() ITableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableTypeContext)
}

func (s *TableOptionTableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionTableType(s)
	}
}

func (s *TableOptionTableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionTableType(s)
	}
}

type TableOptionKeyBlockSizeContext struct {
	*TableOptionContext
}

func NewTableOptionKeyBlockSizeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionKeyBlockSizeContext {
	var p = new(TableOptionKeyBlockSizeContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionKeyBlockSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionKeyBlockSizeContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY_BLOCK_SIZE, 0)
}

func (s *TableOptionKeyBlockSizeContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *TableOptionKeyBlockSizeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionKeyBlockSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionKeyBlockSize(s)
	}
}

func (s *TableOptionKeyBlockSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionKeyBlockSize(s)
	}
}

type TableOptionEncryptionContext struct {
	*TableOptionContext
}

func NewTableOptionEncryptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEncryptionContext {
	var p = new(TableOptionEncryptionContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEncryptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEncryptionContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(StmtParserENCRYPTION, 0)
}

func (s *TableOptionEncryptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *TableOptionEncryptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEncryptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionEncryption(s)
	}
}

func (s *TableOptionEncryptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionEncryption(s)
	}
}

type TableOptionDataDirectoryContext struct {
	*TableOptionContext
}

func NewTableOptionDataDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionDataDirectoryContext {
	var p = new(TableOptionDataDirectoryContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionDataDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionDataDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(StmtParserDIRECTORY, 0)
}

func (s *TableOptionDataDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *TableOptionDataDirectoryContext) DATA() antlr.TerminalNode {
	return s.GetToken(StmtParserDATA, 0)
}

func (s *TableOptionDataDirectoryContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StmtParserINDEX, 0)
}

func (s *TableOptionDataDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionDataDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionDataDirectory(s)
	}
}

func (s *TableOptionDataDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionDataDirectory(s)
	}
}

type TableOptionRecalculationContext struct {
	*TableOptionContext
	extBoolValue antlr.Token
}

func NewTableOptionRecalculationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionRecalculationContext {
	var p = new(TableOptionRecalculationContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionRecalculationContext) GetExtBoolValue() antlr.Token { return s.extBoolValue }

func (s *TableOptionRecalculationContext) SetExtBoolValue(v antlr.Token) { s.extBoolValue = v }

func (s *TableOptionRecalculationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionRecalculationContext) STATS_AUTO_RECALC() antlr.TerminalNode {
	return s.GetToken(StmtParserSTATS_AUTO_RECALC, 0)
}

func (s *TableOptionRecalculationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *TableOptionRecalculationContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserZERO_DECIMAL, 0)
}

func (s *TableOptionRecalculationContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserONE_DECIMAL, 0)
}

func (s *TableOptionRecalculationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionRecalculationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionRecalculation(s)
	}
}

func (s *TableOptionRecalculationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionRecalculation(s)
	}
}

type TableOptionAutoIncrementContext struct {
	*TableOptionContext
}

func NewTableOptionAutoIncrementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionAutoIncrementContext {
	var p = new(TableOptionAutoIncrementContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionAutoIncrementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionAutoIncrementContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(StmtParserAUTO_INCREMENT, 0)
}

func (s *TableOptionAutoIncrementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionAutoIncrementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionAutoIncrementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionAutoIncrement(s)
	}
}

func (s *TableOptionAutoIncrementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionAutoIncrement(s)
	}
}

type TableOptionChecksumContext struct {
	*TableOptionContext
	boolValue antlr.Token
}

func NewTableOptionChecksumContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionChecksumContext {
	var p = new(TableOptionChecksumContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionChecksumContext) GetBoolValue() antlr.Token { return s.boolValue }

func (s *TableOptionChecksumContext) SetBoolValue(v antlr.Token) { s.boolValue = v }

func (s *TableOptionChecksumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionChecksumContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(StmtParserCHECKSUM, 0)
}

func (s *TableOptionChecksumContext) PAGE_CHECKSUM() antlr.TerminalNode {
	return s.GetToken(StmtParserPAGE_CHECKSUM, 0)
}

func (s *TableOptionChecksumContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserZERO_DECIMAL, 0)
}

func (s *TableOptionChecksumContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserONE_DECIMAL, 0)
}

func (s *TableOptionChecksumContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionChecksumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionChecksum(s)
	}
}

func (s *TableOptionChecksumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionChecksum(s)
	}
}

type TableOptionDelayContext struct {
	*TableOptionContext
	boolValue antlr.Token
}

func NewTableOptionDelayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionDelayContext {
	var p = new(TableOptionDelayContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionDelayContext) GetBoolValue() antlr.Token { return s.boolValue }

func (s *TableOptionDelayContext) SetBoolValue(v antlr.Token) { s.boolValue = v }

func (s *TableOptionDelayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionDelayContext) DELAY_KEY_WRITE() antlr.TerminalNode {
	return s.GetToken(StmtParserDELAY_KEY_WRITE, 0)
}

func (s *TableOptionDelayContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserZERO_DECIMAL, 0)
}

func (s *TableOptionDelayContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserONE_DECIMAL, 0)
}

func (s *TableOptionDelayContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionDelayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionDelay(s)
	}
}

func (s *TableOptionDelayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionDelay(s)
	}
}

type TableOptionConnectionContext struct {
	*TableOptionContext
}

func NewTableOptionConnectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionConnectionContext {
	var p = new(TableOptionConnectionContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionConnectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionConnectionContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(StmtParserCONNECTION, 0)
}

func (s *TableOptionConnectionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *TableOptionConnectionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionConnectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionConnection(s)
	}
}

func (s *TableOptionConnectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionConnection(s)
	}
}

type TableOptionSecondaryEngineAttributeContext struct {
	*TableOptionContext
}

func NewTableOptionSecondaryEngineAttributeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionSecondaryEngineAttributeContext {
	var p = new(TableOptionSecondaryEngineAttributeContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionSecondaryEngineAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionSecondaryEngineAttributeContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *TableOptionSecondaryEngineAttributeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *TableOptionSecondaryEngineAttributeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionSecondaryEngineAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionSecondaryEngineAttribute(s)
	}
}

func (s *TableOptionSecondaryEngineAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionSecondaryEngineAttribute(s)
	}
}

type TableOptionCommentContext struct {
	*TableOptionContext
}

func NewTableOptionCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCommentContext {
	var p = new(TableOptionCommentContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMENT, 0)
}

func (s *TableOptionCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *TableOptionCommentContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionComment(s)
	}
}

func (s *TableOptionCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionComment(s)
	}
}

type TableOptionAverageContext struct {
	*TableOptionContext
}

func NewTableOptionAverageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionAverageContext {
	var p = new(TableOptionAverageContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionAverageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionAverageContext) AVG_ROW_LENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserAVG_ROW_LENGTH, 0)
}

func (s *TableOptionAverageContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionAverageContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionAverageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionAverage(s)
	}
}

func (s *TableOptionAverageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionAverage(s)
	}
}

type TableOptionRowFormatContext struct {
	*TableOptionContext
	rowFormat antlr.Token
}

func NewTableOptionRowFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionRowFormatContext {
	var p = new(TableOptionRowFormatContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionRowFormatContext) GetRowFormat() antlr.Token { return s.rowFormat }

func (s *TableOptionRowFormatContext) SetRowFormat(v antlr.Token) { s.rowFormat = v }

func (s *TableOptionRowFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionRowFormatContext) ROW_FORMAT() antlr.TerminalNode {
	return s.GetToken(StmtParserROW_FORMAT, 0)
}

func (s *TableOptionRowFormatContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *TableOptionRowFormatContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(StmtParserDYNAMIC, 0)
}

func (s *TableOptionRowFormatContext) FIXED() antlr.TerminalNode {
	return s.GetToken(StmtParserFIXED, 0)
}

func (s *TableOptionRowFormatContext) COMPRESSED() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMPRESSED, 0)
}

func (s *TableOptionRowFormatContext) REDUNDANT() antlr.TerminalNode {
	return s.GetToken(StmtParserREDUNDANT, 0)
}

func (s *TableOptionRowFormatContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMPACT, 0)
}

func (s *TableOptionRowFormatContext) ID() antlr.TerminalNode {
	return s.GetToken(StmtParserID, 0)
}

func (s *TableOptionRowFormatContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionRowFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionRowFormat(s)
	}
}

func (s *TableOptionRowFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionRowFormat(s)
	}
}

type TableOptionCompressionContext struct {
	*TableOptionContext
}

func NewTableOptionCompressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCompressionContext {
	var p = new(TableOptionCompressionContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCompressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCompressionContext) COMPRESSION() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMPRESSION, 0)
}

func (s *TableOptionCompressionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *TableOptionCompressionContext) ID() antlr.TerminalNode {
	return s.GetToken(StmtParserID, 0)
}

func (s *TableOptionCompressionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCompressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionCompression(s)
	}
}

func (s *TableOptionCompressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionCompression(s)
	}
}

type TableOptionInsertMethodContext struct {
	*TableOptionContext
	insertMethod antlr.Token
}

func NewTableOptionInsertMethodContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionInsertMethodContext {
	var p = new(TableOptionInsertMethodContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionInsertMethodContext) GetInsertMethod() antlr.Token { return s.insertMethod }

func (s *TableOptionInsertMethodContext) SetInsertMethod(v antlr.Token) { s.insertMethod = v }

func (s *TableOptionInsertMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionInsertMethodContext) INSERT_METHOD() antlr.TerminalNode {
	return s.GetToken(StmtParserINSERT_METHOD, 0)
}

func (s *TableOptionInsertMethodContext) NO() antlr.TerminalNode {
	return s.GetToken(StmtParserNO, 0)
}

func (s *TableOptionInsertMethodContext) FIRST() antlr.TerminalNode {
	return s.GetToken(StmtParserFIRST, 0)
}

func (s *TableOptionInsertMethodContext) LAST() antlr.TerminalNode {
	return s.GetToken(StmtParserLAST, 0)
}

func (s *TableOptionInsertMethodContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionInsertMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionInsertMethod(s)
	}
}

func (s *TableOptionInsertMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionInsertMethod(s)
	}
}

type TableOptionEngineAttributeContext struct {
	*TableOptionContext
}

func NewTableOptionEngineAttributeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEngineAttributeContext {
	var p = new(TableOptionEngineAttributeContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEngineAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEngineAttributeContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserENGINE_ATTRIBUTE, 0)
}

func (s *TableOptionEngineAttributeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *TableOptionEngineAttributeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEngineAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionEngineAttribute(s)
	}
}

func (s *TableOptionEngineAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionEngineAttribute(s)
	}
}

type TableOptionMinRowsContext struct {
	*TableOptionContext
}

func NewTableOptionMinRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionMinRowsContext {
	var p = new(TableOptionMinRowsContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionMinRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionMinRowsContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(StmtParserMIN_ROWS, 0)
}

func (s *TableOptionMinRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionMinRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionMinRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableOptionMinRows(s)
	}
}

func (s *TableOptionMinRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableOptionMinRows(s)
	}
}

func (p *StmtParser) TableOption() (localctx ITableOptionContext) {
	this := p
	_ = this

	localctx = NewTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, StmtParserRULE_tableOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(619)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableOptionEngineContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(457)
			p.Match(StmtParserENGINE)
		}
		p.SetState(459)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(458)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		p.SetState(462)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCONNECT || (int64((_la-767)) & ^0x3f) == 0 && ((int64(1)<<(_la-767))&4095) != 0 || (int64((_la-1138)) & ^0x3f) == 0 && ((int64(1)<<(_la-1138))&769) != 0 {
			{
				p.SetState(461)
				p.EngineName()
			}

		}

	case 2:
		localctx = NewTableOptionEngineAttributeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(464)
			p.Match(StmtParserENGINE_ATTRIBUTE)
		}
		p.SetState(466)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(465)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(468)
			p.Match(StmtParserSTRING_LITERAL)
		}

	case 3:
		localctx = NewTableOptionAutoextendSizeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(469)
			p.Match(StmtParserAUTOEXTEND_SIZE)
		}
		p.SetState(471)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(470)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(473)
			p.DecimalLiteral()
		}

	case 4:
		localctx = NewTableOptionAutoIncrementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(474)
			p.Match(StmtParserAUTO_INCREMENT)
		}
		p.SetState(476)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(475)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(478)
			p.DecimalLiteral()
		}

	case 5:
		localctx = NewTableOptionAverageContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(479)
			p.Match(StmtParserAVG_ROW_LENGTH)
		}
		p.SetState(481)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(480)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(483)
			p.DecimalLiteral()
		}

	case 6:
		localctx = NewTableOptionCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(485)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserDEFAULT {
			{
				p.SetState(484)
				p.Match(StmtParserDEFAULT)
			}

		}
		{
			p.SetState(487)
			p.CharSet()
		}
		p.SetState(489)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(488)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		p.SetState(493)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case StmtParserBINARY, StmtParserARMSCII8, StmtParserASCII, StmtParserBIG5, StmtParserCP1250, StmtParserCP1251, StmtParserCP1256, StmtParserCP1257, StmtParserCP850, StmtParserCP852, StmtParserCP866, StmtParserCP932, StmtParserDEC8, StmtParserEUCJPMS, StmtParserEUCKR, StmtParserGB18030, StmtParserGB2312, StmtParserGBK, StmtParserGEOSTD8, StmtParserGREEK, StmtParserHEBREW, StmtParserHP8, StmtParserKEYBCS2, StmtParserKOI8R, StmtParserKOI8U, StmtParserLATIN1, StmtParserLATIN2, StmtParserLATIN5, StmtParserLATIN7, StmtParserMACCE, StmtParserMACROMAN, StmtParserSJIS, StmtParserSWE7, StmtParserTIS620, StmtParserUCS2, StmtParserUJIS, StmtParserUTF16, StmtParserUTF16LE, StmtParserUTF32, StmtParserUTF8, StmtParserUTF8MB3, StmtParserUTF8MB4, StmtParserCHARSET_REVERSE_QOUTE_STRING, StmtParserSTRING_LITERAL:
			{
				p.SetState(491)
				p.CharsetName()
			}

		case StmtParserDEFAULT:
			{
				p.SetState(492)
				p.Match(StmtParserDEFAULT)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 7:
		localctx = NewTableOptionChecksumContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(495)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserCHECKSUM || _la == StmtParserPAGE_CHECKSUM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(497)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(496)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(499)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionChecksumContext).boolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserZERO_DECIMAL || _la == StmtParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionChecksumContext).boolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 8:
		localctx = NewTableOptionCollateContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		p.SetState(501)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserDEFAULT {
			{
				p.SetState(500)
				p.Match(StmtParserDEFAULT)
			}

		}
		{
			p.SetState(503)
			p.Match(StmtParserCOLLATE)
		}
		p.SetState(505)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(504)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(507)
			p.CollationName()
		}

	case 9:
		localctx = NewTableOptionCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(508)
			p.Match(StmtParserCOMMENT)
		}
		p.SetState(510)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(509)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(512)
			p.Match(StmtParserSTRING_LITERAL)
		}

	case 10:
		localctx = NewTableOptionCompressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(513)
			p.Match(StmtParserCOMPRESSION)
		}
		p.SetState(515)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(514)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(517)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserSTRING_LITERAL || _la == StmtParserID) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 11:
		localctx = NewTableOptionConnectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(518)
			p.Match(StmtParserCONNECTION)
		}
		p.SetState(520)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(519)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(522)
			p.Match(StmtParserSTRING_LITERAL)
		}

	case 12:
		localctx = NewTableOptionDataDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(523)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserINDEX || _la == StmtParserDATA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(524)
			p.Match(StmtParserDIRECTORY)
		}
		p.SetState(526)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(525)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(528)
			p.Match(StmtParserSTRING_LITERAL)
		}

	case 13:
		localctx = NewTableOptionDelayContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(529)
			p.Match(StmtParserDELAY_KEY_WRITE)
		}
		p.SetState(531)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(530)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(533)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionDelayContext).boolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserZERO_DECIMAL || _la == StmtParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionDelayContext).boolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 14:
		localctx = NewTableOptionEncryptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(534)
			p.Match(StmtParserENCRYPTION)
		}
		p.SetState(536)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(535)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(538)
			p.Match(StmtParserSTRING_LITERAL)
		}

	case 15:
		localctx = NewTableOptionIndexDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(539)
			p.Match(StmtParserINDEX)
		}
		{
			p.SetState(540)
			p.Match(StmtParserDIRECTORY)
		}
		p.SetState(542)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(541)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(544)
			p.Match(StmtParserSTRING_LITERAL)
		}

	case 16:
		localctx = NewTableOptionInsertMethodContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(545)
			p.Match(StmtParserINSERT_METHOD)
		}
		p.SetState(547)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(546)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(549)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionInsertMethodContext).insertMethod = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserFIRST || _la == StmtParserLAST || _la == StmtParserNO) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionInsertMethodContext).insertMethod = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 17:
		localctx = NewTableOptionKeyBlockSizeContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(550)
			p.Match(StmtParserKEY_BLOCK_SIZE)
		}
		p.SetState(552)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(551)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(554)
			p.FileSizeLiteral()
		}

	case 18:
		localctx = NewTableOptionMaxRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(555)
			p.Match(StmtParserMAX_ROWS)
		}
		p.SetState(557)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(556)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(559)
			p.DecimalLiteral()
		}

	case 19:
		localctx = NewTableOptionMinRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(560)
			p.Match(StmtParserMIN_ROWS)
		}
		p.SetState(562)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(561)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(564)
			p.DecimalLiteral()
		}

	case 20:
		localctx = NewTableOptionPackKeysContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(565)
			p.Match(StmtParserPACK_KEYS)
		}
		p.SetState(567)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(566)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(569)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionPackKeysContext).extBoolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserDEFAULT || _la == StmtParserZERO_DECIMAL || _la == StmtParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionPackKeysContext).extBoolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 21:
		localctx = NewTableOptionPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(570)
			p.Match(StmtParserPASSWORD)
		}
		p.SetState(572)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(571)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(574)
			p.Match(StmtParserSTRING_LITERAL)
		}

	case 22:
		localctx = NewTableOptionRowFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(575)
			p.Match(StmtParserROW_FORMAT)
		}
		p.SetState(577)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(576)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(579)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionRowFormatContext).rowFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserDEFAULT || (int64((_la-361)) & ^0x3f) == 0 && ((int64(1)<<(_la-361))&288230380446679045) != 0 || _la == StmtParserREDUNDANT || _la == StmtParserID) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionRowFormatContext).rowFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 23:
		localctx = NewTableOptionStartTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(580)
			p.Match(StmtParserSTART)
		}
		{
			p.SetState(581)
			p.Match(StmtParserTRANSACTION)
		}

	case 24:
		localctx = NewTableOptionSecondaryEngineAttributeContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(582)
			p.Match(StmtParserSECONDARY_ENGINE_ATTRIBUTE)
		}
		p.SetState(584)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(583)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(586)
			p.Match(StmtParserSTRING_LITERAL)
		}

	case 25:
		localctx = NewTableOptionRecalculationContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(587)
			p.Match(StmtParserSTATS_AUTO_RECALC)
		}
		p.SetState(589)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(588)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(591)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionRecalculationContext).extBoolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserDEFAULT || _la == StmtParserZERO_DECIMAL || _la == StmtParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionRecalculationContext).extBoolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 26:
		localctx = NewTableOptionPersistentContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(592)
			p.Match(StmtParserSTATS_PERSISTENT)
		}
		p.SetState(594)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(593)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(596)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionPersistentContext).extBoolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserDEFAULT || _la == StmtParserZERO_DECIMAL || _la == StmtParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionPersistentContext).extBoolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 27:
		localctx = NewTableOptionSamplePageContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(597)
			p.Match(StmtParserSTATS_SAMPLE_PAGES)
		}
		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(598)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(601)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionSamplePageContext).extValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserDEFAULT || _la == StmtParserDECIMAL_LITERAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionSamplePageContext).extValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 28:
		localctx = NewTableOptionTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(602)
			p.Match(StmtParserTABLESPACE)
		}
		{
			p.SetState(603)
			p.Uid()
		}
		p.SetState(605)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(604)
				p.TablespaceStorage()
			}

		}

	case 29:
		localctx = NewTableOptionTableTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(607)
			p.Match(StmtParserTABLE_TYPE)
		}
		{
			p.SetState(608)
			p.Match(StmtParserEQUAL_SYMBOL)
		}
		{
			p.SetState(609)
			p.TableType()
		}

	case 30:
		localctx = NewTableOptionTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(610)
			p.TablespaceStorage()
		}

	case 31:
		localctx = NewTableOptionUnionContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(611)
			p.Match(StmtParserUNION)
		}
		p.SetState(613)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(612)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(615)
			p.Match(StmtParserLR_BRACKET)
		}
		{
			p.SetState(616)
			p.Tables()
		}
		{
			p.SetState(617)
			p.Match(StmtParserRR_BRACKET)
		}

	}

	return localctx
}

// ITableTypeContext is an interface to support dynamic dispatch.
type ITableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableTypeContext differentiates from other interfaces.
	IsTableTypeContext()
}

type TableTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableTypeContext() *TableTypeContext {
	var p = new(TableTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_tableType
	return p
}

func (*TableTypeContext) IsTableTypeContext() {}

func NewTableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableTypeContext {
	var p = new(TableTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_tableType

	return p
}

func (s *TableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TableTypeContext) MYSQL() antlr.TerminalNode {
	return s.GetToken(StmtParserMYSQL, 0)
}

func (s *TableTypeContext) ODBC() antlr.TerminalNode {
	return s.GetToken(StmtParserODBC, 0)
}

func (s *TableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableType(s)
	}
}

func (s *TableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableType(s)
	}
}

func (p *StmtParser) TableType() (localctx ITableTypeContext) {
	this := p
	_ = this

	localctx = NewTableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, StmtParserRULE_tableType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(621)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserMYSQL || _la == StmtParserODBC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITablespaceStorageContext is an interface to support dynamic dispatch.
type ITablespaceStorageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTablespaceStorageContext differentiates from other interfaces.
	IsTablespaceStorageContext()
}

type TablespaceStorageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablespaceStorageContext() *TablespaceStorageContext {
	var p = new(TablespaceStorageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_tablespaceStorage
	return p
}

func (*TablespaceStorageContext) IsTablespaceStorageContext() {}

func NewTablespaceStorageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablespaceStorageContext {
	var p = new(TablespaceStorageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_tablespaceStorage

	return p
}

func (s *TablespaceStorageContext) GetParser() antlr.Parser { return s.parser }

func (s *TablespaceStorageContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StmtParserSTORAGE, 0)
}

func (s *TablespaceStorageContext) DISK() antlr.TerminalNode {
	return s.GetToken(StmtParserDISK, 0)
}

func (s *TablespaceStorageContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(StmtParserMEMORY, 0)
}

func (s *TablespaceStorageContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *TablespaceStorageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablespaceStorageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablespaceStorageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTablespaceStorage(s)
	}
}

func (s *TablespaceStorageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTablespaceStorage(s)
	}
}

func (p *StmtParser) TablespaceStorage() (localctx ITablespaceStorageContext) {
	this := p
	_ = this

	localctx = NewTablespaceStorageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, StmtParserRULE_tablespaceStorage)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(623)
		p.Match(StmtParserSTORAGE)
	}
	{
		p.SetState(624)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserDEFAULT || _la == StmtParserDISK || _la == StmtParserMEMORY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPartitionDefinitionsContext is an interface to support dynamic dispatch.
type IPartitionDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCount returns the count rule contexts.
	GetCount() IDecimalLiteralContext

	// GetSubCount returns the subCount rule contexts.
	GetSubCount() IDecimalLiteralContext

	// SetCount sets the count rule contexts.
	SetCount(IDecimalLiteralContext)

	// SetSubCount sets the subCount rule contexts.
	SetSubCount(IDecimalLiteralContext)

	// IsPartitionDefinitionsContext differentiates from other interfaces.
	IsPartitionDefinitionsContext()
}

type PartitionDefinitionsContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	count    IDecimalLiteralContext
	subCount IDecimalLiteralContext
}

func NewEmptyPartitionDefinitionsContext() *PartitionDefinitionsContext {
	var p = new(PartitionDefinitionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_partitionDefinitions
	return p
}

func (*PartitionDefinitionsContext) IsPartitionDefinitionsContext() {}

func NewPartitionDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinitionsContext {
	var p = new(PartitionDefinitionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_partitionDefinitions

	return p
}

func (s *PartitionDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinitionsContext) GetCount() IDecimalLiteralContext { return s.count }

func (s *PartitionDefinitionsContext) GetSubCount() IDecimalLiteralContext { return s.subCount }

func (s *PartitionDefinitionsContext) SetCount(v IDecimalLiteralContext) { s.count = v }

func (s *PartitionDefinitionsContext) SetSubCount(v IDecimalLiteralContext) { s.subCount = v }

func (s *PartitionDefinitionsContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTITION, 0)
}

func (s *PartitionDefinitionsContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(StmtParserBY)
}

func (s *PartitionDefinitionsContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserBY, i)
}

func (s *PartitionDefinitionsContext) PartitionFunctionDefinition() IPartitionFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionFunctionDefinitionContext)
}

func (s *PartitionDefinitionsContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTITIONS, 0)
}

func (s *PartitionDefinitionsContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBPARTITION, 0)
}

func (s *PartitionDefinitionsContext) SubpartitionFunctionDefinition() ISubpartitionFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionFunctionDefinitionContext)
}

func (s *PartitionDefinitionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *PartitionDefinitionsContext) AllPartitionDefinition() []IPartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinitionContext); ok {
			tst[i] = t.(IPartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinitionsContext) PartitionDefinition(i int) IPartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionContext)
}

func (s *PartitionDefinitionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *PartitionDefinitionsContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinitionsContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PartitionDefinitionsContext) SUBPARTITIONS() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBPARTITIONS, 0)
}

func (s *PartitionDefinitionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *PartitionDefinitionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *PartitionDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionDefinitions(s)
	}
}

func (s *PartitionDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionDefinitions(s)
	}
}

func (p *StmtParser) PartitionDefinitions() (localctx IPartitionDefinitionsContext) {
	this := p
	_ = this

	localctx = NewPartitionDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, StmtParserRULE_partitionDefinitions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(626)
		p.Match(StmtParserPARTITION)
	}
	{
		p.SetState(627)
		p.Match(StmtParserBY)
	}
	{
		p.SetState(628)
		p.PartitionFunctionDefinition()
	}
	p.SetState(631)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserPARTITIONS {
		{
			p.SetState(629)
			p.Match(StmtParserPARTITIONS)
		}
		{
			p.SetState(630)

			var _x = p.DecimalLiteral()

			localctx.(*PartitionDefinitionsContext).count = _x
		}

	}
	p.SetState(640)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserSUBPARTITION {
		{
			p.SetState(633)
			p.Match(StmtParserSUBPARTITION)
		}
		{
			p.SetState(634)
			p.Match(StmtParserBY)
		}
		{
			p.SetState(635)
			p.SubpartitionFunctionDefinition()
		}
		p.SetState(638)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserSUBPARTITIONS {
			{
				p.SetState(636)
				p.Match(StmtParserSUBPARTITIONS)
			}
			{
				p.SetState(637)

				var _x = p.DecimalLiteral()

				localctx.(*PartitionDefinitionsContext).subCount = _x
			}

		}

	}
	p.SetState(653)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserLR_BRACKET {
		{
			p.SetState(642)
			p.Match(StmtParserLR_BRACKET)
		}
		{
			p.SetState(643)
			p.PartitionDefinition()
		}
		p.SetState(648)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserCOMMA {
			{
				p.SetState(644)
				p.Match(StmtParserCOMMA)
			}
			{
				p.SetState(645)
				p.PartitionDefinition()
			}

			p.SetState(650)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(651)
			p.Match(StmtParserRR_BRACKET)
		}

	}

	return localctx
}

// IPartitionFunctionDefinitionContext is an interface to support dynamic dispatch.
type IPartitionFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartitionFunctionDefinitionContext differentiates from other interfaces.
	IsPartitionFunctionDefinitionContext()
}

type PartitionFunctionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionFunctionDefinitionContext() *PartitionFunctionDefinitionContext {
	var p = new(PartitionFunctionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_partitionFunctionDefinition
	return p
}

func (*PartitionFunctionDefinitionContext) IsPartitionFunctionDefinitionContext() {}

func NewPartitionFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionFunctionDefinitionContext {
	var p = new(PartitionFunctionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_partitionFunctionDefinition

	return p
}

func (s *PartitionFunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionFunctionDefinitionContext) CopyFrom(ctx *PartitionFunctionDefinitionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PartitionFunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PartitionFunctionKeyContext struct {
	*PartitionFunctionDefinitionContext
	algType antlr.Token
}

func NewPartitionFunctionKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionKeyContext {
	var p = new(PartitionFunctionKeyContext)

	p.PartitionFunctionDefinitionContext = NewEmptyPartitionFunctionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionKeyContext) GetAlgType() antlr.Token { return s.algType }

func (s *PartitionFunctionKeyContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *PartitionFunctionKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY, 0)
}

func (s *PartitionFunctionKeyContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *PartitionFunctionKeyContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PartitionFunctionKeyContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *PartitionFunctionKeyContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserLINEAR, 0)
}

func (s *PartitionFunctionKeyContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(StmtParserALGORITHM, 0)
}

func (s *PartitionFunctionKeyContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *PartitionFunctionKeyContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserONE_DECIMAL, 0)
}

func (s *PartitionFunctionKeyContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserTWO_DECIMAL, 0)
}

func (s *PartitionFunctionKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionFunctionKey(s)
	}
}

func (s *PartitionFunctionKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionFunctionKey(s)
	}
}

type PartitionFunctionHashContext struct {
	*PartitionFunctionDefinitionContext
}

func NewPartitionFunctionHashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionHashContext {
	var p = new(PartitionFunctionHashContext)

	p.PartitionFunctionDefinitionContext = NewEmptyPartitionFunctionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionHashContext) HASH() antlr.TerminalNode {
	return s.GetToken(StmtParserHASH, 0)
}

func (s *PartitionFunctionHashContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *PartitionFunctionHashContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionFunctionHashContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *PartitionFunctionHashContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserLINEAR, 0)
}

func (s *PartitionFunctionHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionFunctionHash(s)
	}
}

func (s *PartitionFunctionHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionFunctionHash(s)
	}
}

type PartitionFunctionListContext struct {
	*PartitionFunctionDefinitionContext
}

func NewPartitionFunctionListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionListContext {
	var p = new(PartitionFunctionListContext)

	p.PartitionFunctionDefinitionContext = NewEmptyPartitionFunctionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionListContext) LIST() antlr.TerminalNode {
	return s.GetToken(StmtParserLIST, 0)
}

func (s *PartitionFunctionListContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *PartitionFunctionListContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionFunctionListContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *PartitionFunctionListContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLUMNS, 0)
}

func (s *PartitionFunctionListContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PartitionFunctionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionFunctionList(s)
	}
}

func (s *PartitionFunctionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionFunctionList(s)
	}
}

type PartitionFunctionRangeContext struct {
	*PartitionFunctionDefinitionContext
}

func NewPartitionFunctionRangeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionRangeContext {
	var p = new(PartitionFunctionRangeContext)

	p.PartitionFunctionDefinitionContext = NewEmptyPartitionFunctionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionRangeContext) RANGE() antlr.TerminalNode {
	return s.GetToken(StmtParserRANGE, 0)
}

func (s *PartitionFunctionRangeContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *PartitionFunctionRangeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionFunctionRangeContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *PartitionFunctionRangeContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLUMNS, 0)
}

func (s *PartitionFunctionRangeContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PartitionFunctionRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionFunctionRange(s)
	}
}

func (s *PartitionFunctionRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionFunctionRange(s)
	}
}

func (p *StmtParser) PartitionFunctionDefinition() (localctx IPartitionFunctionDefinitionContext) {
	this := p
	_ = this

	localctx = NewPartitionFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, StmtParserRULE_partitionFunctionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(700)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPartitionFunctionHashContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(656)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLINEAR {
			{
				p.SetState(655)
				p.Match(StmtParserLINEAR)
			}

		}
		{
			p.SetState(658)
			p.Match(StmtParserHASH)
		}
		{
			p.SetState(659)
			p.Match(StmtParserLR_BRACKET)
		}
		{
			p.SetState(660)
			p.expression(0)
		}
		{
			p.SetState(661)
			p.Match(StmtParserRR_BRACKET)
		}

	case 2:
		localctx = NewPartitionFunctionKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(664)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLINEAR {
			{
				p.SetState(663)
				p.Match(StmtParserLINEAR)
			}

		}
		{
			p.SetState(666)
			p.Match(StmtParserKEY)
		}
		p.SetState(670)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserALGORITHM {
			{
				p.SetState(667)
				p.Match(StmtParserALGORITHM)
			}
			{
				p.SetState(668)
				p.Match(StmtParserEQUAL_SYMBOL)
			}
			{
				p.SetState(669)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*PartitionFunctionKeyContext).algType = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == StmtParserONE_DECIMAL || _la == StmtParserTWO_DECIMAL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*PartitionFunctionKeyContext).algType = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(672)
			p.Match(StmtParserLR_BRACKET)
		}
		{
			p.SetState(673)
			p.UidList()
		}
		{
			p.SetState(674)
			p.Match(StmtParserRR_BRACKET)
		}

	case 3:
		localctx = NewPartitionFunctionRangeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(676)
			p.Match(StmtParserRANGE)
		}
		p.SetState(686)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case StmtParserLR_BRACKET:
			{
				p.SetState(677)
				p.Match(StmtParserLR_BRACKET)
			}
			{
				p.SetState(678)
				p.expression(0)
			}
			{
				p.SetState(679)
				p.Match(StmtParserRR_BRACKET)
			}

		case StmtParserCOLUMNS:
			{
				p.SetState(681)
				p.Match(StmtParserCOLUMNS)
			}
			{
				p.SetState(682)
				p.Match(StmtParserLR_BRACKET)
			}
			{
				p.SetState(683)
				p.UidList()
			}
			{
				p.SetState(684)
				p.Match(StmtParserRR_BRACKET)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 4:
		localctx = NewPartitionFunctionListContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(688)
			p.Match(StmtParserLIST)
		}
		p.SetState(698)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case StmtParserLR_BRACKET:
			{
				p.SetState(689)
				p.Match(StmtParserLR_BRACKET)
			}
			{
				p.SetState(690)
				p.expression(0)
			}
			{
				p.SetState(691)
				p.Match(StmtParserRR_BRACKET)
			}

		case StmtParserCOLUMNS:
			{
				p.SetState(693)
				p.Match(StmtParserCOLUMNS)
			}
			{
				p.SetState(694)
				p.Match(StmtParserLR_BRACKET)
			}
			{
				p.SetState(695)
				p.UidList()
			}
			{
				p.SetState(696)
				p.Match(StmtParserRR_BRACKET)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// ISubpartitionFunctionDefinitionContext is an interface to support dynamic dispatch.
type ISubpartitionFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubpartitionFunctionDefinitionContext differentiates from other interfaces.
	IsSubpartitionFunctionDefinitionContext()
}

type SubpartitionFunctionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubpartitionFunctionDefinitionContext() *SubpartitionFunctionDefinitionContext {
	var p = new(SubpartitionFunctionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_subpartitionFunctionDefinition
	return p
}

func (*SubpartitionFunctionDefinitionContext) IsSubpartitionFunctionDefinitionContext() {}

func NewSubpartitionFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubpartitionFunctionDefinitionContext {
	var p = new(SubpartitionFunctionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_subpartitionFunctionDefinition

	return p
}

func (s *SubpartitionFunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubpartitionFunctionDefinitionContext) CopyFrom(ctx *SubpartitionFunctionDefinitionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SubpartitionFunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubpartitionFunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubPartitionFunctionHashContext struct {
	*SubpartitionFunctionDefinitionContext
}

func NewSubPartitionFunctionHashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubPartitionFunctionHashContext {
	var p = new(SubPartitionFunctionHashContext)

	p.SubpartitionFunctionDefinitionContext = NewEmptySubpartitionFunctionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SubpartitionFunctionDefinitionContext))

	return p
}

func (s *SubPartitionFunctionHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubPartitionFunctionHashContext) HASH() antlr.TerminalNode {
	return s.GetToken(StmtParserHASH, 0)
}

func (s *SubPartitionFunctionHashContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *SubPartitionFunctionHashContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SubPartitionFunctionHashContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *SubPartitionFunctionHashContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserLINEAR, 0)
}

func (s *SubPartitionFunctionHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSubPartitionFunctionHash(s)
	}
}

func (s *SubPartitionFunctionHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSubPartitionFunctionHash(s)
	}
}

type SubPartitionFunctionKeyContext struct {
	*SubpartitionFunctionDefinitionContext
	algType antlr.Token
}

func NewSubPartitionFunctionKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubPartitionFunctionKeyContext {
	var p = new(SubPartitionFunctionKeyContext)

	p.SubpartitionFunctionDefinitionContext = NewEmptySubpartitionFunctionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SubpartitionFunctionDefinitionContext))

	return p
}

func (s *SubPartitionFunctionKeyContext) GetAlgType() antlr.Token { return s.algType }

func (s *SubPartitionFunctionKeyContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *SubPartitionFunctionKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubPartitionFunctionKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY, 0)
}

func (s *SubPartitionFunctionKeyContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *SubPartitionFunctionKeyContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *SubPartitionFunctionKeyContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *SubPartitionFunctionKeyContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserLINEAR, 0)
}

func (s *SubPartitionFunctionKeyContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(StmtParserALGORITHM, 0)
}

func (s *SubPartitionFunctionKeyContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *SubPartitionFunctionKeyContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserONE_DECIMAL, 0)
}

func (s *SubPartitionFunctionKeyContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserTWO_DECIMAL, 0)
}

func (s *SubPartitionFunctionKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSubPartitionFunctionKey(s)
	}
}

func (s *SubPartitionFunctionKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSubPartitionFunctionKey(s)
	}
}

func (p *StmtParser) SubpartitionFunctionDefinition() (localctx ISubpartitionFunctionDefinitionContext) {
	this := p
	_ = this

	localctx = NewSubpartitionFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, StmtParserRULE_subpartitionFunctionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(723)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSubPartitionFunctionHashContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(703)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLINEAR {
			{
				p.SetState(702)
				p.Match(StmtParserLINEAR)
			}

		}
		{
			p.SetState(705)
			p.Match(StmtParserHASH)
		}
		{
			p.SetState(706)
			p.Match(StmtParserLR_BRACKET)
		}
		{
			p.SetState(707)
			p.expression(0)
		}
		{
			p.SetState(708)
			p.Match(StmtParserRR_BRACKET)
		}

	case 2:
		localctx = NewSubPartitionFunctionKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(711)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLINEAR {
			{
				p.SetState(710)
				p.Match(StmtParserLINEAR)
			}

		}
		{
			p.SetState(713)
			p.Match(StmtParserKEY)
		}
		p.SetState(717)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserALGORITHM {
			{
				p.SetState(714)
				p.Match(StmtParserALGORITHM)
			}
			{
				p.SetState(715)
				p.Match(StmtParserEQUAL_SYMBOL)
			}
			{
				p.SetState(716)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SubPartitionFunctionKeyContext).algType = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == StmtParserONE_DECIMAL || _la == StmtParserTWO_DECIMAL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SubPartitionFunctionKeyContext).algType = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(719)
			p.Match(StmtParserLR_BRACKET)
		}
		{
			p.SetState(720)
			p.UidList()
		}
		{
			p.SetState(721)
			p.Match(StmtParserRR_BRACKET)
		}

	}

	return localctx
}

// IPartitionDefinitionContext is an interface to support dynamic dispatch.
type IPartitionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartitionDefinitionContext differentiates from other interfaces.
	IsPartitionDefinitionContext()
}

type PartitionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinitionContext() *PartitionDefinitionContext {
	var p = new(PartitionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_partitionDefinition
	return p
}

func (*PartitionDefinitionContext) IsPartitionDefinitionContext() {}

func NewPartitionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinitionContext {
	var p = new(PartitionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_partitionDefinition

	return p
}

func (s *PartitionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinitionContext) CopyFrom(ctx *PartitionDefinitionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PartitionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PartitionComparisonContext struct {
	*PartitionDefinitionContext
}

func NewPartitionComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionComparisonContext {
	var p = new(PartitionComparisonContext)

	p.PartitionDefinitionContext = NewEmptyPartitionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionComparisonContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTITION, 0)
}

func (s *PartitionComparisonContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionComparisonContext) VALUES() antlr.TerminalNode {
	return s.GetToken(StmtParserVALUES, 0)
}

func (s *PartitionComparisonContext) LESS() antlr.TerminalNode {
	return s.GetToken(StmtParserLESS, 0)
}

func (s *PartitionComparisonContext) THAN() antlr.TerminalNode {
	return s.GetToken(StmtParserTHAN, 0)
}

func (s *PartitionComparisonContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(StmtParserLR_BRACKET)
}

func (s *PartitionComparisonContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, i)
}

func (s *PartitionComparisonContext) AllPartitionDefinerAtom() []IPartitionDefinerAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerAtomContext); ok {
			tst[i] = t.(IPartitionDefinerAtomContext)
			i++
		}
	}

	return tst
}

func (s *PartitionComparisonContext) PartitionDefinerAtom(i int) IPartitionDefinerAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerAtomContext)
}

func (s *PartitionComparisonContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(StmtParserRR_BRACKET)
}

func (s *PartitionComparisonContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, i)
}

func (s *PartitionComparisonContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *PartitionComparisonContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *PartitionComparisonContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionComparisonContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionComparisonContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionComparisonContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionComparison(s)
	}
}

func (s *PartitionComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionComparison(s)
	}
}

type PartitionListAtomContext struct {
	*PartitionDefinitionContext
}

func NewPartitionListAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionListAtomContext {
	var p = new(PartitionListAtomContext)

	p.PartitionDefinitionContext = NewEmptyPartitionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionListAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionListAtomContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTITION, 0)
}

func (s *PartitionListAtomContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionListAtomContext) VALUES() antlr.TerminalNode {
	return s.GetToken(StmtParserVALUES, 0)
}

func (s *PartitionListAtomContext) IN() antlr.TerminalNode {
	return s.GetToken(StmtParserIN, 0)
}

func (s *PartitionListAtomContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(StmtParserLR_BRACKET)
}

func (s *PartitionListAtomContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, i)
}

func (s *PartitionListAtomContext) AllPartitionDefinerAtom() []IPartitionDefinerAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerAtomContext); ok {
			tst[i] = t.(IPartitionDefinerAtomContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListAtomContext) PartitionDefinerAtom(i int) IPartitionDefinerAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerAtomContext)
}

func (s *PartitionListAtomContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(StmtParserRR_BRACKET)
}

func (s *PartitionListAtomContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, i)
}

func (s *PartitionListAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *PartitionListAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *PartitionListAtomContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListAtomContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionListAtomContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListAtomContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionListAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionListAtom(s)
	}
}

func (s *PartitionListAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionListAtom(s)
	}
}

type PartitionListVectorContext struct {
	*PartitionDefinitionContext
}

func NewPartitionListVectorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionListVectorContext {
	var p = new(PartitionListVectorContext)

	p.PartitionDefinitionContext = NewEmptyPartitionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionListVectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionListVectorContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTITION, 0)
}

func (s *PartitionListVectorContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionListVectorContext) VALUES() antlr.TerminalNode {
	return s.GetToken(StmtParserVALUES, 0)
}

func (s *PartitionListVectorContext) IN() antlr.TerminalNode {
	return s.GetToken(StmtParserIN, 0)
}

func (s *PartitionListVectorContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(StmtParserLR_BRACKET)
}

func (s *PartitionListVectorContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, i)
}

func (s *PartitionListVectorContext) AllPartitionDefinerVector() []IPartitionDefinerVectorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerVectorContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerVectorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerVectorContext); ok {
			tst[i] = t.(IPartitionDefinerVectorContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListVectorContext) PartitionDefinerVector(i int) IPartitionDefinerVectorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerVectorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerVectorContext)
}

func (s *PartitionListVectorContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(StmtParserRR_BRACKET)
}

func (s *PartitionListVectorContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, i)
}

func (s *PartitionListVectorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *PartitionListVectorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *PartitionListVectorContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListVectorContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionListVectorContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListVectorContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionListVectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionListVector(s)
	}
}

func (s *PartitionListVectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionListVector(s)
	}
}

type PartitionSimpleContext struct {
	*PartitionDefinitionContext
}

func NewPartitionSimpleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionSimpleContext {
	var p = new(PartitionSimpleContext)

	p.PartitionDefinitionContext = NewEmptyPartitionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionSimpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSimpleContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTITION, 0)
}

func (s *PartitionSimpleContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionSimpleContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionSimpleContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionSimpleContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *PartitionSimpleContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionSimpleContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionSimpleContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *PartitionSimpleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *PartitionSimpleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *PartitionSimpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionSimple(s)
	}
}

func (s *PartitionSimpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionSimple(s)
	}
}

func (p *StmtParser) PartitionDefinition() (localctx IPartitionDefinitionContext) {
	this := p
	_ = this

	localctx = NewPartitionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, StmtParserRULE_partitionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(871)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPartitionComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(725)
			p.Match(StmtParserPARTITION)
		}
		{
			p.SetState(726)
			p.Uid()
		}
		{
			p.SetState(727)
			p.Match(StmtParserVALUES)
		}
		{
			p.SetState(728)
			p.Match(StmtParserLESS)
		}
		{
			p.SetState(729)
			p.Match(StmtParserTHAN)
		}
		{
			p.SetState(730)
			p.Match(StmtParserLR_BRACKET)
		}
		{
			p.SetState(731)
			p.PartitionDefinerAtom()
		}
		p.SetState(736)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserCOMMA {
			{
				p.SetState(732)
				p.Match(StmtParserCOMMA)
			}
			{
				p.SetState(733)
				p.PartitionDefinerAtom()
			}

			p.SetState(738)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(739)
			p.Match(StmtParserRR_BRACKET)
		}
		p.SetState(743)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserDEFAULT || _la == StmtParserINDEX || (int64((_la-359)) & ^0x3f) == 0 && ((int64(1)<<(_la-359))&549756862465) != 0 || (int64((_la-487)) & ^0x3f) == 0 && ((int64(1)<<(_la-487))&268436481) != 0 || _la == StmtParserSTORAGE || _la == StmtParserTABLESPACE {
			{
				p.SetState(740)
				p.PartitionOption()
			}

			p.SetState(745)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(757)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(746)
				p.Match(StmtParserLR_BRACKET)
			}
			{
				p.SetState(747)
				p.SubpartitionDefinition()
			}
			p.SetState(752)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == StmtParserCOMMA {
				{
					p.SetState(748)
					p.Match(StmtParserCOMMA)
				}
				{
					p.SetState(749)
					p.SubpartitionDefinition()
				}

				p.SetState(754)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(755)
				p.Match(StmtParserRR_BRACKET)
			}

		}

	case 2:
		localctx = NewPartitionComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(759)
			p.Match(StmtParserPARTITION)
		}
		{
			p.SetState(760)
			p.Uid()
		}
		{
			p.SetState(761)
			p.Match(StmtParserVALUES)
		}
		{
			p.SetState(762)
			p.Match(StmtParserLESS)
		}
		{
			p.SetState(763)
			p.Match(StmtParserTHAN)
		}
		{
			p.SetState(764)
			p.PartitionDefinerAtom()
		}
		p.SetState(768)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserDEFAULT || _la == StmtParserINDEX || (int64((_la-359)) & ^0x3f) == 0 && ((int64(1)<<(_la-359))&549756862465) != 0 || (int64((_la-487)) & ^0x3f) == 0 && ((int64(1)<<(_la-487))&268436481) != 0 || _la == StmtParserSTORAGE || _la == StmtParserTABLESPACE {
			{
				p.SetState(765)
				p.PartitionOption()
			}

			p.SetState(770)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(782)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(771)
				p.Match(StmtParserLR_BRACKET)
			}
			{
				p.SetState(772)
				p.SubpartitionDefinition()
			}
			p.SetState(777)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == StmtParserCOMMA {
				{
					p.SetState(773)
					p.Match(StmtParserCOMMA)
				}
				{
					p.SetState(774)
					p.SubpartitionDefinition()
				}

				p.SetState(779)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(780)
				p.Match(StmtParserRR_BRACKET)
			}

		}

	case 3:
		localctx = NewPartitionListAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(784)
			p.Match(StmtParserPARTITION)
		}
		{
			p.SetState(785)
			p.Uid()
		}
		{
			p.SetState(786)
			p.Match(StmtParserVALUES)
		}
		{
			p.SetState(787)
			p.Match(StmtParserIN)
		}
		{
			p.SetState(788)
			p.Match(StmtParserLR_BRACKET)
		}
		{
			p.SetState(789)
			p.PartitionDefinerAtom()
		}
		p.SetState(794)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserCOMMA {
			{
				p.SetState(790)
				p.Match(StmtParserCOMMA)
			}
			{
				p.SetState(791)
				p.PartitionDefinerAtom()
			}

			p.SetState(796)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(797)
			p.Match(StmtParserRR_BRACKET)
		}
		p.SetState(801)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserDEFAULT || _la == StmtParserINDEX || (int64((_la-359)) & ^0x3f) == 0 && ((int64(1)<<(_la-359))&549756862465) != 0 || (int64((_la-487)) & ^0x3f) == 0 && ((int64(1)<<(_la-487))&268436481) != 0 || _la == StmtParserSTORAGE || _la == StmtParserTABLESPACE {
			{
				p.SetState(798)
				p.PartitionOption()
			}

			p.SetState(803)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(815)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(804)
				p.Match(StmtParserLR_BRACKET)
			}
			{
				p.SetState(805)
				p.SubpartitionDefinition()
			}
			p.SetState(810)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == StmtParserCOMMA {
				{
					p.SetState(806)
					p.Match(StmtParserCOMMA)
				}
				{
					p.SetState(807)
					p.SubpartitionDefinition()
				}

				p.SetState(812)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(813)
				p.Match(StmtParserRR_BRACKET)
			}

		}

	case 4:
		localctx = NewPartitionListVectorContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(817)
			p.Match(StmtParserPARTITION)
		}
		{
			p.SetState(818)
			p.Uid()
		}
		{
			p.SetState(819)
			p.Match(StmtParserVALUES)
		}
		{
			p.SetState(820)
			p.Match(StmtParserIN)
		}
		{
			p.SetState(821)
			p.Match(StmtParserLR_BRACKET)
		}
		{
			p.SetState(822)
			p.PartitionDefinerVector()
		}
		p.SetState(827)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserCOMMA {
			{
				p.SetState(823)
				p.Match(StmtParserCOMMA)
			}
			{
				p.SetState(824)
				p.PartitionDefinerVector()
			}

			p.SetState(829)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(830)
			p.Match(StmtParserRR_BRACKET)
		}
		p.SetState(834)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserDEFAULT || _la == StmtParserINDEX || (int64((_la-359)) & ^0x3f) == 0 && ((int64(1)<<(_la-359))&549756862465) != 0 || (int64((_la-487)) & ^0x3f) == 0 && ((int64(1)<<(_la-487))&268436481) != 0 || _la == StmtParserSTORAGE || _la == StmtParserTABLESPACE {
			{
				p.SetState(831)
				p.PartitionOption()
			}

			p.SetState(836)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(848)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(837)
				p.Match(StmtParserLR_BRACKET)
			}
			{
				p.SetState(838)
				p.SubpartitionDefinition()
			}
			p.SetState(843)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == StmtParserCOMMA {
				{
					p.SetState(839)
					p.Match(StmtParserCOMMA)
				}
				{
					p.SetState(840)
					p.SubpartitionDefinition()
				}

				p.SetState(845)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(846)
				p.Match(StmtParserRR_BRACKET)
			}

		}

	case 5:
		localctx = NewPartitionSimpleContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(850)
			p.Match(StmtParserPARTITION)
		}
		{
			p.SetState(851)
			p.Uid()
		}
		p.SetState(855)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserDEFAULT || _la == StmtParserINDEX || (int64((_la-359)) & ^0x3f) == 0 && ((int64(1)<<(_la-359))&549756862465) != 0 || (int64((_la-487)) & ^0x3f) == 0 && ((int64(1)<<(_la-487))&268436481) != 0 || _la == StmtParserSTORAGE || _la == StmtParserTABLESPACE {
			{
				p.SetState(852)
				p.PartitionOption()
			}

			p.SetState(857)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(869)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(858)
				p.Match(StmtParserLR_BRACKET)
			}
			{
				p.SetState(859)
				p.SubpartitionDefinition()
			}
			p.SetState(864)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == StmtParserCOMMA {
				{
					p.SetState(860)
					p.Match(StmtParserCOMMA)
				}
				{
					p.SetState(861)
					p.SubpartitionDefinition()
				}

				p.SetState(866)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(867)
				p.Match(StmtParserRR_BRACKET)
			}

		}

	}

	return localctx
}

// IPartitionDefinerAtomContext is an interface to support dynamic dispatch.
type IPartitionDefinerAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartitionDefinerAtomContext differentiates from other interfaces.
	IsPartitionDefinerAtomContext()
}

type PartitionDefinerAtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinerAtomContext() *PartitionDefinerAtomContext {
	var p = new(PartitionDefinerAtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_partitionDefinerAtom
	return p
}

func (*PartitionDefinerAtomContext) IsPartitionDefinerAtomContext() {}

func NewPartitionDefinerAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinerAtomContext {
	var p = new(PartitionDefinerAtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_partitionDefinerAtom

	return p
}

func (s *PartitionDefinerAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinerAtomContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PartitionDefinerAtomContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionDefinerAtomContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserMAXVALUE, 0)
}

func (s *PartitionDefinerAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinerAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinerAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionDefinerAtom(s)
	}
}

func (s *PartitionDefinerAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionDefinerAtom(s)
	}
}

func (p *StmtParser) PartitionDefinerAtom() (localctx IPartitionDefinerAtomContext) {
	this := p
	_ = this

	localctx = NewPartitionDefinerAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, StmtParserRULE_partitionDefinerAtom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(876)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(873)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(874)
			p.expression(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(875)
			p.Match(StmtParserMAXVALUE)
		}

	}

	return localctx
}

// IPartitionDefinerVectorContext is an interface to support dynamic dispatch.
type IPartitionDefinerVectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartitionDefinerVectorContext differentiates from other interfaces.
	IsPartitionDefinerVectorContext()
}

type PartitionDefinerVectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinerVectorContext() *PartitionDefinerVectorContext {
	var p = new(PartitionDefinerVectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_partitionDefinerVector
	return p
}

func (*PartitionDefinerVectorContext) IsPartitionDefinerVectorContext() {}

func NewPartitionDefinerVectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinerVectorContext {
	var p = new(PartitionDefinerVectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_partitionDefinerVector

	return p
}

func (s *PartitionDefinerVectorContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinerVectorContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *PartitionDefinerVectorContext) AllPartitionDefinerAtom() []IPartitionDefinerAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerAtomContext); ok {
			tst[i] = t.(IPartitionDefinerAtomContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinerVectorContext) PartitionDefinerAtom(i int) IPartitionDefinerAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerAtomContext)
}

func (s *PartitionDefinerVectorContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *PartitionDefinerVectorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *PartitionDefinerVectorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *PartitionDefinerVectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinerVectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinerVectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionDefinerVector(s)
	}
}

func (s *PartitionDefinerVectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionDefinerVector(s)
	}
}

func (p *StmtParser) PartitionDefinerVector() (localctx IPartitionDefinerVectorContext) {
	this := p
	_ = this

	localctx = NewPartitionDefinerVectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, StmtParserRULE_partitionDefinerVector)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(878)
		p.Match(StmtParserLR_BRACKET)
	}
	{
		p.SetState(879)
		p.PartitionDefinerAtom()
	}
	p.SetState(882)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == StmtParserCOMMA {
		{
			p.SetState(880)
			p.Match(StmtParserCOMMA)
		}
		{
			p.SetState(881)
			p.PartitionDefinerAtom()
		}

		p.SetState(884)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(886)
		p.Match(StmtParserRR_BRACKET)
	}

	return localctx
}

// ISubpartitionDefinitionContext is an interface to support dynamic dispatch.
type ISubpartitionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubpartitionDefinitionContext differentiates from other interfaces.
	IsSubpartitionDefinitionContext()
}

type SubpartitionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubpartitionDefinitionContext() *SubpartitionDefinitionContext {
	var p = new(SubpartitionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_subpartitionDefinition
	return p
}

func (*SubpartitionDefinitionContext) IsSubpartitionDefinitionContext() {}

func NewSubpartitionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubpartitionDefinitionContext {
	var p = new(SubpartitionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_subpartitionDefinition

	return p
}

func (s *SubpartitionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubpartitionDefinitionContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBPARTITION, 0)
}

func (s *SubpartitionDefinitionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SubpartitionDefinitionContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *SubpartitionDefinitionContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *SubpartitionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubpartitionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubpartitionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSubpartitionDefinition(s)
	}
}

func (s *SubpartitionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSubpartitionDefinition(s)
	}
}

func (p *StmtParser) SubpartitionDefinition() (localctx ISubpartitionDefinitionContext) {
	this := p
	_ = this

	localctx = NewSubpartitionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, StmtParserRULE_subpartitionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(888)
		p.Match(StmtParserSUBPARTITION)
	}
	{
		p.SetState(889)
		p.Uid()
	}
	p.SetState(893)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == StmtParserDEFAULT || _la == StmtParserINDEX || (int64((_la-359)) & ^0x3f) == 0 && ((int64(1)<<(_la-359))&549756862465) != 0 || (int64((_la-487)) & ^0x3f) == 0 && ((int64(1)<<(_la-487))&268436481) != 0 || _la == StmtParserSTORAGE || _la == StmtParserTABLESPACE {
		{
			p.SetState(890)
			p.PartitionOption()
		}

		p.SetState(895)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPartitionOptionContext is an interface to support dynamic dispatch.
type IPartitionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartitionOptionContext differentiates from other interfaces.
	IsPartitionOptionContext()
}

type PartitionOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionOptionContext() *PartitionOptionContext {
	var p = new(PartitionOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_partitionOption
	return p
}

func (*PartitionOptionContext) IsPartitionOptionContext() {}

func NewPartitionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionOptionContext {
	var p = new(PartitionOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_partitionOption

	return p
}

func (s *PartitionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionOptionContext) CopyFrom(ctx *PartitionOptionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PartitionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PartitionOptionCommentContext struct {
	*PartitionOptionContext
	comment antlr.Token
}

func NewPartitionOptionCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionCommentContext {
	var p = new(PartitionOptionCommentContext)

	p.PartitionOptionContext = NewEmptyPartitionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionCommentContext) GetComment() antlr.Token { return s.comment }

func (s *PartitionOptionCommentContext) SetComment(v antlr.Token) { s.comment = v }

func (s *PartitionOptionCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMENT, 0)
}

func (s *PartitionOptionCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *PartitionOptionCommentContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionOptionComment(s)
	}
}

func (s *PartitionOptionCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionOptionComment(s)
	}
}

type PartitionOptionNodeGroupContext struct {
	*PartitionOptionContext
	nodegroup IUidContext
}

func NewPartitionOptionNodeGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionNodeGroupContext {
	var p = new(PartitionOptionNodeGroupContext)

	p.PartitionOptionContext = NewEmptyPartitionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionNodeGroupContext) GetNodegroup() IUidContext { return s.nodegroup }

func (s *PartitionOptionNodeGroupContext) SetNodegroup(v IUidContext) { s.nodegroup = v }

func (s *PartitionOptionNodeGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionNodeGroupContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(StmtParserNODEGROUP, 0)
}

func (s *PartitionOptionNodeGroupContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionOptionNodeGroupContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionNodeGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionOptionNodeGroup(s)
	}
}

func (s *PartitionOptionNodeGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionOptionNodeGroup(s)
	}
}

type PartitionOptionIndexDirectoryContext struct {
	*PartitionOptionContext
	indexDirectory antlr.Token
}

func NewPartitionOptionIndexDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionIndexDirectoryContext {
	var p = new(PartitionOptionIndexDirectoryContext)

	p.PartitionOptionContext = NewEmptyPartitionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionIndexDirectoryContext) GetIndexDirectory() antlr.Token {
	return s.indexDirectory
}

func (s *PartitionOptionIndexDirectoryContext) SetIndexDirectory(v antlr.Token) { s.indexDirectory = v }

func (s *PartitionOptionIndexDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionIndexDirectoryContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StmtParserINDEX, 0)
}

func (s *PartitionOptionIndexDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(StmtParserDIRECTORY, 0)
}

func (s *PartitionOptionIndexDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *PartitionOptionIndexDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionIndexDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionOptionIndexDirectory(s)
	}
}

func (s *PartitionOptionIndexDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionOptionIndexDirectory(s)
	}
}

type PartitionOptionMaxRowsContext struct {
	*PartitionOptionContext
	maxRows IDecimalLiteralContext
}

func NewPartitionOptionMaxRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionMaxRowsContext {
	var p = new(PartitionOptionMaxRowsContext)

	p.PartitionOptionContext = NewEmptyPartitionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionMaxRowsContext) GetMaxRows() IDecimalLiteralContext { return s.maxRows }

func (s *PartitionOptionMaxRowsContext) SetMaxRows(v IDecimalLiteralContext) { s.maxRows = v }

func (s *PartitionOptionMaxRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionMaxRowsContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(StmtParserMAX_ROWS, 0)
}

func (s *PartitionOptionMaxRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PartitionOptionMaxRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionMaxRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionOptionMaxRows(s)
	}
}

func (s *PartitionOptionMaxRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionOptionMaxRows(s)
	}
}

type PartitionOptionTablespaceContext struct {
	*PartitionOptionContext
	tablespace IUidContext
}

func NewPartitionOptionTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionTablespaceContext {
	var p = new(PartitionOptionTablespaceContext)

	p.PartitionOptionContext = NewEmptyPartitionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionTablespaceContext) GetTablespace() IUidContext { return s.tablespace }

func (s *PartitionOptionTablespaceContext) SetTablespace(v IUidContext) { s.tablespace = v }

func (s *PartitionOptionTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(StmtParserTABLESPACE, 0)
}

func (s *PartitionOptionTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionOptionTablespaceContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionOptionTablespace(s)
	}
}

func (s *PartitionOptionTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionOptionTablespace(s)
	}
}

type PartitionOptionEngineContext struct {
	*PartitionOptionContext
}

func NewPartitionOptionEngineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionEngineContext {
	var p = new(PartitionOptionEngineContext)

	p.PartitionOptionContext = NewEmptyPartitionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionEngineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionEngineContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(StmtParserENGINE, 0)
}

func (s *PartitionOptionEngineContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *PartitionOptionEngineContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *PartitionOptionEngineContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StmtParserSTORAGE, 0)
}

func (s *PartitionOptionEngineContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionEngineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionOptionEngine(s)
	}
}

func (s *PartitionOptionEngineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionOptionEngine(s)
	}
}

type PartitionOptionMinRowsContext struct {
	*PartitionOptionContext
	minRows IDecimalLiteralContext
}

func NewPartitionOptionMinRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionMinRowsContext {
	var p = new(PartitionOptionMinRowsContext)

	p.PartitionOptionContext = NewEmptyPartitionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionMinRowsContext) GetMinRows() IDecimalLiteralContext { return s.minRows }

func (s *PartitionOptionMinRowsContext) SetMinRows(v IDecimalLiteralContext) { s.minRows = v }

func (s *PartitionOptionMinRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionMinRowsContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(StmtParserMIN_ROWS, 0)
}

func (s *PartitionOptionMinRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PartitionOptionMinRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionMinRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionOptionMinRows(s)
	}
}

func (s *PartitionOptionMinRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionOptionMinRows(s)
	}
}

type PartitionOptionDataDirectoryContext struct {
	*PartitionOptionContext
	dataDirectory antlr.Token
}

func NewPartitionOptionDataDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionDataDirectoryContext {
	var p = new(PartitionOptionDataDirectoryContext)

	p.PartitionOptionContext = NewEmptyPartitionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionDataDirectoryContext) GetDataDirectory() antlr.Token { return s.dataDirectory }

func (s *PartitionOptionDataDirectoryContext) SetDataDirectory(v antlr.Token) { s.dataDirectory = v }

func (s *PartitionOptionDataDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionDataDirectoryContext) DATA() antlr.TerminalNode {
	return s.GetToken(StmtParserDATA, 0)
}

func (s *PartitionOptionDataDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(StmtParserDIRECTORY, 0)
}

func (s *PartitionOptionDataDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *PartitionOptionDataDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionDataDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPartitionOptionDataDirectory(s)
	}
}

func (s *PartitionOptionDataDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPartitionOptionDataDirectory(s)
	}
}

func (p *StmtParser) PartitionOption() (localctx IPartitionOptionContext) {
	this := p
	_ = this

	localctx = NewPartitionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, StmtParserRULE_partitionOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(944)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case StmtParserDEFAULT, StmtParserENGINE, StmtParserSTORAGE:
		localctx = NewPartitionOptionEngineContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(897)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserDEFAULT {
			{
				p.SetState(896)
				p.Match(StmtParserDEFAULT)
			}

		}
		p.SetState(900)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserSTORAGE {
			{
				p.SetState(899)
				p.Match(StmtParserSTORAGE)
			}

		}
		{
			p.SetState(902)
			p.Match(StmtParserENGINE)
		}
		p.SetState(904)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(903)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(906)
			p.EngineName()
		}

	case StmtParserCOMMENT:
		localctx = NewPartitionOptionCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(907)
			p.Match(StmtParserCOMMENT)
		}
		p.SetState(909)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(908)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(911)

			var _m = p.Match(StmtParserSTRING_LITERAL)

			localctx.(*PartitionOptionCommentContext).comment = _m
		}

	case StmtParserDATA:
		localctx = NewPartitionOptionDataDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(912)
			p.Match(StmtParserDATA)
		}
		{
			p.SetState(913)
			p.Match(StmtParserDIRECTORY)
		}
		p.SetState(915)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(914)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(917)

			var _m = p.Match(StmtParserSTRING_LITERAL)

			localctx.(*PartitionOptionDataDirectoryContext).dataDirectory = _m
		}

	case StmtParserINDEX:
		localctx = NewPartitionOptionIndexDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(918)
			p.Match(StmtParserINDEX)
		}
		{
			p.SetState(919)
			p.Match(StmtParserDIRECTORY)
		}
		p.SetState(921)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(920)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(923)

			var _m = p.Match(StmtParserSTRING_LITERAL)

			localctx.(*PartitionOptionIndexDirectoryContext).indexDirectory = _m
		}

	case StmtParserMAX_ROWS:
		localctx = NewPartitionOptionMaxRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(924)
			p.Match(StmtParserMAX_ROWS)
		}
		p.SetState(926)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(925)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(928)

			var _x = p.DecimalLiteral()

			localctx.(*PartitionOptionMaxRowsContext).maxRows = _x
		}

	case StmtParserMIN_ROWS:
		localctx = NewPartitionOptionMinRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(929)
			p.Match(StmtParserMIN_ROWS)
		}
		p.SetState(931)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(930)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(933)

			var _x = p.DecimalLiteral()

			localctx.(*PartitionOptionMinRowsContext).minRows = _x
		}

	case StmtParserTABLESPACE:
		localctx = NewPartitionOptionTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(934)
			p.Match(StmtParserTABLESPACE)
		}
		p.SetState(936)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(935)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(938)

			var _x = p.Uid()

			localctx.(*PartitionOptionTablespaceContext).tablespace = _x
		}

	case StmtParserNODEGROUP:
		localctx = NewPartitionOptionNodeGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(939)
			p.Match(StmtParserNODEGROUP)
		}
		p.SetState(941)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserEQUAL_SYMBOL {
			{
				p.SetState(940)
				p.Match(StmtParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(943)

			var _x = p.Uid()

			localctx.(*PartitionOptionNodeGroupContext).nodegroup = _x
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFullIdContext is an interface to support dynamic dispatch.
type IFullIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFullIdContext differentiates from other interfaces.
	IsFullIdContext()
}

type FullIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullIdContext() *FullIdContext {
	var p = new(FullIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_fullId
	return p
}

func (*FullIdContext) IsFullIdContext() {}

func NewFullIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullIdContext {
	var p = new(FullIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_fullId

	return p
}

func (s *FullIdContext) GetParser() antlr.Parser { return s.parser }

func (s *FullIdContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *FullIdContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FullIdContext) DOT_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserDOT_ID, 0)
}

func (s *FullIdContext) DOT() antlr.TerminalNode {
	return s.GetToken(StmtParserDOT, 0)
}

func (s *FullIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterFullId(s)
	}
}

func (s *FullIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitFullId(s)
	}
}

func (p *StmtParser) FullId() (localctx IFullIdContext) {
	this := p
	_ = this

	localctx = NewFullIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, StmtParserRULE_fullId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(946)
		p.Uid()
	}
	p.SetState(950)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case StmtParserDOT_ID:
		{
			p.SetState(947)
			p.Match(StmtParserDOT_ID)
		}

	case StmtParserDOT:
		{
			p.SetState(948)
			p.Match(StmtParserDOT)
		}
		{
			p.SetState(949)
			p.Uid()
		}

	case StmtParserAS, StmtParserCHECK, StmtParserCOLLATE, StmtParserCONSTRAINT, StmtParserDEFAULT, StmtParserGENERATED, StmtParserKEY, StmtParserMATCH, StmtParserNOT, StmtParserNULL_LITERAL, StmtParserON, StmtParserPRIMARY, StmtParserREFERENCES, StmtParserUNIQUE, StmtParserSERIAL, StmtParserAUTO_INCREMENT, StmtParserCOLUMN_FORMAT, StmtParserCOMMENT, StmtParserINVISIBLE, StmtParserSTORAGE, StmtParserVISIBLE, StmtParserLR_BRACKET, StmtParserRR_BRACKET, StmtParserCOMMA, StmtParserNULL_SPEC_LITERAL:

	default:
	}

	return localctx
}

// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_tableName
	return p
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (p *StmtParser) TableName() (localctx ITableNameContext) {
	this := p
	_ = this

	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, StmtParserRULE_tableName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(952)
		p.FullId()
	}

	return localctx
}

// IFullColumnNameContext is an interface to support dynamic dispatch.
type IFullColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFullColumnNameContext differentiates from other interfaces.
	IsFullColumnNameContext()
}

type FullColumnNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullColumnNameContext() *FullColumnNameContext {
	var p = new(FullColumnNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_fullColumnName
	return p
}

func (*FullColumnNameContext) IsFullColumnNameContext() {}

func NewFullColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullColumnNameContext {
	var p = new(FullColumnNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_fullColumnName

	return p
}

func (s *FullColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FullColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FullColumnNameContext) AllDottedId() []IDottedIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDottedIdContext); ok {
			len++
		}
	}

	tst := make([]IDottedIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDottedIdContext); ok {
			tst[i] = t.(IDottedIdContext)
			i++
		}
	}

	return tst
}

func (s *FullColumnNameContext) DottedId(i int) IDottedIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDottedIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDottedIdContext)
}

func (s *FullColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterFullColumnName(s)
	}
}

func (s *FullColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitFullColumnName(s)
	}
}

func (p *StmtParser) FullColumnName() (localctx IFullColumnNameContext) {
	this := p
	_ = this

	localctx = NewFullColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, StmtParserRULE_fullColumnName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(966)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(954)
			p.Uid()
		}
		p.SetState(959)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(955)
				p.DottedId()
			}
			p.SetState(957)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(956)
					p.DottedId()
				}

			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(961)
		p.MatchWildcard()

		{
			p.SetState(962)
			p.DottedId()
		}
		p.SetState(964)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(963)
				p.DottedId()
			}

		}

	}

	return localctx
}

// IIndexColumnNameContext is an interface to support dynamic dispatch.
type IIndexColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSortType returns the sortType token.
	GetSortType() antlr.Token

	// SetSortType sets the sortType token.
	SetSortType(antlr.Token)

	// IsIndexColumnNameContext differentiates from other interfaces.
	IsIndexColumnNameContext()
}

type IndexColumnNameContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	sortType antlr.Token
}

func NewEmptyIndexColumnNameContext() *IndexColumnNameContext {
	var p = new(IndexColumnNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_indexColumnName
	return p
}

func (*IndexColumnNameContext) IsIndexColumnNameContext() {}

func NewIndexColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnNameContext {
	var p = new(IndexColumnNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_indexColumnName

	return p
}

func (s *IndexColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnNameContext) GetSortType() antlr.Token { return s.sortType }

func (s *IndexColumnNameContext) SetSortType(v antlr.Token) { s.sortType = v }

func (s *IndexColumnNameContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *IndexColumnNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *IndexColumnNameContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *IndexColumnNameContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *IndexColumnNameContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *IndexColumnNameContext) ASC() antlr.TerminalNode {
	return s.GetToken(StmtParserASC, 0)
}

func (s *IndexColumnNameContext) DESC() antlr.TerminalNode {
	return s.GetToken(StmtParserDESC, 0)
}

func (s *IndexColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIndexColumnName(s)
	}
}

func (s *IndexColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIndexColumnName(s)
	}
}

func (p *StmtParser) IndexColumnName() (localctx IIndexColumnNameContext) {
	this := p
	_ = this

	localctx = NewIndexColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, StmtParserRULE_indexColumnName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(979)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext()) {
	case 1:
		p.SetState(970)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(968)
				p.Uid()
			}

		case 2:
			{
				p.SetState(969)
				p.Match(StmtParserSTRING_LITERAL)
			}

		}
		p.SetState(976)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(972)
				p.Match(StmtParserLR_BRACKET)
			}
			{
				p.SetState(973)
				p.DecimalLiteral()
			}
			{
				p.SetState(974)
				p.Match(StmtParserRR_BRACKET)
			}

		}

	case 2:
		{
			p.SetState(978)
			p.expression(0)
		}

	}
	p.SetState(982)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserASC || _la == StmtParserDESC {
		{
			p.SetState(981)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IndexColumnNameContext).sortType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserASC || _la == StmtParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IndexColumnNameContext).sortType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IMysqlVariableContext is an interface to support dynamic dispatch.
type IMysqlVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMysqlVariableContext differentiates from other interfaces.
	IsMysqlVariableContext()
}

type MysqlVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMysqlVariableContext() *MysqlVariableContext {
	var p = new(MysqlVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_mysqlVariable
	return p
}

func (*MysqlVariableContext) IsMysqlVariableContext() {}

func NewMysqlVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MysqlVariableContext {
	var p = new(MysqlVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_mysqlVariable

	return p
}

func (s *MysqlVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *MysqlVariableContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserLOCAL_ID, 0)
}

func (s *MysqlVariableContext) GLOBAL_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserGLOBAL_ID, 0)
}

func (s *MysqlVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MysqlVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterMysqlVariable(s)
	}
}

func (s *MysqlVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitMysqlVariable(s)
	}
}

func (p *StmtParser) MysqlVariable() (localctx IMysqlVariableContext) {
	this := p
	_ = this

	localctx = NewMysqlVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, StmtParserRULE_mysqlVariable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(984)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserLOCAL_ID || _la == StmtParserGLOBAL_ID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICharsetNameContext is an interface to support dynamic dispatch.
type ICharsetNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharsetNameContext differentiates from other interfaces.
	IsCharsetNameContext()
}

type CharsetNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameContext() *CharsetNameContext {
	var p = new(CharsetNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_charsetName
	return p
}

func (*CharsetNameContext) IsCharsetNameContext() {}

func NewCharsetNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameContext {
	var p = new(CharsetNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_charsetName

	return p
}

func (s *CharsetNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameContext) BINARY() antlr.TerminalNode {
	return s.GetToken(StmtParserBINARY, 0)
}

func (s *CharsetNameContext) CharsetNameBase() ICharsetNameBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameBaseContext)
}

func (s *CharsetNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *CharsetNameContext) CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode {
	return s.GetToken(StmtParserCHARSET_REVERSE_QOUTE_STRING, 0)
}

func (s *CharsetNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCharsetName(s)
	}
}

func (s *CharsetNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCharsetName(s)
	}
}

func (p *StmtParser) CharsetName() (localctx ICharsetNameContext) {
	this := p
	_ = this

	localctx = NewCharsetNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, StmtParserRULE_charsetName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(990)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(986)
			p.Match(StmtParserBINARY)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(987)
			p.CharsetNameBase()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(988)
			p.Match(StmtParserSTRING_LITERAL)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(989)
			p.Match(StmtParserCHARSET_REVERSE_QOUTE_STRING)
		}

	}

	return localctx
}

// ICollationNameContext is an interface to support dynamic dispatch.
type ICollationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollationNameContext differentiates from other interfaces.
	IsCollationNameContext()
}

type CollationNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollationNameContext() *CollationNameContext {
	var p = new(CollationNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_collationName
	return p
}

func (*CollationNameContext) IsCollationNameContext() {}

func NewCollationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollationNameContext {
	var p = new(CollationNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_collationName

	return p
}

func (s *CollationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CollationNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CollationNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *CollationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCollationName(s)
	}
}

func (s *CollationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCollationName(s)
	}
}

func (p *StmtParser) CollationName() (localctx ICollationNameContext) {
	this := p
	_ = this

	localctx = NewCollationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, StmtParserRULE_collationName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(994)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(992)
			p.Uid()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(993)
			p.Match(StmtParserSTRING_LITERAL)
		}

	}

	return localctx
}

// IEngineNameContext is an interface to support dynamic dispatch.
type IEngineNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEngineNameContext differentiates from other interfaces.
	IsEngineNameContext()
}

type EngineNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineNameContext() *EngineNameContext {
	var p = new(EngineNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_engineName
	return p
}

func (*EngineNameContext) IsEngineNameContext() {}

func NewEngineNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineNameContext {
	var p = new(EngineNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_engineName

	return p
}

func (s *EngineNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineNameContext) ARCHIVE() antlr.TerminalNode {
	return s.GetToken(StmtParserARCHIVE, 0)
}

func (s *EngineNameContext) BLACKHOLE() antlr.TerminalNode {
	return s.GetToken(StmtParserBLACKHOLE, 0)
}

func (s *EngineNameContext) CSV() antlr.TerminalNode {
	return s.GetToken(StmtParserCSV, 0)
}

func (s *EngineNameContext) FEDERATED() antlr.TerminalNode {
	return s.GetToken(StmtParserFEDERATED, 0)
}

func (s *EngineNameContext) INNODB() antlr.TerminalNode {
	return s.GetToken(StmtParserINNODB, 0)
}

func (s *EngineNameContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(StmtParserMEMORY, 0)
}

func (s *EngineNameContext) MRG_MYISAM() antlr.TerminalNode {
	return s.GetToken(StmtParserMRG_MYISAM, 0)
}

func (s *EngineNameContext) MYISAM() antlr.TerminalNode {
	return s.GetToken(StmtParserMYISAM, 0)
}

func (s *EngineNameContext) NDB() antlr.TerminalNode {
	return s.GetToken(StmtParserNDB, 0)
}

func (s *EngineNameContext) NDBCLUSTER() antlr.TerminalNode {
	return s.GetToken(StmtParserNDBCLUSTER, 0)
}

func (s *EngineNameContext) PERFORMANCE_SCHEMA() antlr.TerminalNode {
	return s.GetToken(StmtParserPERFORMANCE_SCHEMA, 0)
}

func (s *EngineNameContext) TOKUDB() antlr.TerminalNode {
	return s.GetToken(StmtParserTOKUDB, 0)
}

func (s *EngineNameContext) ID() antlr.TerminalNode {
	return s.GetToken(StmtParserID, 0)
}

func (s *EngineNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *EngineNameContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserREVERSE_QUOTE_ID, 0)
}

func (s *EngineNameContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONNECT, 0)
}

func (s *EngineNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EngineNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterEngineName(s)
	}
}

func (s *EngineNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitEngineName(s)
	}
}

func (p *StmtParser) EngineName() (localctx IEngineNameContext) {
	this := p
	_ = this

	localctx = NewEngineNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, StmtParserRULE_engineName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(996)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserCONNECT || (int64((_la-767)) & ^0x3f) == 0 && ((int64(1)<<(_la-767))&4095) != 0 || (int64((_la-1138)) & ^0x3f) == 0 && ((int64(1)<<(_la-1138))&769) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IUidContext is an interface to support dynamic dispatch.
type IUidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUidContext differentiates from other interfaces.
	IsUidContext()
}

type UidContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUidContext() *UidContext {
	var p = new(UidContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_uid
	return p
}

func (*UidContext) IsUidContext() {}

func NewUidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UidContext {
	var p = new(UidContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_uid

	return p
}

func (s *UidContext) GetParser() antlr.Parser { return s.parser }

func (s *UidContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *UidContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserREVERSE_QUOTE_ID, 0)
}

func (s *UidContext) CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode {
	return s.GetToken(StmtParserCHARSET_REVERSE_QOUTE_STRING, 0)
}

func (s *UidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterUid(s)
	}
}

func (s *UidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitUid(s)
	}
}

func (p *StmtParser) Uid() (localctx IUidContext) {
	this := p
	_ = this

	localctx = NewUidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, StmtParserRULE_uid)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1001)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 149, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(998)
			p.SimpleId()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(999)
			p.Match(StmtParserREVERSE_QUOTE_ID)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1000)
			p.Match(StmtParserCHARSET_REVERSE_QOUTE_STRING)
		}

	}

	return localctx
}

// ISimpleIdContext is an interface to support dynamic dispatch.
type ISimpleIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleIdContext differentiates from other interfaces.
	IsSimpleIdContext()
}

type SimpleIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleIdContext() *SimpleIdContext {
	var p = new(SimpleIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_simpleId
	return p
}

func (*SimpleIdContext) IsSimpleIdContext() {}

func NewSimpleIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleIdContext {
	var p = new(SimpleIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_simpleId

	return p
}

func (s *SimpleIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleIdContext) ID() antlr.TerminalNode {
	return s.GetToken(StmtParserID, 0)
}

func (s *SimpleIdContext) CharsetNameBase() ICharsetNameBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameBaseContext)
}

func (s *SimpleIdContext) TransactionLevelBase() ITransactionLevelBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionLevelBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionLevelBaseContext)
}

func (s *SimpleIdContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *SimpleIdContext) PrivilegesBase() IPrivilegesBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegesBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegesBaseContext)
}

func (s *SimpleIdContext) IntervalTypeBase() IIntervalTypeBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeBaseContext)
}

func (s *SimpleIdContext) DataTypeBase() IDataTypeBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeBaseContext)
}

func (s *SimpleIdContext) KeywordsCanBeId() IKeywordsCanBeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsCanBeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsCanBeIdContext)
}

func (s *SimpleIdContext) ScalarFunctionName() IScalarFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarFunctionNameContext)
}

func (s *SimpleIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSimpleId(s)
	}
}

func (s *SimpleIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSimpleId(s)
	}
}

func (p *StmtParser) SimpleId() (localctx ISimpleIdContext) {
	this := p
	_ = this

	localctx = NewSimpleIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, StmtParserRULE_simpleId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1012)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1003)
			p.Match(StmtParserID)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1004)
			p.CharsetNameBase()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1005)
			p.TransactionLevelBase()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1006)
			p.EngineName()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1007)
			p.PrivilegesBase()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1008)
			p.IntervalTypeBase()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1009)
			p.DataTypeBase()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1010)
			p.KeywordsCanBeId()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1011)
			p.ScalarFunctionName()
		}

	}

	return localctx
}

// IDottedIdContext is an interface to support dynamic dispatch.
type IDottedIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDottedIdContext differentiates from other interfaces.
	IsDottedIdContext()
}

type DottedIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDottedIdContext() *DottedIdContext {
	var p = new(DottedIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_dottedId
	return p
}

func (*DottedIdContext) IsDottedIdContext() {}

func NewDottedIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DottedIdContext {
	var p = new(DottedIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_dottedId

	return p
}

func (s *DottedIdContext) GetParser() antlr.Parser { return s.parser }

func (s *DottedIdContext) DOT_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserDOT_ID, 0)
}

func (s *DottedIdContext) DOT() antlr.TerminalNode {
	return s.GetToken(StmtParserDOT, 0)
}

func (s *DottedIdContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DottedIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DottedIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DottedIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterDottedId(s)
	}
}

func (s *DottedIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitDottedId(s)
	}
}

func (p *StmtParser) DottedId() (localctx IDottedIdContext) {
	this := p
	_ = this

	localctx = NewDottedIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, StmtParserRULE_dottedId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1017)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case StmtParserDOT_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1014)
			p.Match(StmtParserDOT_ID)
		}

	case StmtParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1015)
			p.Match(StmtParserDOT)
		}
		{
			p.SetState(1016)
			p.Uid()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDecimalLiteralContext is an interface to support dynamic dispatch.
type IDecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecimalLiteralContext differentiates from other interfaces.
	IsDecimalLiteralContext()
}

type DecimalLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalLiteralContext() *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_decimalLiteral
	return p
}

func (*DecimalLiteralContext) IsDecimalLiteralContext() {}

func NewDecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_decimalLiteral

	return p
}

func (s *DecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserDECIMAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserZERO_DECIMAL, 0)
}

func (s *DecimalLiteralContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserONE_DECIMAL, 0)
}

func (s *DecimalLiteralContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserTWO_DECIMAL, 0)
}

func (s *DecimalLiteralContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserREAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

func (p *StmtParser) DecimalLiteral() (localctx IDecimalLiteralContext) {
	this := p
	_ = this

	localctx = NewDecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, StmtParserRULE_decimalLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1019)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-1128)) & ^0x3f) == 0 && ((int64(1)<<(_la-1128))&10247) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFileSizeLiteralContext is an interface to support dynamic dispatch.
type IFileSizeLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileSizeLiteralContext differentiates from other interfaces.
	IsFileSizeLiteralContext()
}

type FileSizeLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileSizeLiteralContext() *FileSizeLiteralContext {
	var p = new(FileSizeLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_fileSizeLiteral
	return p
}

func (*FileSizeLiteralContext) IsFileSizeLiteralContext() {}

func NewFileSizeLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileSizeLiteralContext {
	var p = new(FileSizeLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_fileSizeLiteral

	return p
}

func (s *FileSizeLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FileSizeLiteralContext) FILESIZE_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserFILESIZE_LITERAL, 0)
}

func (s *FileSizeLiteralContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *FileSizeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileSizeLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileSizeLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterFileSizeLiteral(s)
	}
}

func (s *FileSizeLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitFileSizeLiteral(s)
	}
}

func (p *StmtParser) FileSizeLiteral() (localctx IFileSizeLiteralContext) {
	this := p
	_ = this

	localctx = NewFileSizeLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, StmtParserRULE_fileSizeLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1023)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case StmtParserFILESIZE_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1021)
			p.Match(StmtParserFILESIZE_LITERAL)
		}

	case StmtParserZERO_DECIMAL, StmtParserONE_DECIMAL, StmtParserTWO_DECIMAL, StmtParserDECIMAL_LITERAL, StmtParserREAL_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1022)
			p.DecimalLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_stringLiteral
	return p
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(StmtParserSTRING_LITERAL)
}

func (s *StringLiteralContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, i)
}

func (s *StringLiteralContext) START_NATIONAL_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTART_NATIONAL_STRING_LITERAL, 0)
}

func (s *StringLiteralContext) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_CHARSET_NAME, 0)
}

func (s *StringLiteralContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLLATE, 0)
}

func (s *StringLiteralContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *StmtParser) StringLiteral() (localctx IStringLiteralContext) {
	this := p
	_ = this

	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, StmtParserRULE_stringLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1048)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1030)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case StmtParserSTRING_LITERAL, StmtParserSTRING_CHARSET_NAME:
			p.SetState(1026)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == StmtParserSTRING_CHARSET_NAME {
				{
					p.SetState(1025)
					p.Match(StmtParserSTRING_CHARSET_NAME)
				}

			}
			{
				p.SetState(1028)
				p.Match(StmtParserSTRING_LITERAL)
			}

		case StmtParserSTART_NATIONAL_STRING_LITERAL:
			{
				p.SetState(1029)
				p.Match(StmtParserSTART_NATIONAL_STRING_LITERAL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(1033)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1032)
					p.Match(StmtParserSTRING_LITERAL)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1035)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1042)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case StmtParserSTRING_LITERAL, StmtParserSTRING_CHARSET_NAME:
			p.SetState(1038)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == StmtParserSTRING_CHARSET_NAME {
				{
					p.SetState(1037)
					p.Match(StmtParserSTRING_CHARSET_NAME)
				}

			}
			{
				p.SetState(1040)
				p.Match(StmtParserSTRING_LITERAL)
			}

		case StmtParserSTART_NATIONAL_STRING_LITERAL:
			{
				p.SetState(1041)
				p.Match(StmtParserSTART_NATIONAL_STRING_LITERAL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(1046)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1044)
				p.Match(StmtParserCOLLATE)
			}
			{
				p.SetState(1045)
				p.CollationName()
			}

		}

	}

	return localctx
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_booleanLiteral
	return p
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(StmtParserTRUE, 0)
}

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(StmtParserFALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *StmtParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	this := p
	_ = this

	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, StmtParserRULE_booleanLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1050)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserFALSE || _la == StmtParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IHexadecimalLiteralContext is an interface to support dynamic dispatch.
type IHexadecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHexadecimalLiteralContext differentiates from other interfaces.
	IsHexadecimalLiteralContext()
}

type HexadecimalLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexadecimalLiteralContext() *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_hexadecimalLiteral
	return p
}

func (*HexadecimalLiteralContext) IsHexadecimalLiteralContext() {}

func NewHexadecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_hexadecimalLiteral

	return p
}

func (s *HexadecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *HexadecimalLiteralContext) HEXADECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserHEXADECIMAL_LITERAL, 0)
}

func (s *HexadecimalLiteralContext) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_CHARSET_NAME, 0)
}

func (s *HexadecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexadecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexadecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterHexadecimalLiteral(s)
	}
}

func (s *HexadecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitHexadecimalLiteral(s)
	}
}

func (p *StmtParser) HexadecimalLiteral() (localctx IHexadecimalLiteralContext) {
	this := p
	_ = this

	localctx = NewHexadecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, StmtParserRULE_hexadecimalLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1053)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserSTRING_CHARSET_NAME {
		{
			p.SetState(1052)
			p.Match(StmtParserSTRING_CHARSET_NAME)
		}

	}
	{
		p.SetState(1055)
		p.Match(StmtParserHEXADECIMAL_LITERAL)
	}

	return localctx
}

// INullNotnullContext is an interface to support dynamic dispatch.
type INullNotnullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNullNotnullContext differentiates from other interfaces.
	IsNullNotnullContext()
}

type NullNotnullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullNotnullContext() *NullNotnullContext {
	var p = new(NullNotnullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_nullNotnull
	return p
}

func (*NullNotnullContext) IsNullNotnullContext() {}

func NewNullNotnullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullNotnullContext {
	var p = new(NullNotnullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_nullNotnull

	return p
}

func (s *NullNotnullContext) GetParser() antlr.Parser { return s.parser }

func (s *NullNotnullContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNULL_LITERAL, 0)
}

func (s *NullNotnullContext) NULL_SPEC_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNULL_SPEC_LITERAL, 0)
}

func (s *NullNotnullContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *NullNotnullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullNotnullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullNotnullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterNullNotnull(s)
	}
}

func (s *NullNotnullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitNullNotnull(s)
	}
}

func (p *StmtParser) NullNotnull() (localctx INullNotnullContext) {
	this := p
	_ = this

	localctx = NewNullNotnullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, StmtParserRULE_nullNotnull)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1058)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserNOT {
		{
			p.SetState(1057)
			p.Match(StmtParserNOT)
		}

	}
	{
		p.SetState(1060)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserNULL_LITERAL || _la == StmtParserNULL_SPEC_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNullLiteral returns the nullLiteral token.
	GetNullLiteral() antlr.Token

	// SetNullLiteral sets the nullLiteral token.
	SetNullLiteral(antlr.Token)

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	nullLiteral antlr.Token
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_constant
	return p
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) GetNullLiteral() antlr.Token { return s.nullLiteral }

func (s *ConstantContext) SetNullLiteral(v antlr.Token) { s.nullLiteral = v }

func (s *ConstantContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ConstantContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ConstantContext) MINUS() antlr.TerminalNode {
	return s.GetToken(StmtParserMINUS, 0)
}

func (s *ConstantContext) HexadecimalLiteral() IHexadecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexadecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexadecimalLiteralContext)
}

func (s *ConstantContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *ConstantContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserREAL_LITERAL, 0)
}

func (s *ConstantContext) BIT_STRING() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_STRING, 0)
}

func (s *ConstantContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNULL_LITERAL, 0)
}

func (s *ConstantContext) NULL_SPEC_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNULL_SPEC_LITERAL, 0)
}

func (s *ConstantContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (p *StmtParser) Constant() (localctx IConstantContext) {
	this := p
	_ = this

	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, StmtParserRULE_constant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1074)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 163, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1062)
			p.StringLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1063)
			p.DecimalLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1064)
			p.Match(StmtParserMINUS)
		}
		{
			p.SetState(1065)
			p.DecimalLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1066)
			p.HexadecimalLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1067)
			p.BooleanLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1068)
			p.Match(StmtParserREAL_LITERAL)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1069)
			p.Match(StmtParserBIT_STRING)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(1071)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserNOT {
			{
				p.SetState(1070)
				p.Match(StmtParserNOT)
			}

		}
		{
			p.SetState(1073)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConstantContext).nullLiteral = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserNULL_LITERAL || _la == StmtParserNULL_SPEC_LITERAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConstantContext).nullLiteral = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_dataType
	return p
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) CopyFrom(ctx *DataTypeContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SpatialDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewSpatialDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpatialDataTypeContext {
	var p = new(SpatialDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *SpatialDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *SpatialDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *SpatialDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpatialDataTypeContext) GEOMETRYCOLLECTION() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMETRYCOLLECTION, 0)
}

func (s *SpatialDataTypeContext) GEOMCOLLECTION() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMCOLLECTION, 0)
}

func (s *SpatialDataTypeContext) LINESTRING() antlr.TerminalNode {
	return s.GetToken(StmtParserLINESTRING, 0)
}

func (s *SpatialDataTypeContext) MULTILINESTRING() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTILINESTRING, 0)
}

func (s *SpatialDataTypeContext) MULTIPOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTIPOINT, 0)
}

func (s *SpatialDataTypeContext) MULTIPOLYGON() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTIPOLYGON, 0)
}

func (s *SpatialDataTypeContext) POINT() antlr.TerminalNode {
	return s.GetToken(StmtParserPOINT, 0)
}

func (s *SpatialDataTypeContext) POLYGON() antlr.TerminalNode {
	return s.GetToken(StmtParserPOLYGON, 0)
}

func (s *SpatialDataTypeContext) GEOMETRY() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMETRY, 0)
}

func (s *SpatialDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSpatialDataType(s)
	}
}

func (s *SpatialDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSpatialDataType(s)
	}
}

type FloatDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewFloatDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FloatDataTypeContext {
	var p = new(FloatDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *FloatDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *FloatDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *FloatDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatDataTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserDECIMAL, 0)
}

func (s *FloatDataTypeContext) DEC() antlr.TerminalNode {
	return s.GetToken(StmtParserDEC, 0)
}

func (s *FloatDataTypeContext) FIXED() antlr.TerminalNode {
	return s.GetToken(StmtParserFIXED, 0)
}

func (s *FloatDataTypeContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(StmtParserNUMERIC, 0)
}

func (s *FloatDataTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(StmtParserFLOAT, 0)
}

func (s *FloatDataTypeContext) FLOAT4() antlr.TerminalNode {
	return s.GetToken(StmtParserFLOAT4, 0)
}

func (s *FloatDataTypeContext) FLOAT8() antlr.TerminalNode {
	return s.GetToken(StmtParserFLOAT8, 0)
}

func (s *FloatDataTypeContext) LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoOptionalDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoOptionalDimensionContext)
}

func (s *FloatDataTypeContext) AllSIGNED() []antlr.TerminalNode {
	return s.GetTokens(StmtParserSIGNED)
}

func (s *FloatDataTypeContext) SIGNED(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserSIGNED, i)
}

func (s *FloatDataTypeContext) AllUNSIGNED() []antlr.TerminalNode {
	return s.GetTokens(StmtParserUNSIGNED)
}

func (s *FloatDataTypeContext) UNSIGNED(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserUNSIGNED, i)
}

func (s *FloatDataTypeContext) AllZEROFILL() []antlr.TerminalNode {
	return s.GetTokens(StmtParserZEROFILL)
}

func (s *FloatDataTypeContext) ZEROFILL(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserZEROFILL, i)
}

func (s *FloatDataTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(StmtParserDOUBLE, 0)
}

func (s *FloatDataTypeContext) PRECISION() antlr.TerminalNode {
	return s.GetToken(StmtParserPRECISION, 0)
}

func (s *FloatDataTypeContext) LengthTwoDimension() ILengthTwoDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoDimensionContext)
}

func (s *FloatDataTypeContext) REAL() antlr.TerminalNode {
	return s.GetToken(StmtParserREAL, 0)
}

func (s *FloatDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterFloatDataType(s)
	}
}

func (s *FloatDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitFloatDataType(s)
	}
}

type IntegerDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewIntegerDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerDataTypeContext {
	var p = new(IntegerDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *IntegerDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *IntegerDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *IntegerDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerDataTypeContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(StmtParserTINYINT, 0)
}

func (s *IntegerDataTypeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(StmtParserSMALLINT, 0)
}

func (s *IntegerDataTypeContext) MEDIUMINT() antlr.TerminalNode {
	return s.GetToken(StmtParserMEDIUMINT, 0)
}

func (s *IntegerDataTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(StmtParserINT, 0)
}

func (s *IntegerDataTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(StmtParserINTEGER, 0)
}

func (s *IntegerDataTypeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(StmtParserBIGINT, 0)
}

func (s *IntegerDataTypeContext) MIDDLEINT() antlr.TerminalNode {
	return s.GetToken(StmtParserMIDDLEINT, 0)
}

func (s *IntegerDataTypeContext) INT1() antlr.TerminalNode {
	return s.GetToken(StmtParserINT1, 0)
}

func (s *IntegerDataTypeContext) INT2() antlr.TerminalNode {
	return s.GetToken(StmtParserINT2, 0)
}

func (s *IntegerDataTypeContext) INT3() antlr.TerminalNode {
	return s.GetToken(StmtParserINT3, 0)
}

func (s *IntegerDataTypeContext) INT4() antlr.TerminalNode {
	return s.GetToken(StmtParserINT4, 0)
}

func (s *IntegerDataTypeContext) INT8() antlr.TerminalNode {
	return s.GetToken(StmtParserINT8, 0)
}

func (s *IntegerDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *IntegerDataTypeContext) AllSIGNED() []antlr.TerminalNode {
	return s.GetTokens(StmtParserSIGNED)
}

func (s *IntegerDataTypeContext) SIGNED(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserSIGNED, i)
}

func (s *IntegerDataTypeContext) AllUNSIGNED() []antlr.TerminalNode {
	return s.GetTokens(StmtParserUNSIGNED)
}

func (s *IntegerDataTypeContext) UNSIGNED(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserUNSIGNED, i)
}

func (s *IntegerDataTypeContext) AllZEROFILL() []antlr.TerminalNode {
	return s.GetTokens(StmtParserZEROFILL)
}

func (s *IntegerDataTypeContext) ZEROFILL(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserZEROFILL, i)
}

func (s *IntegerDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIntegerDataType(s)
	}
}

func (s *IntegerDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIntegerDataType(s)
	}
}

type SpecialDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewSpecialDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialDataTypeContext {
	var p = new(SpecialDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *SpecialDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *SpecialDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *SpecialDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialDataTypeContext) BOOL() antlr.TerminalNode {
	return s.GetToken(StmtParserBOOL, 0)
}

func (s *SpecialDataTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(StmtParserBOOLEAN, 0)
}

func (s *SpecialDataTypeContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSERIAL, 0)
}

func (s *SpecialDataTypeContext) BIT() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT, 0)
}

func (s *SpecialDataTypeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserYEAR, 0)
}

func (s *SpecialDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *SpecialDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSpecialDataType(s)
	}
}

func (s *SpecialDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSpecialDataType(s)
	}
}

type StringDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewStringDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringDataTypeContext {
	var p = new(StringDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *StringDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *StringDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *StringDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(StmtParserCHAR, 0)
}

func (s *StringDataTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(StmtParserCHARACTER, 0)
}

func (s *StringDataTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(StmtParserVARCHAR, 0)
}

func (s *StringDataTypeContext) TINYTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserTINYTEXT, 0)
}

func (s *StringDataTypeContext) TEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserTEXT, 0)
}

func (s *StringDataTypeContext) MEDIUMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserMEDIUMTEXT, 0)
}

func (s *StringDataTypeContext) LONGTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserLONGTEXT, 0)
}

func (s *StringDataTypeContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(StmtParserNCHAR, 0)
}

func (s *StringDataTypeContext) NVARCHAR() antlr.TerminalNode {
	return s.GetToken(StmtParserNVARCHAR, 0)
}

func (s *StringDataTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(StmtParserLONG, 0)
}

func (s *StringDataTypeContext) VARYING() antlr.TerminalNode {
	return s.GetToken(StmtParserVARYING, 0)
}

func (s *StringDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *StringDataTypeContext) AllBINARY() []antlr.TerminalNode {
	return s.GetTokens(StmtParserBINARY)
}

func (s *StringDataTypeContext) BINARY(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserBINARY, i)
}

func (s *StringDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *StringDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *StringDataTypeContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLLATE, 0)
}

func (s *StringDataTypeContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *StringDataTypeContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNATIONAL, 0)
}

func (s *StringDataTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(StmtParserVARBINARY, 0)
}

func (s *StringDataTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON, 0)
}

func (s *StringDataTypeContext) CollectionOptions() ICollectionOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollectionOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollectionOptionsContext)
}

func (s *StringDataTypeContext) ENUM() antlr.TerminalNode {
	return s.GetToken(StmtParserENUM, 0)
}

func (s *StringDataTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(StmtParserSET, 0)
}

func (s *StringDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterStringDataType(s)
	}
}

func (s *StringDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitStringDataType(s)
	}
}

type BinaryDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewBinaryDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryDataTypeContext {
	var p = new(BinaryDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *BinaryDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *BinaryDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *BinaryDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(StmtParserBINARY, 0)
}

func (s *BinaryDataTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(StmtParserVARBINARY, 0)
}

func (s *BinaryDataTypeContext) BLOB() antlr.TerminalNode {
	return s.GetToken(StmtParserBLOB, 0)
}

func (s *BinaryDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *BinaryDataTypeContext) TINYBLOB() antlr.TerminalNode {
	return s.GetToken(StmtParserTINYBLOB, 0)
}

func (s *BinaryDataTypeContext) MEDIUMBLOB() antlr.TerminalNode {
	return s.GetToken(StmtParserMEDIUMBLOB, 0)
}

func (s *BinaryDataTypeContext) LONGBLOB() antlr.TerminalNode {
	return s.GetToken(StmtParserLONGBLOB, 0)
}

func (s *BinaryDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterBinaryDataType(s)
	}
}

func (s *BinaryDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitBinaryDataType(s)
	}
}

type TimeDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewTimeDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeDataTypeContext {
	var p = new(TimeDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *TimeDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *TimeDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *TimeDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeDataTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(StmtParserTIME, 0)
}

func (s *TimeDataTypeContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserTIMESTAMP, 0)
}

func (s *TimeDataTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(StmtParserDATETIME, 0)
}

func (s *TimeDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *TimeDataTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(StmtParserDATE, 0)
}

func (s *TimeDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTimeDataType(s)
	}
}

func (s *TimeDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTimeDataType(s)
	}
}

func (p *StmtParser) DataType() (localctx IDataTypeContext) {
	this := p
	_ = this

	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, StmtParserRULE_dataType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1211)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 194, p.GetParserRuleContext()) {
	case 1:
		localctx = NewIntegerDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1076)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IntegerDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-190)) & ^0x3f) == 0 && ((int64(1)<<(_la-190))&4095) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IntegerDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1078)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1077)
				p.LengthOneDimension()
			}

		}
		p.SetState(1083)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserUNSIGNED || _la == StmtParserZEROFILL || _la == StmtParserSIGNED {
			{
				p.SetState(1080)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StmtParserUNSIGNED || _la == StmtParserZEROFILL || _la == StmtParserSIGNED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(1085)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewFloatDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1086)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FloatDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-205)) & ^0x3f) == 0 && ((int64(1)<<(_la-205))&63) != 0 || _la == StmtParserFIXED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FloatDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1088)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1087)
				p.LengthTwoOptionalDimension()
			}

		}
		p.SetState(1093)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserUNSIGNED || _la == StmtParserZEROFILL || _la == StmtParserSIGNED {
			{
				p.SetState(1090)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StmtParserUNSIGNED || _la == StmtParserZEROFILL || _la == StmtParserSIGNED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(1095)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewFloatDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1096)

			var _m = p.Match(StmtParserDOUBLE)

			localctx.(*FloatDataTypeContext).typeName = _m
		}
		p.SetState(1098)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserPRECISION {
			{
				p.SetState(1097)
				p.Match(StmtParserPRECISION)
			}

		}
		p.SetState(1101)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1100)
				p.LengthTwoDimension()
			}

		}
		p.SetState(1106)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserUNSIGNED || _la == StmtParserZEROFILL || _la == StmtParserSIGNED {
			{
				p.SetState(1103)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StmtParserUNSIGNED || _la == StmtParserZEROFILL || _la == StmtParserSIGNED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(1108)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 4:
		localctx = NewFloatDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1109)

			var _m = p.Match(StmtParserREAL)

			localctx.(*FloatDataTypeContext).typeName = _m
		}
		p.SetState(1111)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1110)
				p.LengthTwoDimension()
			}

		}
		p.SetState(1116)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserUNSIGNED || _la == StmtParserZEROFILL || _la == StmtParserSIGNED {
			{
				p.SetState(1113)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StmtParserUNSIGNED || _la == StmtParserZEROFILL || _la == StmtParserSIGNED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(1118)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 5:
		localctx = NewTimeDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1119)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TimeDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-212)) & ^0x3f) == 0 && ((int64(1)<<(_la-212))&7) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TimeDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1121)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1120)
				p.LengthOneDimension()
			}

		}

	case 6:
		localctx = NewTimeDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1123)
			p.Match(StmtParserDATE)
		}

	case 7:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1124)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserCHARACTER || (int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&31239) != 0 || _la == StmtParserNCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1126)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserVARYING {
			{
				p.SetState(1125)
				p.Match(StmtParserVARYING)
			}

		}
		p.SetState(1129)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1128)
				p.LengthOneDimension()
			}

		}
		p.SetState(1132)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1131)
				p.Match(StmtParserBINARY)
			}

		}
		p.SetState(1137)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCHARACTER || _la == StmtParserCHAR || _la == StmtParserCHARSET {
			{
				p.SetState(1134)
				p.CharSet()
			}
			{
				p.SetState(1135)
				p.CharsetName()
			}

		}
		p.SetState(1142)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1139)
				p.Match(StmtParserCOLLATE)
			}
			{
				p.SetState(1140)
				p.CollationName()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1141)
				p.Match(StmtParserBINARY)
			}

		}

	case 8:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1144)
			p.Match(StmtParserNATIONAL)
		}
		{
			p.SetState(1145)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserCHARACTER || _la == StmtParserVARCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1147)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1146)
				p.LengthOneDimension()
			}

		}
		p.SetState(1150)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserBINARY {
			{
				p.SetState(1149)
				p.Match(StmtParserBINARY)
			}

		}

	case 9:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1152)
			p.Match(StmtParserNCHAR)
		}
		{
			p.SetState(1153)

			var _m = p.Match(StmtParserVARCHAR)

			localctx.(*StringDataTypeContext).typeName = _m
		}
		p.SetState(1155)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1154)
				p.LengthOneDimension()
			}

		}
		p.SetState(1158)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserBINARY {
			{
				p.SetState(1157)
				p.Match(StmtParserBINARY)
			}

		}

	case 10:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1160)
			p.Match(StmtParserNATIONAL)
		}
		{
			p.SetState(1161)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserCHARACTER || _la == StmtParserCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1162)
			p.Match(StmtParserVARYING)
		}
		p.SetState(1164)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1163)
				p.LengthOneDimension()
			}

		}
		p.SetState(1167)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserBINARY {
			{
				p.SetState(1166)
				p.Match(StmtParserBINARY)
			}

		}

	case 11:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1169)

			var _m = p.Match(StmtParserLONG)

			localctx.(*StringDataTypeContext).typeName = _m
		}
		p.SetState(1171)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserVARCHAR {
			{
				p.SetState(1170)
				p.Match(StmtParserVARCHAR)
			}

		}
		p.SetState(1174)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserBINARY {
			{
				p.SetState(1173)
				p.Match(StmtParserBINARY)
			}

		}
		p.SetState(1179)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCHARACTER || _la == StmtParserCHAR || _la == StmtParserCHARSET {
			{
				p.SetState(1176)
				p.CharSet()
			}
			{
				p.SetState(1177)
				p.CharsetName()
			}

		}
		p.SetState(1183)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 188, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1181)
				p.Match(StmtParserCOLLATE)
			}
			{
				p.SetState(1182)
				p.CollationName()
			}

		}

	case 12:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		p.SetState(1188)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case StmtParserLONG:
			{
				p.SetState(1185)
				p.Match(StmtParserLONG)
			}
			{
				p.SetState(1186)
				p.Match(StmtParserVARBINARY)
			}

		case StmtParserJSON:
			{
				p.SetState(1187)
				p.Match(StmtParserJSON)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 13:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1190)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserSET || _la == StmtParserENUM) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1191)
			p.CollectionOptions()
		}
		p.SetState(1193)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserBINARY {
			{
				p.SetState(1192)
				p.Match(StmtParserBINARY)
			}

		}
		p.SetState(1198)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCHARACTER || _la == StmtParserCHAR || _la == StmtParserCHARSET {
			{
				p.SetState(1195)
				p.CharSet()
			}
			{
				p.SetState(1196)
				p.CharsetName()
			}

		}

	case 14:
		localctx = NewBinaryDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1200)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*BinaryDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-220)) & ^0x3f) == 0 && ((int64(1)<<(_la-220))&11) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*BinaryDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1202)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1201)
				p.LengthOneDimension()
			}

		}

	case 15:
		localctx = NewBinaryDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1204)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*BinaryDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-222)) & ^0x3f) == 0 && ((int64(1)<<(_la-222))&21) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*BinaryDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 16:
		localctx = NewSpecialDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1205)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SpecialDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserSERIAL || _la == StmtParserBOOL || _la == StmtParserBOOLEAN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SpecialDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 17:
		localctx = NewSpecialDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1206)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SpecialDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserYEAR || _la == StmtParserBIT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SpecialDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1208)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1207)
				p.LengthOneDimension()
			}

		}

	case 18:
		localctx = NewSpatialDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1210)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SpatialDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-783)) & ^0x3f) == 0 && ((int64(1)<<(_la-783))&511) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SpatialDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// ICollectionOptionsContext is an interface to support dynamic dispatch.
type ICollectionOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollectionOptionsContext differentiates from other interfaces.
	IsCollectionOptionsContext()
}

type CollectionOptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectionOptionsContext() *CollectionOptionsContext {
	var p = new(CollectionOptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_collectionOptions
	return p
}

func (*CollectionOptionsContext) IsCollectionOptionsContext() {}

func NewCollectionOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectionOptionsContext {
	var p = new(CollectionOptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_collectionOptions

	return p
}

func (s *CollectionOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectionOptionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *CollectionOptionsContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(StmtParserSTRING_LITERAL)
}

func (s *CollectionOptionsContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, i)
}

func (s *CollectionOptionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *CollectionOptionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *CollectionOptionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *CollectionOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectionOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCollectionOptions(s)
	}
}

func (s *CollectionOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCollectionOptions(s)
	}
}

func (p *StmtParser) CollectionOptions() (localctx ICollectionOptionsContext) {
	this := p
	_ = this

	localctx = NewCollectionOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, StmtParserRULE_collectionOptions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1213)
		p.Match(StmtParserLR_BRACKET)
	}
	{
		p.SetState(1214)
		p.Match(StmtParserSTRING_LITERAL)
	}
	p.SetState(1219)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == StmtParserCOMMA {
		{
			p.SetState(1215)
			p.Match(StmtParserCOMMA)
		}
		{
			p.SetState(1216)
			p.Match(StmtParserSTRING_LITERAL)
		}

		p.SetState(1221)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1222)
		p.Match(StmtParserRR_BRACKET)
	}

	return localctx
}

// IConvertedDataTypeContext is an interface to support dynamic dispatch.
type IConvertedDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTypeName returns the typeName token.
	GetTypeName() antlr.Token

	// SetTypeName sets the typeName token.
	SetTypeName(antlr.Token)

	// IsConvertedDataTypeContext differentiates from other interfaces.
	IsConvertedDataTypeContext()
}

type ConvertedDataTypeContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	typeName antlr.Token
}

func NewEmptyConvertedDataTypeContext() *ConvertedDataTypeContext {
	var p = new(ConvertedDataTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_convertedDataType
	return p
}

func (*ConvertedDataTypeContext) IsConvertedDataTypeContext() {}

func NewConvertedDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConvertedDataTypeContext {
	var p = new(ConvertedDataTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_convertedDataType

	return p
}

func (s *ConvertedDataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ConvertedDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *ConvertedDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *ConvertedDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(StmtParserCHAR, 0)
}

func (s *ConvertedDataTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(StmtParserDECIMAL, 0)
}

func (s *ConvertedDataTypeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(StmtParserSIGNED, 0)
}

func (s *ConvertedDataTypeContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(StmtParserUNSIGNED, 0)
}

func (s *ConvertedDataTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(StmtParserARRAY, 0)
}

func (s *ConvertedDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(StmtParserBINARY, 0)
}

func (s *ConvertedDataTypeContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(StmtParserNCHAR, 0)
}

func (s *ConvertedDataTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(StmtParserDATE, 0)
}

func (s *ConvertedDataTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(StmtParserDATETIME, 0)
}

func (s *ConvertedDataTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(StmtParserTIME, 0)
}

func (s *ConvertedDataTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON, 0)
}

func (s *ConvertedDataTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(StmtParserINT, 0)
}

func (s *ConvertedDataTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(StmtParserINTEGER, 0)
}

func (s *ConvertedDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *ConvertedDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *ConvertedDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *ConvertedDataTypeContext) LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoOptionalDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoOptionalDimensionContext)
}

func (s *ConvertedDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertedDataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConvertedDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterConvertedDataType(s)
	}
}

func (s *ConvertedDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitConvertedDataType(s)
	}
}

func (p *StmtParser) ConvertedDataType() (localctx IConvertedDataTypeContext) {
	this := p
	_ = this

	localctx = NewConvertedDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, StmtParserRULE_convertedDataType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1246)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case StmtParserBINARY, StmtParserNCHAR:
		{
			p.SetState(1224)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConvertedDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserBINARY || _la == StmtParserNCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConvertedDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1226)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1225)
				p.LengthOneDimension()
			}

		}

	case StmtParserCHAR:
		{
			p.SetState(1228)

			var _m = p.Match(StmtParserCHAR)

			localctx.(*ConvertedDataTypeContext).typeName = _m
		}
		p.SetState(1230)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1229)
				p.LengthOneDimension()
			}

		}
		p.SetState(1235)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserCHARACTER || _la == StmtParserCHAR || _la == StmtParserCHARSET {
			{
				p.SetState(1232)
				p.CharSet()
			}
			{
				p.SetState(1233)
				p.CharsetName()
			}

		}

	case StmtParserINT, StmtParserINTEGER, StmtParserDATE, StmtParserTIME, StmtParserDATETIME, StmtParserJSON:
		{
			p.SetState(1237)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConvertedDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&1441857) != 0 || _la == StmtParserJSON) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConvertedDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case StmtParserDECIMAL:
		{
			p.SetState(1238)

			var _m = p.Match(StmtParserDECIMAL)

			localctx.(*ConvertedDataTypeContext).typeName = _m
		}
		p.SetState(1240)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1239)
				p.LengthTwoOptionalDimension()
			}

		}

	case StmtParserUNSIGNED, StmtParserSIGNED:
		{
			p.SetState(1242)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserUNSIGNED || _la == StmtParserSIGNED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1244)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserINTEGER {
			{
				p.SetState(1243)
				p.Match(StmtParserINTEGER)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1249)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserARRAY {
		{
			p.SetState(1248)
			p.Match(StmtParserARRAY)
		}

	}

	return localctx
}

// ILengthOneDimensionContext is an interface to support dynamic dispatch.
type ILengthOneDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLengthOneDimensionContext differentiates from other interfaces.
	IsLengthOneDimensionContext()
}

type LengthOneDimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthOneDimensionContext() *LengthOneDimensionContext {
	var p = new(LengthOneDimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_lengthOneDimension
	return p
}

func (*LengthOneDimensionContext) IsLengthOneDimensionContext() {}

func NewLengthOneDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthOneDimensionContext {
	var p = new(LengthOneDimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_lengthOneDimension

	return p
}

func (s *LengthOneDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthOneDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *LengthOneDimensionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthOneDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *LengthOneDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthOneDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthOneDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterLengthOneDimension(s)
	}
}

func (s *LengthOneDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitLengthOneDimension(s)
	}
}

func (p *StmtParser) LengthOneDimension() (localctx ILengthOneDimensionContext) {
	this := p
	_ = this

	localctx = NewLengthOneDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, StmtParserRULE_lengthOneDimension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1251)
		p.Match(StmtParserLR_BRACKET)
	}
	{
		p.SetState(1252)
		p.DecimalLiteral()
	}
	{
		p.SetState(1253)
		p.Match(StmtParserRR_BRACKET)
	}

	return localctx
}

// ILengthTwoDimensionContext is an interface to support dynamic dispatch.
type ILengthTwoDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLengthTwoDimensionContext differentiates from other interfaces.
	IsLengthTwoDimensionContext()
}

type LengthTwoDimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthTwoDimensionContext() *LengthTwoDimensionContext {
	var p = new(LengthTwoDimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_lengthTwoDimension
	return p
}

func (*LengthTwoDimensionContext) IsLengthTwoDimensionContext() {}

func NewLengthTwoDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthTwoDimensionContext {
	var p = new(LengthTwoDimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_lengthTwoDimension

	return p
}

func (s *LengthTwoDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthTwoDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *LengthTwoDimensionContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LengthTwoDimensionContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthTwoDimensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, 0)
}

func (s *LengthTwoDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *LengthTwoDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthTwoDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthTwoDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterLengthTwoDimension(s)
	}
}

func (s *LengthTwoDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitLengthTwoDimension(s)
	}
}

func (p *StmtParser) LengthTwoDimension() (localctx ILengthTwoDimensionContext) {
	this := p
	_ = this

	localctx = NewLengthTwoDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, StmtParserRULE_lengthTwoDimension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1255)
		p.Match(StmtParserLR_BRACKET)
	}
	{
		p.SetState(1256)
		p.DecimalLiteral()
	}
	{
		p.SetState(1257)
		p.Match(StmtParserCOMMA)
	}
	{
		p.SetState(1258)
		p.DecimalLiteral()
	}
	{
		p.SetState(1259)
		p.Match(StmtParserRR_BRACKET)
	}

	return localctx
}

// ILengthTwoOptionalDimensionContext is an interface to support dynamic dispatch.
type ILengthTwoOptionalDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLengthTwoOptionalDimensionContext differentiates from other interfaces.
	IsLengthTwoOptionalDimensionContext()
}

type LengthTwoOptionalDimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthTwoOptionalDimensionContext() *LengthTwoOptionalDimensionContext {
	var p = new(LengthTwoOptionalDimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_lengthTwoOptionalDimension
	return p
}

func (*LengthTwoOptionalDimensionContext) IsLengthTwoOptionalDimensionContext() {}

func NewLengthTwoOptionalDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthTwoOptionalDimensionContext {
	var p = new(LengthTwoOptionalDimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_lengthTwoOptionalDimension

	return p
}

func (s *LengthTwoOptionalDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthTwoOptionalDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *LengthTwoOptionalDimensionContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LengthTwoOptionalDimensionContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthTwoOptionalDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *LengthTwoOptionalDimensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, 0)
}

func (s *LengthTwoOptionalDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthTwoOptionalDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthTwoOptionalDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterLengthTwoOptionalDimension(s)
	}
}

func (s *LengthTwoOptionalDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitLengthTwoOptionalDimension(s)
	}
}

func (p *StmtParser) LengthTwoOptionalDimension() (localctx ILengthTwoOptionalDimensionContext) {
	this := p
	_ = this

	localctx = NewLengthTwoOptionalDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, StmtParserRULE_lengthTwoOptionalDimension)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1261)
		p.Match(StmtParserLR_BRACKET)
	}
	{
		p.SetState(1262)
		p.DecimalLiteral()
	}
	p.SetState(1265)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == StmtParserCOMMA {
		{
			p.SetState(1263)
			p.Match(StmtParserCOMMA)
		}
		{
			p.SetState(1264)
			p.DecimalLiteral()
		}

	}
	{
		p.SetState(1267)
		p.Match(StmtParserRR_BRACKET)
	}

	return localctx
}

// IUidListContext is an interface to support dynamic dispatch.
type IUidListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUidListContext differentiates from other interfaces.
	IsUidListContext()
}

type UidListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUidListContext() *UidListContext {
	var p = new(UidListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_uidList
	return p
}

func (*UidListContext) IsUidListContext() {}

func NewUidListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UidListContext {
	var p = new(UidListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_uidList

	return p
}

func (s *UidListContext) GetParser() antlr.Parser { return s.parser }

func (s *UidListContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *UidListContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UidListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *UidListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *UidListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UidListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UidListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterUidList(s)
	}
}

func (s *UidListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitUidList(s)
	}
}

func (p *StmtParser) UidList() (localctx IUidListContext) {
	this := p
	_ = this

	localctx = NewUidListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, StmtParserRULE_uidList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1269)
		p.Uid()
	}
	p.SetState(1274)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == StmtParserCOMMA {
		{
			p.SetState(1270)
			p.Match(StmtParserCOMMA)
		}
		{
			p.SetState(1271)
			p.Uid()
		}

		p.SetState(1276)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITablesContext is an interface to support dynamic dispatch.
type ITablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTablesContext differentiates from other interfaces.
	IsTablesContext()
}

type TablesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablesContext() *TablesContext {
	var p = new(TablesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_tables
	return p
}

func (*TablesContext) IsTablesContext() {}

func NewTablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablesContext {
	var p = new(TablesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_tables

	return p
}

func (s *TablesContext) GetParser() antlr.Parser { return s.parser }

func (s *TablesContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *TablesContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *TablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *TablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTables(s)
	}
}

func (s *TablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTables(s)
	}
}

func (p *StmtParser) Tables() (localctx ITablesContext) {
	this := p
	_ = this

	localctx = NewTablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, StmtParserRULE_tables)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1277)
		p.TableName()
	}
	p.SetState(1282)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == StmtParserCOMMA {
		{
			p.SetState(1278)
			p.Match(StmtParserCOMMA)
		}
		{
			p.SetState(1279)
			p.TableName()
		}

		p.SetState(1284)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IIndexColumnNamesContext is an interface to support dynamic dispatch.
type IIndexColumnNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexColumnNamesContext differentiates from other interfaces.
	IsIndexColumnNamesContext()
}

type IndexColumnNamesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexColumnNamesContext() *IndexColumnNamesContext {
	var p = new(IndexColumnNamesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_indexColumnNames
	return p
}

func (*IndexColumnNamesContext) IsIndexColumnNamesContext() {}

func NewIndexColumnNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnNamesContext {
	var p = new(IndexColumnNamesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_indexColumnNames

	return p
}

func (s *IndexColumnNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnNamesContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *IndexColumnNamesContext) AllIndexColumnName() []IIndexColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IIndexColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexColumnNameContext); ok {
			tst[i] = t.(IIndexColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *IndexColumnNamesContext) IndexColumnName(i int) IIndexColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNameContext)
}

func (s *IndexColumnNamesContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *IndexColumnNamesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *IndexColumnNamesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *IndexColumnNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexColumnNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIndexColumnNames(s)
	}
}

func (s *IndexColumnNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIndexColumnNames(s)
	}
}

func (p *StmtParser) IndexColumnNames() (localctx IIndexColumnNamesContext) {
	this := p
	_ = this

	localctx = NewIndexColumnNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, StmtParserRULE_indexColumnNames)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1285)
		p.Match(StmtParserLR_BRACKET)
	}
	{
		p.SetState(1286)
		p.IndexColumnName()
	}
	p.SetState(1291)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == StmtParserCOMMA {
		{
			p.SetState(1287)
			p.Match(StmtParserCOMMA)
		}
		{
			p.SetState(1288)
			p.IndexColumnName()
		}

		p.SetState(1293)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1294)
		p.Match(StmtParserRR_BRACKET)
	}

	return localctx
}

// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_defaultValue
	return p
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNULL_LITERAL, 0)
}

func (s *DefaultValueContext) CAST() antlr.TerminalNode {
	return s.GetToken(StmtParserCAST, 0)
}

func (s *DefaultValueContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *DefaultValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefaultValueContext) AS() antlr.TerminalNode {
	return s.GetToken(StmtParserAS, 0)
}

func (s *DefaultValueContext) ConvertedDataType() IConvertedDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConvertedDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConvertedDataTypeContext)
}

func (s *DefaultValueContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *DefaultValueContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *DefaultValueContext) UnaryOperator() IUnaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryOperatorContext)
}

func (s *DefaultValueContext) AllCurrentTimestamp() []ICurrentTimestampContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICurrentTimestampContext); ok {
			len++
		}
	}

	tst := make([]ICurrentTimestampContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICurrentTimestampContext); ok {
			tst[i] = t.(ICurrentTimestampContext)
			i++
		}
	}

	return tst
}

func (s *DefaultValueContext) CurrentTimestamp(i int) ICurrentTimestampContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentTimestampContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentTimestampContext)
}

func (s *DefaultValueContext) ON() antlr.TerminalNode {
	return s.GetToken(StmtParserON, 0)
}

func (s *DefaultValueContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(StmtParserUPDATE, 0)
}

func (s *DefaultValueContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DefaultValueContext) LASTVAL() antlr.TerminalNode {
	return s.GetToken(StmtParserLASTVAL, 0)
}

func (s *DefaultValueContext) NEXTVAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNEXTVAL, 0)
}

func (s *DefaultValueContext) VALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserVALUE, 0)
}

func (s *DefaultValueContext) FOR() antlr.TerminalNode {
	return s.GetToken(StmtParserFOR, 0)
}

func (s *DefaultValueContext) PREVIOUS() antlr.TerminalNode {
	return s.GetToken(StmtParserPREVIOUS, 0)
}

func (s *DefaultValueContext) NEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserNEXT, 0)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (p *StmtParser) DefaultValue() (localctx IDefaultValueContext) {
	this := p
	_ = this

	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, StmtParserRULE_defaultValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1331)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 209, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1296)
			p.Match(StmtParserNULL_LITERAL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1297)
			p.Match(StmtParserCAST)
		}
		{
			p.SetState(1298)
			p.Match(StmtParserLR_BRACKET)
		}
		{
			p.SetState(1299)
			p.expression(0)
		}
		{
			p.SetState(1300)
			p.Match(StmtParserAS)
		}
		{
			p.SetState(1301)
			p.ConvertedDataType()
		}
		{
			p.SetState(1302)
			p.Match(StmtParserRR_BRACKET)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1305)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 207, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1304)
				p.UnaryOperator()
			}

		}
		{
			p.SetState(1307)
			p.Constant()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1308)
			p.CurrentTimestamp()
		}
		p.SetState(1312)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1309)
				p.Match(StmtParserON)
			}
			{
				p.SetState(1310)
				p.Match(StmtParserUPDATE)
			}
			{
				p.SetState(1311)
				p.CurrentTimestamp()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1314)
			p.Match(StmtParserLR_BRACKET)
		}
		{
			p.SetState(1315)
			p.expression(0)
		}
		{
			p.SetState(1316)
			p.Match(StmtParserRR_BRACKET)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1318)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserLASTVAL || _la == StmtParserNEXTVAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1319)
			p.Match(StmtParserLR_BRACKET)
		}
		{
			p.SetState(1320)
			p.FullId()
		}
		{
			p.SetState(1321)
			p.Match(StmtParserRR_BRACKET)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1323)
			p.Match(StmtParserLR_BRACKET)
		}
		{
			p.SetState(1324)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserNEXT || _la == StmtParserPREVIOUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1325)
			p.Match(StmtParserVALUE)
		}
		{
			p.SetState(1326)
			p.Match(StmtParserFOR)
		}
		{
			p.SetState(1327)
			p.FullId()
		}
		{
			p.SetState(1328)
			p.Match(StmtParserRR_BRACKET)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1330)
			p.expression(0)
		}

	}

	return localctx
}

// ICurrentTimestampContext is an interface to support dynamic dispatch.
type ICurrentTimestampContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCurrentTimestampContext differentiates from other interfaces.
	IsCurrentTimestampContext()
}

type CurrentTimestampContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCurrentTimestampContext() *CurrentTimestampContext {
	var p = new(CurrentTimestampContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_currentTimestamp
	return p
}

func (*CurrentTimestampContext) IsCurrentTimestampContext() {}

func NewCurrentTimestampContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CurrentTimestampContext {
	var p = new(CurrentTimestampContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_currentTimestamp

	return p
}

func (s *CurrentTimestampContext) GetParser() antlr.Parser { return s.parser }

func (s *CurrentTimestampContext) NOW() antlr.TerminalNode {
	return s.GetToken(StmtParserNOW, 0)
}

func (s *CurrentTimestampContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *CurrentTimestampContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *CurrentTimestampContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserCURRENT_TIMESTAMP, 0)
}

func (s *CurrentTimestampContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(StmtParserLOCALTIME, 0)
}

func (s *CurrentTimestampContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserLOCALTIMESTAMP, 0)
}

func (s *CurrentTimestampContext) CURDATE() antlr.TerminalNode {
	return s.GetToken(StmtParserCURDATE, 0)
}

func (s *CurrentTimestampContext) CURTIME() antlr.TerminalNode {
	return s.GetToken(StmtParserCURTIME, 0)
}

func (s *CurrentTimestampContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *CurrentTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentTimestampContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CurrentTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCurrentTimestamp(s)
	}
}

func (s *CurrentTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCurrentTimestamp(s)
	}
}

func (p *StmtParser) CurrentTimestamp() (localctx ICurrentTimestampContext) {
	this := p
	_ = this

	localctx = NewCurrentTimestampContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, StmtParserRULE_currentTimestamp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1347)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case StmtParserCURRENT_TIMESTAMP, StmtParserLOCALTIME, StmtParserCURDATE, StmtParserCURTIME, StmtParserLOCALTIMESTAMP:
		{
			p.SetState(1333)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-306)) & ^0x3f) == 0 && ((int64(1)<<(_la-306))&143) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1339)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserLR_BRACKET {
			{
				p.SetState(1334)
				p.Match(StmtParserLR_BRACKET)
			}
			p.SetState(1336)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-1128)) & ^0x3f) == 0 && ((int64(1)<<(_la-1128))&10247) != 0 {
				{
					p.SetState(1335)
					p.DecimalLiteral()
				}

			}
			{
				p.SetState(1338)
				p.Match(StmtParserRR_BRACKET)
			}

		}

	case StmtParserNOW:
		{
			p.SetState(1341)
			p.Match(StmtParserNOW)
		}
		{
			p.SetState(1342)
			p.Match(StmtParserLR_BRACKET)
		}
		p.SetState(1344)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-1128)) & ^0x3f) == 0 && ((int64(1)<<(_la-1128))&10247) != 0 {
			{
				p.SetState(1343)
				p.DecimalLiteral()
			}

		}
		{
			p.SetState(1346)
			p.Match(StmtParserRR_BRACKET)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIfNotExistsContext is an interface to support dynamic dispatch.
type IIfNotExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfNotExistsContext differentiates from other interfaces.
	IsIfNotExistsContext()
}

type IfNotExistsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNotExistsContext() *IfNotExistsContext {
	var p = new(IfNotExistsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_ifNotExists
	return p
}

func (*IfNotExistsContext) IsIfNotExistsContext() {}

func NewIfNotExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNotExistsContext {
	var p = new(IfNotExistsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_ifNotExists

	return p
}

func (s *IfNotExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNotExistsContext) IF() antlr.TerminalNode {
	return s.GetToken(StmtParserIF, 0)
}

func (s *IfNotExistsContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *IfNotExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StmtParserEXISTS, 0)
}

func (s *IfNotExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNotExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfNotExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIfNotExists(s)
	}
}

func (s *IfNotExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIfNotExists(s)
	}
}

func (p *StmtParser) IfNotExists() (localctx IIfNotExistsContext) {
	this := p
	_ = this

	localctx = NewIfNotExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, StmtParserRULE_ifNotExists)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1349)
		p.Match(StmtParserIF)
	}
	{
		p.SetState(1350)
		p.Match(StmtParserNOT)
	}
	{
		p.SetState(1351)
		p.Match(StmtParserEXISTS)
	}

	return localctx
}

// IScalarFunctionNameContext is an interface to support dynamic dispatch.
type IScalarFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScalarFunctionNameContext differentiates from other interfaces.
	IsScalarFunctionNameContext()
}

type ScalarFunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalarFunctionNameContext() *ScalarFunctionNameContext {
	var p = new(ScalarFunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_scalarFunctionName
	return p
}

func (*ScalarFunctionNameContext) IsScalarFunctionNameContext() {}

func NewScalarFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalarFunctionNameContext {
	var p = new(ScalarFunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_scalarFunctionName

	return p
}

func (s *ScalarFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalarFunctionNameContext) FunctionNameBase() IFunctionNameBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameBaseContext)
}

func (s *ScalarFunctionNameContext) ASCII() antlr.TerminalNode {
	return s.GetToken(StmtParserASCII, 0)
}

func (s *ScalarFunctionNameContext) CURDATE() antlr.TerminalNode {
	return s.GetToken(StmtParserCURDATE, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(StmtParserCURRENT_DATE, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(StmtParserCURRENT_TIME, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserCURRENT_TIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) CURTIME() antlr.TerminalNode {
	return s.GetToken(StmtParserCURTIME, 0)
}

func (s *ScalarFunctionNameContext) DATE_ADD() antlr.TerminalNode {
	return s.GetToken(StmtParserDATE_ADD, 0)
}

func (s *ScalarFunctionNameContext) DATE_SUB() antlr.TerminalNode {
	return s.GetToken(StmtParserDATE_SUB, 0)
}

func (s *ScalarFunctionNameContext) IF() antlr.TerminalNode {
	return s.GetToken(StmtParserIF, 0)
}

func (s *ScalarFunctionNameContext) INSERT() antlr.TerminalNode {
	return s.GetToken(StmtParserINSERT, 0)
}

func (s *ScalarFunctionNameContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(StmtParserLOCALTIME, 0)
}

func (s *ScalarFunctionNameContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserLOCALTIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) MID() antlr.TerminalNode {
	return s.GetToken(StmtParserMID, 0)
}

func (s *ScalarFunctionNameContext) NOW() antlr.TerminalNode {
	return s.GetToken(StmtParserNOW, 0)
}

func (s *ScalarFunctionNameContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLACE, 0)
}

func (s *ScalarFunctionNameContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBSTR, 0)
}

func (s *ScalarFunctionNameContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBSTRING, 0)
}

func (s *ScalarFunctionNameContext) SYSDATE() antlr.TerminalNode {
	return s.GetToken(StmtParserSYSDATE, 0)
}

func (s *ScalarFunctionNameContext) TRIM() antlr.TerminalNode {
	return s.GetToken(StmtParserTRIM, 0)
}

func (s *ScalarFunctionNameContext) UTC_DATE() antlr.TerminalNode {
	return s.GetToken(StmtParserUTC_DATE, 0)
}

func (s *ScalarFunctionNameContext) UTC_TIME() antlr.TerminalNode {
	return s.GetToken(StmtParserUTC_TIME, 0)
}

func (s *ScalarFunctionNameContext) UTC_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserUTC_TIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalarFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterScalarFunctionName(s)
	}
}

func (s *ScalarFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitScalarFunctionName(s)
	}
}

func (p *StmtParser) ScalarFunctionName() (localctx IScalarFunctionNameContext) {
	this := p
	_ = this

	localctx = NewScalarFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, StmtParserRULE_scalarFunctionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1376)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case StmtParserDATABASE, StmtParserLEFT, StmtParserRIGHT, StmtParserSCHEMA, StmtParserDATE, StmtParserTIME, StmtParserTIMESTAMP, StmtParserYEAR, StmtParserJSON_ARRAY, StmtParserJSON_OBJECT, StmtParserJSON_QUOTE, StmtParserJSON_CONTAINS, StmtParserJSON_CONTAINS_PATH, StmtParserJSON_EXTRACT, StmtParserJSON_KEYS, StmtParserJSON_OVERLAPS, StmtParserJSON_SEARCH, StmtParserJSON_VALUE, StmtParserJSON_ARRAY_APPEND, StmtParserJSON_ARRAY_INSERT, StmtParserJSON_INSERT, StmtParserJSON_MERGE, StmtParserJSON_MERGE_PATCH, StmtParserJSON_MERGE_PRESERVE, StmtParserJSON_REMOVE, StmtParserJSON_REPLACE, StmtParserJSON_SET, StmtParserJSON_UNQUOTE, StmtParserJSON_DEPTH, StmtParserJSON_LENGTH, StmtParserJSON_TYPE, StmtParserJSON_VALID, StmtParserJSON_TABLE, StmtParserJSON_SCHEMA_VALID, StmtParserJSON_SCHEMA_VALIDATION_REPORT, StmtParserJSON_PRETTY, StmtParserJSON_STORAGE_FREE, StmtParserJSON_STORAGE_SIZE, StmtParserJSON_ARRAYAGG, StmtParserJSON_OBJECTAGG, StmtParserCOUNT, StmtParserCUME_DIST, StmtParserDENSE_RANK, StmtParserFIRST_VALUE, StmtParserLAG, StmtParserLAST_VALUE, StmtParserLEAD, StmtParserNTILE, StmtParserNTH_VALUE, StmtParserPERCENT_RANK, StmtParserRANK, StmtParserROW_NUMBER, StmtParserPOSITION, StmtParserINVISIBLE, StmtParserVISIBLE, StmtParserQUARTER, StmtParserMONTH, StmtParserDAY, StmtParserHOUR, StmtParserMINUTE, StmtParserWEEK, StmtParserSECOND, StmtParserMICROSECOND, StmtParserSESSION_VARIABLES_ADMIN, StmtParserGEOMETRYCOLLECTION, StmtParserLINESTRING, StmtParserMULTILINESTRING, StmtParserMULTIPOINT, StmtParserMULTIPOLYGON, StmtParserPOINT, StmtParserPOLYGON, StmtParserABS, StmtParserACOS, StmtParserADDDATE, StmtParserADDTIME, StmtParserAES_DECRYPT, StmtParserAES_ENCRYPT, StmtParserAREA, StmtParserASBINARY, StmtParserASIN, StmtParserASTEXT, StmtParserASWKB, StmtParserASWKT, StmtParserASYMMETRIC_DECRYPT, StmtParserASYMMETRIC_DERIVE, StmtParserASYMMETRIC_ENCRYPT, StmtParserASYMMETRIC_SIGN, StmtParserASYMMETRIC_VERIFY, StmtParserATAN, StmtParserATAN2, StmtParserBENCHMARK, StmtParserBIN, StmtParserBIT_COUNT, StmtParserBIT_LENGTH, StmtParserBUFFER, StmtParserCEIL, StmtParserCEILING, StmtParserCENTROID, StmtParserCHARACTER_LENGTH, StmtParserCHARSET, StmtParserCHAR_LENGTH, StmtParserCOERCIBILITY, StmtParserCOLLATION, StmtParserCOMPRESS, StmtParserCONCAT, StmtParserCONCAT_WS, StmtParserCONNECTION_ID, StmtParserCONV, StmtParserCONVERT_TZ, StmtParserCOS, StmtParserCOT, StmtParserCRC32, StmtParserCREATE_ASYMMETRIC_PRIV_KEY, StmtParserCREATE_ASYMMETRIC_PUB_KEY, StmtParserCREATE_DH_PARAMETERS, StmtParserCREATE_DIGEST, StmtParserCROSSES, StmtParserDATEDIFF, StmtParserDATE_FORMAT, StmtParserDAYNAME, StmtParserDAYOFMONTH, StmtParserDAYOFWEEK, StmtParserDAYOFYEAR, StmtParserDECODE, StmtParserDEGREES, StmtParserDES_DECRYPT, StmtParserDES_ENCRYPT, StmtParserDIMENSION, StmtParserDISJOINT, StmtParserELT, StmtParserENCODE, StmtParserENCRYPT, StmtParserENDPOINT, StmtParserENVELOPE, StmtParserEQUALS, StmtParserEXP, StmtParserEXPORT_SET, StmtParserEXTERIORRING, StmtParserEXTRACTVALUE, StmtParserFIELD, StmtParserFIND_IN_SET, StmtParserFLOOR, StmtParserFORMAT, StmtParserFOUND_ROWS, StmtParserFROM_BASE64, StmtParserFROM_DAYS, StmtParserFROM_UNIXTIME, StmtParserGEOMCOLLFROMTEXT, StmtParserGEOMCOLLFROMWKB, StmtParserGEOMETRYCOLLECTIONFROMTEXT, StmtParserGEOMETRYCOLLECTIONFROMWKB, StmtParserGEOMETRYFROMTEXT, StmtParserGEOMETRYFROMWKB, StmtParserGEOMETRYN, StmtParserGEOMETRYTYPE, StmtParserGEOMFROMTEXT, StmtParserGEOMFROMWKB, StmtParserGET_FORMAT, StmtParserGET_LOCK, StmtParserGLENGTH, StmtParserGREATEST, StmtParserGTID_SUBSET, StmtParserGTID_SUBTRACT, StmtParserHEX, StmtParserIFNULL, StmtParserINET6_ATON, StmtParserINET6_NTOA, StmtParserINET_ATON, StmtParserINET_NTOA, StmtParserINSTR, StmtParserINTERIORRINGN, StmtParserINTERSECTS, StmtParserISCLOSED, StmtParserISEMPTY, StmtParserISNULL, StmtParserISSIMPLE, StmtParserIS_FREE_LOCK, StmtParserIS_IPV4, StmtParserIS_IPV4_COMPAT, StmtParserIS_IPV4_MAPPED, StmtParserIS_IPV6, StmtParserIS_USED_LOCK, StmtParserLAST_INSERT_ID, StmtParserLCASE, StmtParserLEAST, StmtParserLENGTH, StmtParserLINEFROMTEXT, StmtParserLINEFROMWKB, StmtParserLINESTRINGFROMTEXT, StmtParserLINESTRINGFROMWKB, StmtParserLN, StmtParserLOAD_FILE, StmtParserLOCATE, StmtParserLOG, StmtParserLOG10, StmtParserLOG2, StmtParserLOWER, StmtParserLPAD, StmtParserLTRIM, StmtParserMAKEDATE, StmtParserMAKETIME, StmtParserMAKE_SET, StmtParserMASTER_POS_WAIT, StmtParserMBRCONTAINS, StmtParserMBRDISJOINT, StmtParserMBREQUAL, StmtParserMBRINTERSECTS, StmtParserMBROVERLAPS, StmtParserMBRTOUCHES, StmtParserMBRWITHIN, StmtParserMD5, StmtParserMLINEFROMTEXT, StmtParserMLINEFROMWKB, StmtParserMONTHNAME, StmtParserMPOINTFROMTEXT, StmtParserMPOINTFROMWKB, StmtParserMPOLYFROMTEXT, StmtParserMPOLYFROMWKB, StmtParserMULTILINESTRINGFROMTEXT, StmtParserMULTILINESTRINGFROMWKB, StmtParserMULTIPOINTFROMTEXT, StmtParserMULTIPOINTFROMWKB, StmtParserMULTIPOLYGONFROMTEXT, StmtParserMULTIPOLYGONFROMWKB, StmtParserNAME_CONST, StmtParserNULLIF, StmtParserNUMGEOMETRIES, StmtParserNUMINTERIORRINGS, StmtParserNUMPOINTS, StmtParserOCT, StmtParserOCTET_LENGTH, StmtParserORD, StmtParserOVERLAPS, StmtParserPERIOD_ADD, StmtParserPERIOD_DIFF, StmtParserPI, StmtParserPOINTFROMTEXT, StmtParserPOINTFROMWKB, StmtParserPOINTN, StmtParserPOLYFROMTEXT, StmtParserPOLYFROMWKB, StmtParserPOLYGONFROMTEXT, StmtParserPOLYGONFROMWKB, StmtParserPOW, StmtParserPOWER, StmtParserQUOTE, StmtParserRADIANS, StmtParserRAND, StmtParserRANDOM_BYTES, StmtParserRELEASE_LOCK, StmtParserREVERSE, StmtParserROUND, StmtParserROW_COUNT, StmtParserRPAD, StmtParserRTRIM, StmtParserSEC_TO_TIME, StmtParserSESSION_USER, StmtParserSHA, StmtParserSHA1, StmtParserSHA2, StmtParserSIGN, StmtParserSIN, StmtParserSLEEP, StmtParserSOUNDEX, StmtParserSQL_THREAD_WAIT_AFTER_GTIDS, StmtParserSQRT, StmtParserSRID, StmtParserSTARTPOINT, StmtParserSTRCMP, StmtParserSTR_TO_DATE, StmtParserST_AREA, StmtParserST_ASBINARY, StmtParserST_ASTEXT, StmtParserST_ASWKB, StmtParserST_ASWKT, StmtParserST_BUFFER, StmtParserST_CENTROID, StmtParserST_CONTAINS, StmtParserST_CROSSES, StmtParserST_DIFFERENCE, StmtParserST_DIMENSION, StmtParserST_DISJOINT, StmtParserST_DISTANCE, StmtParserST_ENDPOINT, StmtParserST_ENVELOPE, StmtParserST_EQUALS, StmtParserST_EXTERIORRING, StmtParserST_GEOMCOLLFROMTEXT, StmtParserST_GEOMCOLLFROMTXT, StmtParserST_GEOMCOLLFROMWKB, StmtParserST_GEOMETRYCOLLECTIONFROMTEXT, StmtParserST_GEOMETRYCOLLECTIONFROMWKB, StmtParserST_GEOMETRYFROMTEXT, StmtParserST_GEOMETRYFROMWKB, StmtParserST_GEOMETRYN, StmtParserST_GEOMETRYTYPE, StmtParserST_GEOMFROMTEXT, StmtParserST_GEOMFROMWKB, StmtParserST_INTERIORRINGN, StmtParserST_INTERSECTION, StmtParserST_INTERSECTS, StmtParserST_ISCLOSED, StmtParserST_ISEMPTY, StmtParserST_ISSIMPLE, StmtParserST_LINEFROMTEXT, StmtParserST_LINEFROMWKB, StmtParserST_LINESTRINGFROMTEXT, StmtParserST_LINESTRINGFROMWKB, StmtParserST_NUMGEOMETRIES, StmtParserST_NUMINTERIORRING, StmtParserST_NUMINTERIORRINGS, StmtParserST_NUMPOINTS, StmtParserST_OVERLAPS, StmtParserST_POINTFROMTEXT, StmtParserST_POINTFROMWKB, StmtParserST_POINTN, StmtParserST_POLYFROMTEXT, StmtParserST_POLYFROMWKB, StmtParserST_POLYGONFROMTEXT, StmtParserST_POLYGONFROMWKB, StmtParserST_SRID, StmtParserST_STARTPOINT, StmtParserST_SYMDIFFERENCE, StmtParserST_TOUCHES, StmtParserST_UNION, StmtParserST_WITHIN, StmtParserST_X, StmtParserST_Y, StmtParserSUBDATE, StmtParserSUBSTRING_INDEX, StmtParserSUBTIME, StmtParserSYSTEM_USER, StmtParserTAN, StmtParserTIMEDIFF, StmtParserTIMESTAMPADD, StmtParserTIMESTAMPDIFF, StmtParserTIME_FORMAT, StmtParserTIME_TO_SEC, StmtParserTOUCHES, StmtParserTO_BASE64, StmtParserTO_DAYS, StmtParserTO_SECONDS, StmtParserUCASE, StmtParserUNCOMPRESS, StmtParserUNCOMPRESSED_LENGTH, StmtParserUNHEX, StmtParserUNIX_TIMESTAMP, StmtParserUPDATEXML, StmtParserUPPER, StmtParserUUID, StmtParserUUID_SHORT, StmtParserVALIDATE_PASSWORD_STRENGTH, StmtParserVERSION, StmtParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, StmtParserWEEKDAY, StmtParserWEEKOFYEAR, StmtParserWEIGHT_STRING, StmtParserWITHIN, StmtParserYEARWEEK, StmtParserY_FUNCTION, StmtParserX_FUNCTION, StmtParserLASTVAL, StmtParserNEXTVAL, StmtParserSETVAL, StmtParserMOD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1353)
			p.FunctionNameBase()
		}

	case StmtParserASCII:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1354)
			p.Match(StmtParserASCII)
		}

	case StmtParserCURDATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1355)
			p.Match(StmtParserCURDATE)
		}

	case StmtParserCURRENT_DATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1356)
			p.Match(StmtParserCURRENT_DATE)
		}

	case StmtParserCURRENT_TIME:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1357)
			p.Match(StmtParserCURRENT_TIME)
		}

	case StmtParserCURRENT_TIMESTAMP:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1358)
			p.Match(StmtParserCURRENT_TIMESTAMP)
		}

	case StmtParserCURTIME:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1359)
			p.Match(StmtParserCURTIME)
		}

	case StmtParserDATE_ADD:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1360)
			p.Match(StmtParserDATE_ADD)
		}

	case StmtParserDATE_SUB:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1361)
			p.Match(StmtParserDATE_SUB)
		}

	case StmtParserIF:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1362)
			p.Match(StmtParserIF)
		}

	case StmtParserINSERT:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1363)
			p.Match(StmtParserINSERT)
		}

	case StmtParserLOCALTIME:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1364)
			p.Match(StmtParserLOCALTIME)
		}

	case StmtParserLOCALTIMESTAMP:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1365)
			p.Match(StmtParserLOCALTIMESTAMP)
		}

	case StmtParserMID:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1366)
			p.Match(StmtParserMID)
		}

	case StmtParserNOW:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1367)
			p.Match(StmtParserNOW)
		}

	case StmtParserREPLACE:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1368)
			p.Match(StmtParserREPLACE)
		}

	case StmtParserSUBSTR:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1369)
			p.Match(StmtParserSUBSTR)
		}

	case StmtParserSUBSTRING:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1370)
			p.Match(StmtParserSUBSTRING)
		}

	case StmtParserSYSDATE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1371)
			p.Match(StmtParserSYSDATE)
		}

	case StmtParserTRIM:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1372)
			p.Match(StmtParserTRIM)
		}

	case StmtParserUTC_DATE:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1373)
			p.Match(StmtParserUTC_DATE)
		}

	case StmtParserUTC_TIME:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1374)
			p.Match(StmtParserUTC_TIME)
		}

	case StmtParserUTC_TIMESTAMP:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1375)
			p.Match(StmtParserUTC_TIMESTAMP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyFrom(ctx *ExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IsExpressionContext struct {
	*ExpressionContext
	testValue antlr.Token
}

func NewIsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsExpressionContext {
	var p = new(IsExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *IsExpressionContext) GetTestValue() antlr.Token { return s.testValue }

func (s *IsExpressionContext) SetTestValue(v antlr.Token) { s.testValue = v }

func (s *IsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsExpressionContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *IsExpressionContext) IS() antlr.TerminalNode {
	return s.GetToken(StmtParserIS, 0)
}

func (s *IsExpressionContext) TRUE() antlr.TerminalNode {
	return s.GetToken(StmtParserTRUE, 0)
}

func (s *IsExpressionContext) FALSE() antlr.TerminalNode {
	return s.GetToken(StmtParserFALSE, 0)
}

func (s *IsExpressionContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(StmtParserUNKNOWN, 0)
}

func (s *IsExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *IsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIsExpression(s)
	}
}

func (s *IsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIsExpression(s)
	}
}

type NotExpressionContext struct {
	*ExpressionContext
	notOperator antlr.Token
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext {
	var p = new(NotExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *NotExpressionContext) GetNotOperator() antlr.Token { return s.notOperator }

func (s *NotExpressionContext) SetNotOperator(v antlr.Token) { s.notOperator = v }

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NotExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *NotExpressionContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEXCLAMATION_SYMBOL, 0)
}

func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

type LogicalExpressionContext struct {
	*ExpressionContext
}

func NewLogicalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalExpressionContext) LogicalOperator() ILogicalOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOperatorContext)
}

func (s *LogicalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterLogicalExpression(s)
	}
}

func (s *LogicalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitLogicalExpression(s)
	}
}

type PredicateExpressionContext struct {
	*ExpressionContext
}

func NewPredicateExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExpressionContext {
	var p = new(PredicateExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PredicateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateExpressionContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicateExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPredicateExpression(s)
	}
}

func (s *PredicateExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPredicateExpression(s)
	}
}

func (p *StmtParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *StmtParser) expression(_p int) (localctx IExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 114
	p.EnterRecursionRule(localctx, 114, StmtParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1389)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 216, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1379)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NotExpressionContext).notOperator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserNOT || _la == StmtParserEXCLAMATION_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NotExpressionContext).notOperator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1380)
			p.expression(4)
		}

	case 2:
		localctx = NewIsExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1381)
			p.predicate(0)
		}
		{
			p.SetState(1382)
			p.Match(StmtParserIS)
		}
		p.SetState(1384)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == StmtParserNOT {
			{
				p.SetState(1383)
				p.Match(StmtParserNOT)
			}

		}
		{
			p.SetState(1386)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IsExpressionContext).testValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StmtParserFALSE || _la == StmtParserTRUE || _la == StmtParserUNKNOWN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IsExpressionContext).testValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		localctx = NewPredicateExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1388)
			p.predicate(0)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1397)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 217, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_expression)
			p.SetState(1391)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
			}
			{
				p.SetState(1392)
				p.LogicalOperator()
			}
			{
				p.SetState(1393)
				p.expression(4)
			}

		}
		p.SetState(1399)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 217, p.GetParserRuleContext())
	}

	return localctx
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_predicate
	return p
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) CopyFrom(ctx *PredicateContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SoundsLikePredicateContext struct {
	*PredicateContext
}

func NewSoundsLikePredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SoundsLikePredicateContext {
	var p = new(SoundsLikePredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *SoundsLikePredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoundsLikePredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *SoundsLikePredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *SoundsLikePredicateContext) SOUNDS() antlr.TerminalNode {
	return s.GetToken(StmtParserSOUNDS, 0)
}

func (s *SoundsLikePredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StmtParserLIKE, 0)
}

func (s *SoundsLikePredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterSoundsLikePredicate(s)
	}
}

func (s *SoundsLikePredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitSoundsLikePredicate(s)
	}
}

type ExpressionAtomPredicateContext struct {
	*PredicateContext
}

func NewExpressionAtomPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpressionAtomPredicateContext {
	var p = new(ExpressionAtomPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *ExpressionAtomPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionAtomPredicateContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *ExpressionAtomPredicateContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserLOCAL_ID, 0)
}

func (s *ExpressionAtomPredicateContext) VAR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(StmtParserVAR_ASSIGN, 0)
}

func (s *ExpressionAtomPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterExpressionAtomPredicate(s)
	}
}

func (s *ExpressionAtomPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitExpressionAtomPredicate(s)
	}
}

type JsonMemberOfPredicateContext struct {
	*PredicateContext
}

func NewJsonMemberOfPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonMemberOfPredicateContext {
	var p = new(JsonMemberOfPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *JsonMemberOfPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonMemberOfPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *JsonMemberOfPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *JsonMemberOfPredicateContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(StmtParserMEMBER, 0)
}

func (s *JsonMemberOfPredicateContext) OF() antlr.TerminalNode {
	return s.GetToken(StmtParserOF, 0)
}

func (s *JsonMemberOfPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *JsonMemberOfPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *JsonMemberOfPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterJsonMemberOfPredicate(s)
	}
}

func (s *JsonMemberOfPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitJsonMemberOfPredicate(s)
	}
}

type BinaryComparisonPredicateContext struct {
	*PredicateContext
	left  IPredicateContext
	right IPredicateContext
}

func NewBinaryComparisonPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryComparisonPredicateContext {
	var p = new(BinaryComparisonPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *BinaryComparisonPredicateContext) GetLeft() IPredicateContext { return s.left }

func (s *BinaryComparisonPredicateContext) GetRight() IPredicateContext { return s.right }

func (s *BinaryComparisonPredicateContext) SetLeft(v IPredicateContext) { s.left = v }

func (s *BinaryComparisonPredicateContext) SetRight(v IPredicateContext) { s.right = v }

func (s *BinaryComparisonPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryComparisonPredicateContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *BinaryComparisonPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *BinaryComparisonPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BinaryComparisonPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterBinaryComparisonPredicate(s)
	}
}

func (s *BinaryComparisonPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitBinaryComparisonPredicate(s)
	}
}

type BetweenPredicateContext struct {
	*PredicateContext
}

func NewBetweenPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenPredicateContext {
	var p = new(BetweenPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *BetweenPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *BetweenPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BetweenPredicateContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(StmtParserBETWEEN, 0)
}

func (s *BetweenPredicateContext) AND() antlr.TerminalNode {
	return s.GetToken(StmtParserAND, 0)
}

func (s *BetweenPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *BetweenPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterBetweenPredicate(s)
	}
}

func (s *BetweenPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitBetweenPredicate(s)
	}
}

type IsNullPredicateContext struct {
	*PredicateContext
}

func NewIsNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsNullPredicateContext {
	var p = new(IsNullPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *IsNullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsNullPredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *IsNullPredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(StmtParserIS, 0)
}

func (s *IsNullPredicateContext) NullNotnull() INullNotnullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullNotnullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullNotnullContext)
}

func (s *IsNullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIsNullPredicate(s)
	}
}

func (s *IsNullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIsNullPredicate(s)
	}
}

type LikePredicateContext struct {
	*PredicateContext
}

func NewLikePredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikePredicateContext {
	var p = new(LikePredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *LikePredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikePredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *LikePredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *LikePredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StmtParserLIKE, 0)
}

func (s *LikePredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *LikePredicateContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(StmtParserESCAPE, 0)
}

func (s *LikePredicateContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING_LITERAL, 0)
}

func (s *LikePredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterLikePredicate(s)
	}
}

func (s *LikePredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitLikePredicate(s)
	}
}

type RegexpPredicateContext struct {
	*PredicateContext
	regex antlr.Token
}

func NewRegexpPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegexpPredicateContext {
	var p = new(RegexpPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *RegexpPredicateContext) GetRegex() antlr.Token { return s.regex }

func (s *RegexpPredicateContext) SetRegex(v antlr.Token) { s.regex = v }

func (s *RegexpPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegexpPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *RegexpPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *RegexpPredicateContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(StmtParserREGEXP, 0)
}

func (s *RegexpPredicateContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(StmtParserRLIKE, 0)
}

func (s *RegexpPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *RegexpPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterRegexpPredicate(s)
	}
}

func (s *RegexpPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitRegexpPredicate(s)
	}
}

func (p *StmtParser) Predicate() (localctx IPredicateContext) {
	return p.predicate(0)
}

func (p *StmtParser) predicate(_p int) (localctx IPredicateContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPredicateContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 116
	p.EnterRecursionRule(localctx, 116, StmtParserRULE_predicate, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewExpressionAtomPredicateContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	p.SetState(1403)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 218, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1401)
			p.Match(StmtParserLOCAL_ID)
		}
		{
			p.SetState(1402)
			p.Match(StmtParserVAR_ASSIGN)
		}

	}
	{
		p.SetState(1405)
		p.expressionAtom(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1452)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 224, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1450)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 223, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBinaryComparisonPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				localctx.(*BinaryComparisonPredicateContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_predicate)
				p.SetState(1407)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(1408)
					p.ComparisonOperator()
				}
				{
					p.SetState(1409)

					var _x = p.predicate(8)

					localctx.(*BinaryComparisonPredicateContext).right = _x
				}

			case 2:
				localctx = NewBetweenPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_predicate)
				p.SetState(1411)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				p.SetState(1413)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == StmtParserNOT {
					{
						p.SetState(1412)
						p.Match(StmtParserNOT)
					}

				}
				{
					p.SetState(1415)
					p.Match(StmtParserBETWEEN)
				}
				{
					p.SetState(1416)
					p.predicate(0)
				}
				{
					p.SetState(1417)
					p.Match(StmtParserAND)
				}
				{
					p.SetState(1418)
					p.predicate(7)
				}

			case 3:
				localctx = NewSoundsLikePredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_predicate)
				p.SetState(1420)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(1421)
					p.Match(StmtParserSOUNDS)
				}
				{
					p.SetState(1422)
					p.Match(StmtParserLIKE)
				}
				{
					p.SetState(1423)
					p.predicate(6)
				}

			case 4:
				localctx = NewRegexpPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_predicate)
				p.SetState(1424)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				p.SetState(1426)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == StmtParserNOT {
					{
						p.SetState(1425)
						p.Match(StmtParserNOT)
					}

				}
				{
					p.SetState(1428)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*RegexpPredicateContext).regex = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == StmtParserREGEXP || _la == StmtParserRLIKE) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*RegexpPredicateContext).regex = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1429)
					p.predicate(4)
				}

			case 5:
				localctx = NewIsNullPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_predicate)
				p.SetState(1430)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(1431)
					p.Match(StmtParserIS)
				}
				{
					p.SetState(1432)
					p.NullNotnull()
				}

			case 6:
				localctx = NewLikePredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_predicate)
				p.SetState(1433)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				p.SetState(1435)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == StmtParserNOT {
					{
						p.SetState(1434)
						p.Match(StmtParserNOT)
					}

				}
				{
					p.SetState(1437)
					p.Match(StmtParserLIKE)
				}
				{
					p.SetState(1438)
					p.predicate(0)
				}
				p.SetState(1441)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 222, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1439)
						p.Match(StmtParserESCAPE)
					}
					{
						p.SetState(1440)
						p.Match(StmtParserSTRING_LITERAL)
					}

				}

			case 7:
				localctx = NewJsonMemberOfPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_predicate)
				p.SetState(1443)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(1444)
					p.Match(StmtParserMEMBER)
				}
				{
					p.SetState(1445)
					p.Match(StmtParserOF)
				}
				{
					p.SetState(1446)
					p.Match(StmtParserLR_BRACKET)
				}
				{
					p.SetState(1447)
					p.predicate(0)
				}
				{
					p.SetState(1448)
					p.Match(StmtParserRR_BRACKET)
				}

			}

		}
		p.SetState(1454)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 224, p.GetParserRuleContext())
	}

	return localctx
}

// IExpressionAtomContext is an interface to support dynamic dispatch.
type IExpressionAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionAtomContext differentiates from other interfaces.
	IsExpressionAtomContext()
}

type ExpressionAtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionAtomContext() *ExpressionAtomContext {
	var p = new(ExpressionAtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_expressionAtom
	return p
}

func (*ExpressionAtomContext) IsExpressionAtomContext() {}

func NewExpressionAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionAtomContext {
	var p = new(ExpressionAtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_expressionAtom

	return p
}

func (s *ExpressionAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionAtomContext) CopyFrom(ctx *ExpressionAtomContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type JsonExpressionAtomContext struct {
	*ExpressionAtomContext
	left  IExpressionAtomContext
	right IExpressionAtomContext
}

func NewJsonExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonExpressionAtomContext {
	var p = new(JsonExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *JsonExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *JsonExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }

func (s *JsonExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *JsonExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *JsonExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonExpressionAtomContext) JsonOperator() IJsonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOperatorContext)
}

func (s *JsonExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			len++
		}
	}

	tst := make([]IExpressionAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionAtomContext); ok {
			tst[i] = t.(IExpressionAtomContext)
			i++
		}
	}

	return tst
}

func (s *JsonExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *JsonExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterJsonExpressionAtom(s)
	}
}

func (s *JsonExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitJsonExpressionAtom(s)
	}
}

type UnaryExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewUnaryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryExpressionAtomContext {
	var p = new(UnaryExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *UnaryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionAtomContext) UnaryOperator() IUnaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryOperatorContext)
}

func (s *UnaryExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *UnaryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterUnaryExpressionAtom(s)
	}
}

func (s *UnaryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitUnaryExpressionAtom(s)
	}
}

type CollateExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewCollateExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateExpressionAtomContext {
	var p = new(CollateExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *CollateExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *CollateExpressionAtomContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLLATE, 0)
}

func (s *CollateExpressionAtomContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *CollateExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCollateExpressionAtom(s)
	}
}

func (s *CollateExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCollateExpressionAtom(s)
	}
}

type ConstantExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewConstantExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstantExpressionAtomContext {
	var p = new(ConstantExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *ConstantExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantExpressionAtomContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterConstantExpressionAtom(s)
	}
}

func (s *ConstantExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitConstantExpressionAtom(s)
	}
}

type MysqlVariableExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewMysqlVariableExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MysqlVariableExpressionAtomContext {
	var p = new(MysqlVariableExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *MysqlVariableExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlVariableExpressionAtomContext) MysqlVariable() IMysqlVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMysqlVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMysqlVariableContext)
}

func (s *MysqlVariableExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterMysqlVariableExpressionAtom(s)
	}
}

func (s *MysqlVariableExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitMysqlVariableExpressionAtom(s)
	}
}

type BinaryExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewBinaryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryExpressionAtomContext {
	var p = new(BinaryExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *BinaryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryExpressionAtomContext) BINARY() antlr.TerminalNode {
	return s.GetToken(StmtParserBINARY, 0)
}

func (s *BinaryExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *BinaryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterBinaryExpressionAtom(s)
	}
}

func (s *BinaryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitBinaryExpressionAtom(s)
	}
}

type FullColumnNameExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewFullColumnNameExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FullColumnNameExpressionAtomContext {
	var p = new(FullColumnNameExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *FullColumnNameExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameExpressionAtomContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FullColumnNameExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterFullColumnNameExpressionAtom(s)
	}
}

func (s *FullColumnNameExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitFullColumnNameExpressionAtom(s)
	}
}

type BitExpressionAtomContext struct {
	*ExpressionAtomContext
	left  IExpressionAtomContext
	right IExpressionAtomContext
}

func NewBitExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitExpressionAtomContext {
	var p = new(BitExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *BitExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *BitExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }

func (s *BitExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *BitExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *BitExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitExpressionAtomContext) BitOperator() IBitOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitOperatorContext)
}

func (s *BitExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			len++
		}
	}

	tst := make([]IExpressionAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionAtomContext); ok {
			tst[i] = t.(IExpressionAtomContext)
			i++
		}
	}

	return tst
}

func (s *BitExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *BitExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterBitExpressionAtom(s)
	}
}

func (s *BitExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitBitExpressionAtom(s)
	}
}

type NestedExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewNestedExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NestedExpressionAtomContext {
	var p = new(NestedExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *NestedExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *NestedExpressionAtomContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NestedExpressionAtomContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NestedExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *NestedExpressionAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *NestedExpressionAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *NestedExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterNestedExpressionAtom(s)
	}
}

func (s *NestedExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitNestedExpressionAtom(s)
	}
}

type NestedRowExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewNestedRowExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NestedRowExpressionAtomContext {
	var p = new(NestedRowExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *NestedRowExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedRowExpressionAtomContext) ROW() antlr.TerminalNode {
	return s.GetToken(StmtParserROW, 0)
}

func (s *NestedRowExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserLR_BRACKET, 0)
}

func (s *NestedRowExpressionAtomContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NestedRowExpressionAtomContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NestedRowExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(StmtParserRR_BRACKET, 0)
}

func (s *NestedRowExpressionAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(StmtParserCOMMA)
}

func (s *NestedRowExpressionAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMA, i)
}

func (s *NestedRowExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterNestedRowExpressionAtom(s)
	}
}

func (s *NestedRowExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitNestedRowExpressionAtom(s)
	}
}

type MathExpressionAtomContext struct {
	*ExpressionAtomContext
	left  IExpressionAtomContext
	right IExpressionAtomContext
}

func NewMathExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MathExpressionAtomContext {
	var p = new(MathExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *MathExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *MathExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }

func (s *MathExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *MathExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *MathExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MathExpressionAtomContext) MathOperator() IMathOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMathOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMathOperatorContext)
}

func (s *MathExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			len++
		}
	}

	tst := make([]IExpressionAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionAtomContext); ok {
			tst[i] = t.(IExpressionAtomContext)
			i++
		}
	}

	return tst
}

func (s *MathExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *MathExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterMathExpressionAtom(s)
	}
}

func (s *MathExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitMathExpressionAtom(s)
	}
}

type IntervalExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewIntervalExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalExpressionAtomContext {
	var p = new(IntervalExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *IntervalExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalExpressionAtomContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(StmtParserINTERVAL, 0)
}

func (s *IntervalExpressionAtomContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalExpressionAtomContext) IntervalType() IIntervalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *IntervalExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIntervalExpressionAtom(s)
	}
}

func (s *IntervalExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIntervalExpressionAtom(s)
	}
}

func (p *StmtParser) ExpressionAtom() (localctx IExpressionAtomContext) {
	return p.expressionAtom(0)
}

func (p *StmtParser) expressionAtom(_p int) (localctx IExpressionAtomContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionAtomContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionAtomContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 118
	p.EnterRecursionRule(localctx, 118, StmtParserRULE_expressionAtom, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1490)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 227, p.GetParserRuleContext()) {
	case 1:
		localctx = NewConstantExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1456)
			p.Constant()
		}

	case 2:
		localctx = NewFullColumnNameExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1457)
			p.FullColumnName()
		}

	case 3:
		localctx = NewMysqlVariableExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1458)
			p.MysqlVariable()
		}

	case 4:
		localctx = NewUnaryExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1459)
			p.UnaryOperator()
		}
		{
			p.SetState(1460)
			p.expressionAtom(8)
		}

	case 5:
		localctx = NewBinaryExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1462)
			p.Match(StmtParserBINARY)
		}
		{
			p.SetState(1463)
			p.expressionAtom(7)
		}

	case 6:
		localctx = NewNestedExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1464)
			p.Match(StmtParserLR_BRACKET)
		}
		{
			p.SetState(1465)
			p.expression(0)
		}
		p.SetState(1470)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == StmtParserCOMMA {
			{
				p.SetState(1466)
				p.Match(StmtParserCOMMA)
			}
			{
				p.SetState(1467)
				p.expression(0)
			}

			p.SetState(1472)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1473)
			p.Match(StmtParserRR_BRACKET)
		}

	case 7:
		localctx = NewNestedRowExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1475)
			p.Match(StmtParserROW)
		}
		{
			p.SetState(1476)
			p.Match(StmtParserLR_BRACKET)
		}
		{
			p.SetState(1477)
			p.expression(0)
		}
		p.SetState(1480)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == StmtParserCOMMA {
			{
				p.SetState(1478)
				p.Match(StmtParserCOMMA)
			}
			{
				p.SetState(1479)
				p.expression(0)
			}

			p.SetState(1482)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1484)
			p.Match(StmtParserRR_BRACKET)
		}

	case 8:
		localctx = NewIntervalExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1486)
			p.Match(StmtParserINTERVAL)
		}
		{
			p.SetState(1487)
			p.expression(0)
		}
		{
			p.SetState(1488)
			p.IntervalType()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1509)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 229, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1507)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 228, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBitExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*BitExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_expressionAtom)
				p.SetState(1492)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(1493)
					p.BitOperator()
				}
				{
					p.SetState(1494)

					var _x = p.expressionAtom(4)

					localctx.(*BitExpressionAtomContext).right = _x
				}

			case 2:
				localctx = NewMathExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*MathExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_expressionAtom)
				p.SetState(1496)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(1497)
					p.MathOperator()
				}
				{
					p.SetState(1498)

					var _x = p.expressionAtom(3)

					localctx.(*MathExpressionAtomContext).right = _x
				}

			case 3:
				localctx = NewJsonExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*JsonExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_expressionAtom)
				p.SetState(1500)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(1501)
					p.JsonOperator()
				}
				{
					p.SetState(1502)

					var _x = p.expressionAtom(2)

					localctx.(*JsonExpressionAtomContext).right = _x
				}

			case 4:
				localctx = NewCollateExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StmtParserRULE_expressionAtom)
				p.SetState(1504)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(1505)
					p.Match(StmtParserCOLLATE)
				}
				{
					p.SetState(1506)
					p.CollationName()
				}

			}

		}
		p.SetState(1511)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 229, p.GetParserRuleContext())
	}

	return localctx
}

// IUnaryOperatorContext is an interface to support dynamic dispatch.
type IUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryOperatorContext differentiates from other interfaces.
	IsUnaryOperatorContext()
}

type UnaryOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryOperatorContext() *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_unaryOperator
	return p
}

func (*UnaryOperatorContext) IsUnaryOperatorContext() {}

func NewUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_unaryOperator

	return p
}

func (s *UnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEXCLAMATION_SYMBOL, 0)
}

func (s *UnaryOperatorContext) BIT_NOT_OP() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_NOT_OP, 0)
}

func (s *UnaryOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(StmtParserPLUS, 0)
}

func (s *UnaryOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(StmtParserMINUS, 0)
}

func (s *UnaryOperatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOT, 0)
}

func (s *UnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterUnaryOperator(s)
	}
}

func (s *UnaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitUnaryOperator(s)
	}
}

func (p *StmtParser) UnaryOperator() (localctx IUnaryOperatorContext) {
	this := p
	_ = this

	localctx = NewUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, StmtParserRULE_unaryOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1512)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserNOT || (int64((_la-1110)) & ^0x3f) == 0 && ((int64(1)<<(_la-1110))&387) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUAL_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GREATER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserGREATER_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserLESS_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StmtParserEXCLAMATION_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *StmtParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	this := p
	_ = this

	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, StmtParserRULE_comparisonOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1528)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 230, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1514)
			p.Match(StmtParserEQUAL_SYMBOL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1515)
			p.Match(StmtParserGREATER_SYMBOL)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1516)
			p.Match(StmtParserLESS_SYMBOL)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1517)
			p.Match(StmtParserLESS_SYMBOL)
		}
		{
			p.SetState(1518)
			p.Match(StmtParserEQUAL_SYMBOL)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1519)
			p.Match(StmtParserGREATER_SYMBOL)
		}
		{
			p.SetState(1520)
			p.Match(StmtParserEQUAL_SYMBOL)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1521)
			p.Match(StmtParserLESS_SYMBOL)
		}
		{
			p.SetState(1522)
			p.Match(StmtParserGREATER_SYMBOL)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1523)
			p.Match(StmtParserEXCLAMATION_SYMBOL)
		}
		{
			p.SetState(1524)
			p.Match(StmtParserEQUAL_SYMBOL)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1525)
			p.Match(StmtParserLESS_SYMBOL)
		}
		{
			p.SetState(1526)
			p.Match(StmtParserEQUAL_SYMBOL)
		}
		{
			p.SetState(1527)
			p.Match(StmtParserGREATER_SYMBOL)
		}

	}

	return localctx
}

// ILogicalOperatorContext is an interface to support dynamic dispatch.
type ILogicalOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogicalOperatorContext differentiates from other interfaces.
	IsLogicalOperatorContext()
}

type LogicalOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalOperatorContext() *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_logicalOperator
	return p
}

func (*LogicalOperatorContext) IsLogicalOperatorContext() {}

func NewLogicalOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_logicalOperator

	return p
}

func (s *LogicalOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOperatorContext) AND() antlr.TerminalNode {
	return s.GetToken(StmtParserAND, 0)
}

func (s *LogicalOperatorContext) AllBIT_AND_OP() []antlr.TerminalNode {
	return s.GetTokens(StmtParserBIT_AND_OP)
}

func (s *LogicalOperatorContext) BIT_AND_OP(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_AND_OP, i)
}

func (s *LogicalOperatorContext) XOR() antlr.TerminalNode {
	return s.GetToken(StmtParserXOR, 0)
}

func (s *LogicalOperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(StmtParserOR, 0)
}

func (s *LogicalOperatorContext) AllBIT_OR_OP() []antlr.TerminalNode {
	return s.GetTokens(StmtParserBIT_OR_OP)
}

func (s *LogicalOperatorContext) BIT_OR_OP(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_OR_OP, i)
}

func (s *LogicalOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterLogicalOperator(s)
	}
}

func (s *LogicalOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitLogicalOperator(s)
	}
}

func (p *StmtParser) LogicalOperator() (localctx ILogicalOperatorContext) {
	this := p
	_ = this

	localctx = NewLogicalOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, StmtParserRULE_logicalOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1537)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case StmtParserAND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1530)
			p.Match(StmtParserAND)
		}

	case StmtParserBIT_AND_OP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1531)
			p.Match(StmtParserBIT_AND_OP)
		}
		{
			p.SetState(1532)
			p.Match(StmtParserBIT_AND_OP)
		}

	case StmtParserXOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1533)
			p.Match(StmtParserXOR)
		}

	case StmtParserOR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1534)
			p.Match(StmtParserOR)
		}

	case StmtParserBIT_OR_OP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1535)
			p.Match(StmtParserBIT_OR_OP)
		}
		{
			p.SetState(1536)
			p.Match(StmtParserBIT_OR_OP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBitOperatorContext is an interface to support dynamic dispatch.
type IBitOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitOperatorContext differentiates from other interfaces.
	IsBitOperatorContext()
}

type BitOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitOperatorContext() *BitOperatorContext {
	var p = new(BitOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_bitOperator
	return p
}

func (*BitOperatorContext) IsBitOperatorContext() {}

func NewBitOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitOperatorContext {
	var p = new(BitOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_bitOperator

	return p
}

func (s *BitOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *BitOperatorContext) AllLESS_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(StmtParserLESS_SYMBOL)
}

func (s *BitOperatorContext) LESS_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserLESS_SYMBOL, i)
}

func (s *BitOperatorContext) AllGREATER_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(StmtParserGREATER_SYMBOL)
}

func (s *BitOperatorContext) GREATER_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserGREATER_SYMBOL, i)
}

func (s *BitOperatorContext) BIT_AND_OP() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_AND_OP, 0)
}

func (s *BitOperatorContext) BIT_XOR_OP() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_XOR_OP, 0)
}

func (s *BitOperatorContext) BIT_OR_OP() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_OR_OP, 0)
}

func (s *BitOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterBitOperator(s)
	}
}

func (s *BitOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitBitOperator(s)
	}
}

func (p *StmtParser) BitOperator() (localctx IBitOperatorContext) {
	this := p
	_ = this

	localctx = NewBitOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, StmtParserRULE_bitOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1546)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case StmtParserLESS_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1539)
			p.Match(StmtParserLESS_SYMBOL)
		}
		{
			p.SetState(1540)
			p.Match(StmtParserLESS_SYMBOL)
		}

	case StmtParserGREATER_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1541)
			p.Match(StmtParserGREATER_SYMBOL)
		}
		{
			p.SetState(1542)
			p.Match(StmtParserGREATER_SYMBOL)
		}

	case StmtParserBIT_AND_OP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1543)
			p.Match(StmtParserBIT_AND_OP)
		}

	case StmtParserBIT_XOR_OP:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1544)
			p.Match(StmtParserBIT_XOR_OP)
		}

	case StmtParserBIT_OR_OP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1545)
			p.Match(StmtParserBIT_OR_OP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMathOperatorContext is an interface to support dynamic dispatch.
type IMathOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMathOperatorContext differentiates from other interfaces.
	IsMathOperatorContext()
}

type MathOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMathOperatorContext() *MathOperatorContext {
	var p = new(MathOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_mathOperator
	return p
}

func (*MathOperatorContext) IsMathOperatorContext() {}

func NewMathOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MathOperatorContext {
	var p = new(MathOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_mathOperator

	return p
}

func (s *MathOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MathOperatorContext) STAR() antlr.TerminalNode {
	return s.GetToken(StmtParserSTAR, 0)
}

func (s *MathOperatorContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(StmtParserDIVIDE, 0)
}

func (s *MathOperatorContext) MODULE() antlr.TerminalNode {
	return s.GetToken(StmtParserMODULE, 0)
}

func (s *MathOperatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(StmtParserDIV, 0)
}

func (s *MathOperatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(StmtParserMOD, 0)
}

func (s *MathOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(StmtParserPLUS, 0)
}

func (s *MathOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(StmtParserMINUS, 0)
}

func (s *MathOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MathOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MathOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterMathOperator(s)
	}
}

func (s *MathOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitMathOperator(s)
	}
}

func (p *StmtParser) MathOperator() (localctx IMathOperatorContext) {
	this := p
	_ = this

	localctx = NewMathOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, StmtParserRULE_mathOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1548)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-1107)) & ^0x3f) == 0 && ((int64(1)<<(_la-1107))&127) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IJsonOperatorContext is an interface to support dynamic dispatch.
type IJsonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJsonOperatorContext differentiates from other interfaces.
	IsJsonOperatorContext()
}

type JsonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonOperatorContext() *JsonOperatorContext {
	var p = new(JsonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_jsonOperator
	return p
}

func (*JsonOperatorContext) IsJsonOperatorContext() {}

func NewJsonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonOperatorContext {
	var p = new(JsonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_jsonOperator

	return p
}

func (s *JsonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(StmtParserMINUS, 0)
}

func (s *JsonOperatorContext) AllGREATER_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(StmtParserGREATER_SYMBOL)
}

func (s *JsonOperatorContext) GREATER_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(StmtParserGREATER_SYMBOL, i)
}

func (s *JsonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterJsonOperator(s)
	}
}

func (s *JsonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitJsonOperator(s)
	}
}

func (p *StmtParser) JsonOperator() (localctx IJsonOperatorContext) {
	this := p
	_ = this

	localctx = NewJsonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, StmtParserRULE_jsonOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1555)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 233, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1550)
			p.Match(StmtParserMINUS)
		}
		{
			p.SetState(1551)
			p.Match(StmtParserGREATER_SYMBOL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1552)
			p.Match(StmtParserMINUS)
		}
		{
			p.SetState(1553)
			p.Match(StmtParserGREATER_SYMBOL)
		}
		{
			p.SetState(1554)
			p.Match(StmtParserGREATER_SYMBOL)
		}

	}

	return localctx
}

// ICharsetNameBaseContext is an interface to support dynamic dispatch.
type ICharsetNameBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharsetNameBaseContext differentiates from other interfaces.
	IsCharsetNameBaseContext()
}

type CharsetNameBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameBaseContext() *CharsetNameBaseContext {
	var p = new(CharsetNameBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_charsetNameBase
	return p
}

func (*CharsetNameBaseContext) IsCharsetNameBaseContext() {}

func NewCharsetNameBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameBaseContext {
	var p = new(CharsetNameBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_charsetNameBase

	return p
}

func (s *CharsetNameBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameBaseContext) ARMSCII8() antlr.TerminalNode {
	return s.GetToken(StmtParserARMSCII8, 0)
}

func (s *CharsetNameBaseContext) ASCII() antlr.TerminalNode {
	return s.GetToken(StmtParserASCII, 0)
}

func (s *CharsetNameBaseContext) BIG5() antlr.TerminalNode {
	return s.GetToken(StmtParserBIG5, 0)
}

func (s *CharsetNameBaseContext) BINARY() antlr.TerminalNode {
	return s.GetToken(StmtParserBINARY, 0)
}

func (s *CharsetNameBaseContext) CP1250() antlr.TerminalNode {
	return s.GetToken(StmtParserCP1250, 0)
}

func (s *CharsetNameBaseContext) CP1251() antlr.TerminalNode {
	return s.GetToken(StmtParserCP1251, 0)
}

func (s *CharsetNameBaseContext) CP1256() antlr.TerminalNode {
	return s.GetToken(StmtParserCP1256, 0)
}

func (s *CharsetNameBaseContext) CP1257() antlr.TerminalNode {
	return s.GetToken(StmtParserCP1257, 0)
}

func (s *CharsetNameBaseContext) CP850() antlr.TerminalNode {
	return s.GetToken(StmtParserCP850, 0)
}

func (s *CharsetNameBaseContext) CP852() antlr.TerminalNode {
	return s.GetToken(StmtParserCP852, 0)
}

func (s *CharsetNameBaseContext) CP866() antlr.TerminalNode {
	return s.GetToken(StmtParserCP866, 0)
}

func (s *CharsetNameBaseContext) CP932() antlr.TerminalNode {
	return s.GetToken(StmtParserCP932, 0)
}

func (s *CharsetNameBaseContext) DEC8() antlr.TerminalNode {
	return s.GetToken(StmtParserDEC8, 0)
}

func (s *CharsetNameBaseContext) EUCJPMS() antlr.TerminalNode {
	return s.GetToken(StmtParserEUCJPMS, 0)
}

func (s *CharsetNameBaseContext) EUCKR() antlr.TerminalNode {
	return s.GetToken(StmtParserEUCKR, 0)
}

func (s *CharsetNameBaseContext) GB18030() antlr.TerminalNode {
	return s.GetToken(StmtParserGB18030, 0)
}

func (s *CharsetNameBaseContext) GB2312() antlr.TerminalNode {
	return s.GetToken(StmtParserGB2312, 0)
}

func (s *CharsetNameBaseContext) GBK() antlr.TerminalNode {
	return s.GetToken(StmtParserGBK, 0)
}

func (s *CharsetNameBaseContext) GEOSTD8() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOSTD8, 0)
}

func (s *CharsetNameBaseContext) GREEK() antlr.TerminalNode {
	return s.GetToken(StmtParserGREEK, 0)
}

func (s *CharsetNameBaseContext) HEBREW() antlr.TerminalNode {
	return s.GetToken(StmtParserHEBREW, 0)
}

func (s *CharsetNameBaseContext) HP8() antlr.TerminalNode {
	return s.GetToken(StmtParserHP8, 0)
}

func (s *CharsetNameBaseContext) KEYBCS2() antlr.TerminalNode {
	return s.GetToken(StmtParserKEYBCS2, 0)
}

func (s *CharsetNameBaseContext) KOI8R() antlr.TerminalNode {
	return s.GetToken(StmtParserKOI8R, 0)
}

func (s *CharsetNameBaseContext) KOI8U() antlr.TerminalNode {
	return s.GetToken(StmtParserKOI8U, 0)
}

func (s *CharsetNameBaseContext) LATIN1() antlr.TerminalNode {
	return s.GetToken(StmtParserLATIN1, 0)
}

func (s *CharsetNameBaseContext) LATIN2() antlr.TerminalNode {
	return s.GetToken(StmtParserLATIN2, 0)
}

func (s *CharsetNameBaseContext) LATIN5() antlr.TerminalNode {
	return s.GetToken(StmtParserLATIN5, 0)
}

func (s *CharsetNameBaseContext) LATIN7() antlr.TerminalNode {
	return s.GetToken(StmtParserLATIN7, 0)
}

func (s *CharsetNameBaseContext) MACCE() antlr.TerminalNode {
	return s.GetToken(StmtParserMACCE, 0)
}

func (s *CharsetNameBaseContext) MACROMAN() antlr.TerminalNode {
	return s.GetToken(StmtParserMACROMAN, 0)
}

func (s *CharsetNameBaseContext) SJIS() antlr.TerminalNode {
	return s.GetToken(StmtParserSJIS, 0)
}

func (s *CharsetNameBaseContext) SWE7() antlr.TerminalNode {
	return s.GetToken(StmtParserSWE7, 0)
}

func (s *CharsetNameBaseContext) TIS620() antlr.TerminalNode {
	return s.GetToken(StmtParserTIS620, 0)
}

func (s *CharsetNameBaseContext) UCS2() antlr.TerminalNode {
	return s.GetToken(StmtParserUCS2, 0)
}

func (s *CharsetNameBaseContext) UJIS() antlr.TerminalNode {
	return s.GetToken(StmtParserUJIS, 0)
}

func (s *CharsetNameBaseContext) UTF16() antlr.TerminalNode {
	return s.GetToken(StmtParserUTF16, 0)
}

func (s *CharsetNameBaseContext) UTF16LE() antlr.TerminalNode {
	return s.GetToken(StmtParserUTF16LE, 0)
}

func (s *CharsetNameBaseContext) UTF32() antlr.TerminalNode {
	return s.GetToken(StmtParserUTF32, 0)
}

func (s *CharsetNameBaseContext) UTF8() antlr.TerminalNode {
	return s.GetToken(StmtParserUTF8, 0)
}

func (s *CharsetNameBaseContext) UTF8MB3() antlr.TerminalNode {
	return s.GetToken(StmtParserUTF8MB3, 0)
}

func (s *CharsetNameBaseContext) UTF8MB4() antlr.TerminalNode {
	return s.GetToken(StmtParserUTF8MB4, 0)
}

func (s *CharsetNameBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetNameBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterCharsetNameBase(s)
	}
}

func (s *CharsetNameBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitCharsetNameBase(s)
	}
}

func (p *StmtParser) CharsetNameBase() (localctx ICharsetNameBaseContext) {
	this := p
	_ = this

	localctx = NewCharsetNameBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, StmtParserRULE_charsetNameBase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1557)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserBINARY || (int64((_la-726)) & ^0x3f) == 0 && ((int64(1)<<(_la-726))&2199023255551) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITransactionLevelBaseContext is an interface to support dynamic dispatch.
type ITransactionLevelBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransactionLevelBaseContext differentiates from other interfaces.
	IsTransactionLevelBaseContext()
}

type TransactionLevelBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionLevelBaseContext() *TransactionLevelBaseContext {
	var p = new(TransactionLevelBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_transactionLevelBase
	return p
}

func (*TransactionLevelBaseContext) IsTransactionLevelBaseContext() {}

func NewTransactionLevelBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionLevelBaseContext {
	var p = new(TransactionLevelBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_transactionLevelBase

	return p
}

func (s *TransactionLevelBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionLevelBaseContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserREPEATABLE, 0)
}

func (s *TransactionLevelBaseContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMITTED, 0)
}

func (s *TransactionLevelBaseContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(StmtParserUNCOMMITTED, 0)
}

func (s *TransactionLevelBaseContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserSERIALIZABLE, 0)
}

func (s *TransactionLevelBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionLevelBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionLevelBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterTransactionLevelBase(s)
	}
}

func (s *TransactionLevelBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitTransactionLevelBase(s)
	}
}

func (p *StmtParser) TransactionLevelBase() (localctx ITransactionLevelBaseContext) {
	this := p
	_ = this

	localctx = NewTransactionLevelBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, StmtParserRULE_transactionLevelBase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1559)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-779)) & ^0x3f) == 0 && ((int64(1)<<(_la-779))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPrivilegesBaseContext is an interface to support dynamic dispatch.
type IPrivilegesBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrivilegesBaseContext differentiates from other interfaces.
	IsPrivilegesBaseContext()
}

type PrivilegesBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegesBaseContext() *PrivilegesBaseContext {
	var p = new(PrivilegesBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_privilegesBase
	return p
}

func (*PrivilegesBaseContext) IsPrivilegesBaseContext() {}

func NewPrivilegesBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegesBaseContext {
	var p = new(PrivilegesBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_privilegesBase

	return p
}

func (s *PrivilegesBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegesBaseContext) TABLES() antlr.TerminalNode {
	return s.GetToken(StmtParserTABLES, 0)
}

func (s *PrivilegesBaseContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StmtParserROUTINE, 0)
}

func (s *PrivilegesBaseContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserEXECUTE, 0)
}

func (s *PrivilegesBaseContext) FILE() antlr.TerminalNode {
	return s.GetToken(StmtParserFILE, 0)
}

func (s *PrivilegesBaseContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(StmtParserPROCESS, 0)
}

func (s *PrivilegesBaseContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(StmtParserRELOAD, 0)
}

func (s *PrivilegesBaseContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(StmtParserSHUTDOWN, 0)
}

func (s *PrivilegesBaseContext) SUPER() antlr.TerminalNode {
	return s.GetToken(StmtParserSUPER, 0)
}

func (s *PrivilegesBaseContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(StmtParserPRIVILEGES, 0)
}

func (s *PrivilegesBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegesBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegesBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterPrivilegesBase(s)
	}
}

func (s *PrivilegesBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitPrivilegesBase(s)
	}
}

func (p *StmtParser) PrivilegesBase() (localctx IPrivilegesBaseContext) {
	this := p
	_ = this

	localctx = NewPrivilegesBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, StmtParserRULE_privilegesBase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1561)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-680)) & ^0x3f) == 0 && ((int64(1)<<(_la-680))&511) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIntervalTypeBaseContext is an interface to support dynamic dispatch.
type IIntervalTypeBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntervalTypeBaseContext differentiates from other interfaces.
	IsIntervalTypeBaseContext()
}

type IntervalTypeBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalTypeBaseContext() *IntervalTypeBaseContext {
	var p = new(IntervalTypeBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_intervalTypeBase
	return p
}

func (*IntervalTypeBaseContext) IsIntervalTypeBaseContext() {}

func NewIntervalTypeBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalTypeBaseContext {
	var p = new(IntervalTypeBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_intervalTypeBase

	return p
}

func (s *IntervalTypeBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalTypeBaseContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(StmtParserQUARTER, 0)
}

func (s *IntervalTypeBaseContext) MONTH() antlr.TerminalNode {
	return s.GetToken(StmtParserMONTH, 0)
}

func (s *IntervalTypeBaseContext) DAY() antlr.TerminalNode {
	return s.GetToken(StmtParserDAY, 0)
}

func (s *IntervalTypeBaseContext) HOUR() antlr.TerminalNode {
	return s.GetToken(StmtParserHOUR, 0)
}

func (s *IntervalTypeBaseContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserMINUTE, 0)
}

func (s *IntervalTypeBaseContext) WEEK() antlr.TerminalNode {
	return s.GetToken(StmtParserWEEK, 0)
}

func (s *IntervalTypeBaseContext) SECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserSECOND, 0)
}

func (s *IntervalTypeBaseContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserMICROSECOND, 0)
}

func (s *IntervalTypeBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTypeBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalTypeBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterIntervalTypeBase(s)
	}
}

func (s *IntervalTypeBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitIntervalTypeBase(s)
	}
}

func (p *StmtParser) IntervalTypeBase() (localctx IIntervalTypeBaseContext) {
	this := p
	_ = this

	localctx = NewIntervalTypeBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, StmtParserRULE_intervalTypeBase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1563)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-672)) & ^0x3f) == 0 && ((int64(1)<<(_la-672))&255) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDataTypeBaseContext is an interface to support dynamic dispatch.
type IDataTypeBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataTypeBaseContext differentiates from other interfaces.
	IsDataTypeBaseContext()
}

type DataTypeBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeBaseContext() *DataTypeBaseContext {
	var p = new(DataTypeBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_dataTypeBase
	return p
}

func (*DataTypeBaseContext) IsDataTypeBaseContext() {}

func NewDataTypeBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeBaseContext {
	var p = new(DataTypeBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_dataTypeBase

	return p
}

func (s *DataTypeBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeBaseContext) DATE() antlr.TerminalNode {
	return s.GetToken(StmtParserDATE, 0)
}

func (s *DataTypeBaseContext) TIME() antlr.TerminalNode {
	return s.GetToken(StmtParserTIME, 0)
}

func (s *DataTypeBaseContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserTIMESTAMP, 0)
}

func (s *DataTypeBaseContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(StmtParserDATETIME, 0)
}

func (s *DataTypeBaseContext) YEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserYEAR, 0)
}

func (s *DataTypeBaseContext) ENUM() antlr.TerminalNode {
	return s.GetToken(StmtParserENUM, 0)
}

func (s *DataTypeBaseContext) TEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserTEXT, 0)
}

func (s *DataTypeBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterDataTypeBase(s)
	}
}

func (s *DataTypeBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitDataTypeBase(s)
	}
}

func (p *StmtParser) DataTypeBase() (localctx IDataTypeBaseContext) {
	this := p
	_ = this

	localctx = NewDataTypeBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, StmtParserRULE_dataTypeBase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1565)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&1179679) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IKeywordsCanBeIdContext is an interface to support dynamic dispatch.
type IKeywordsCanBeIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeywordsCanBeIdContext differentiates from other interfaces.
	IsKeywordsCanBeIdContext()
}

type KeywordsCanBeIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordsCanBeIdContext() *KeywordsCanBeIdContext {
	var p = new(KeywordsCanBeIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_keywordsCanBeId
	return p
}

func (*KeywordsCanBeIdContext) IsKeywordsCanBeIdContext() {}

func NewKeywordsCanBeIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordsCanBeIdContext {
	var p = new(KeywordsCanBeIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_keywordsCanBeId

	return p
}

func (s *KeywordsCanBeIdContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordsCanBeIdContext) ACCOUNT() antlr.TerminalNode {
	return s.GetToken(StmtParserACCOUNT, 0)
}

func (s *KeywordsCanBeIdContext) ACTION() antlr.TerminalNode {
	return s.GetToken(StmtParserACTION, 0)
}

func (s *KeywordsCanBeIdContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserADMIN, 0)
}

func (s *KeywordsCanBeIdContext) AFTER() antlr.TerminalNode {
	return s.GetToken(StmtParserAFTER, 0)
}

func (s *KeywordsCanBeIdContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(StmtParserAGGREGATE, 0)
}

func (s *KeywordsCanBeIdContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(StmtParserALGORITHM, 0)
}

func (s *KeywordsCanBeIdContext) ANY() antlr.TerminalNode {
	return s.GetToken(StmtParserANY, 0)
}

func (s *KeywordsCanBeIdContext) AT() antlr.TerminalNode {
	return s.GetToken(StmtParserAT, 0)
}

func (s *KeywordsCanBeIdContext) AUDIT_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserAUDIT_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(StmtParserAUTHORS, 0)
}

func (s *KeywordsCanBeIdContext) AUTOCOMMIT() antlr.TerminalNode {
	return s.GetToken(StmtParserAUTOCOMMIT, 0)
}

func (s *KeywordsCanBeIdContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserAUTOEXTEND_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(StmtParserAUTO_INCREMENT, 0)
}

func (s *KeywordsCanBeIdContext) AVG() antlr.TerminalNode {
	return s.GetToken(StmtParserAVG, 0)
}

func (s *KeywordsCanBeIdContext) AVG_ROW_LENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserAVG_ROW_LENGTH, 0)
}

func (s *KeywordsCanBeIdContext) BACKUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserBACKUP_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(StmtParserBEGIN, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(StmtParserBINLOG, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserBINLOG_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserBINLOG_ENCRYPTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BIT() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT, 0)
}

func (s *KeywordsCanBeIdContext) BIT_AND() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_AND, 0)
}

func (s *KeywordsCanBeIdContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_OR, 0)
}

func (s *KeywordsCanBeIdContext) BIT_XOR() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_XOR, 0)
}

func (s *KeywordsCanBeIdContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(StmtParserBLOCK, 0)
}

func (s *KeywordsCanBeIdContext) BOOL() antlr.TerminalNode {
	return s.GetToken(StmtParserBOOL, 0)
}

func (s *KeywordsCanBeIdContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(StmtParserBOOLEAN, 0)
}

func (s *KeywordsCanBeIdContext) BTREE() antlr.TerminalNode {
	return s.GetToken(StmtParserBTREE, 0)
}

func (s *KeywordsCanBeIdContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(StmtParserBUCKETS, 0)
}

func (s *KeywordsCanBeIdContext) CACHE() antlr.TerminalNode {
	return s.GetToken(StmtParserCACHE, 0)
}

func (s *KeywordsCanBeIdContext) CASCADED() antlr.TerminalNode {
	return s.GetToken(StmtParserCASCADED, 0)
}

func (s *KeywordsCanBeIdContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(StmtParserCHAIN, 0)
}

func (s *KeywordsCanBeIdContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(StmtParserCHANGED, 0)
}

func (s *KeywordsCanBeIdContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(StmtParserCHANNEL, 0)
}

func (s *KeywordsCanBeIdContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(StmtParserCHECKSUM, 0)
}

func (s *KeywordsCanBeIdContext) PAGE_CHECKSUM() antlr.TerminalNode {
	return s.GetToken(StmtParserPAGE_CHECKSUM, 0)
}

func (s *KeywordsCanBeIdContext) CATALOG_NAME() antlr.TerminalNode {
	return s.GetToken(StmtParserCATALOG_NAME, 0)
}

func (s *KeywordsCanBeIdContext) CIPHER() antlr.TerminalNode {
	return s.GetToken(StmtParserCIPHER, 0)
}

func (s *KeywordsCanBeIdContext) CLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(StmtParserCLASS_ORIGIN, 0)
}

func (s *KeywordsCanBeIdContext) CLIENT() antlr.TerminalNode {
	return s.GetToken(StmtParserCLIENT, 0)
}

func (s *KeywordsCanBeIdContext) CLONE_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserCLONE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(StmtParserCLOSE, 0)
}

func (s *KeywordsCanBeIdContext) CLUSTERING() antlr.TerminalNode {
	return s.GetToken(StmtParserCLUSTERING, 0)
}

func (s *KeywordsCanBeIdContext) COALESCE() antlr.TerminalNode {
	return s.GetToken(StmtParserCOALESCE, 0)
}

func (s *KeywordsCanBeIdContext) CODE() antlr.TerminalNode {
	return s.GetToken(StmtParserCODE, 0)
}

func (s *KeywordsCanBeIdContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLUMNS, 0)
}

func (s *KeywordsCanBeIdContext) COLUMN_FORMAT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLUMN_FORMAT, 0)
}

func (s *KeywordsCanBeIdContext) COLUMN_NAME() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLUMN_NAME, 0)
}

func (s *KeywordsCanBeIdContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMENT, 0)
}

func (s *KeywordsCanBeIdContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMMIT, 0)
}

func (s *KeywordsCanBeIdContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMPACT, 0)
}

func (s *KeywordsCanBeIdContext) COMPLETION() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMPLETION, 0)
}

func (s *KeywordsCanBeIdContext) COMPRESSED() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMPRESSED, 0)
}

func (s *KeywordsCanBeIdContext) COMPRESSION() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMPRESSION, 0)
}

func (s *KeywordsCanBeIdContext) CONCURRENT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONCURRENT, 0)
}

func (s *KeywordsCanBeIdContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONNECT, 0)
}

func (s *KeywordsCanBeIdContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(StmtParserCONNECTION, 0)
}

func (s *KeywordsCanBeIdContext) CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserCONNECTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONSISTENT, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_CATALOG() antlr.TerminalNode {
	return s.GetToken(StmtParserCONSTRAINT_CATALOG, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(StmtParserCONSTRAINT_NAME, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(StmtParserCONSTRAINT_SCHEMA, 0)
}

func (s *KeywordsCanBeIdContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(StmtParserCONTAINS, 0)
}

func (s *KeywordsCanBeIdContext) CONTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONTEXT, 0)
}

func (s *KeywordsCanBeIdContext) CONTRIBUTORS() antlr.TerminalNode {
	return s.GetToken(StmtParserCONTRIBUTORS, 0)
}

func (s *KeywordsCanBeIdContext) COPY() antlr.TerminalNode {
	return s.GetToken(StmtParserCOPY, 0)
}

func (s *KeywordsCanBeIdContext) COUNT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOUNT, 0)
}

func (s *KeywordsCanBeIdContext) CPU() antlr.TerminalNode {
	return s.GetToken(StmtParserCPU, 0)
}

func (s *KeywordsCanBeIdContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(StmtParserCURRENT, 0)
}

func (s *KeywordsCanBeIdContext) CURSOR_NAME() antlr.TerminalNode {
	return s.GetToken(StmtParserCURSOR_NAME, 0)
}

func (s *KeywordsCanBeIdContext) DATA() antlr.TerminalNode {
	return s.GetToken(StmtParserDATA, 0)
}

func (s *KeywordsCanBeIdContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(StmtParserDATAFILE, 0)
}

func (s *KeywordsCanBeIdContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(StmtParserDEALLOCATE, 0)
}

func (s *KeywordsCanBeIdContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT, 0)
}

func (s *KeywordsCanBeIdContext) DEFAULT_AUTH() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFAULT_AUTH, 0)
}

func (s *KeywordsCanBeIdContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(StmtParserDEFINER, 0)
}

func (s *KeywordsCanBeIdContext) DELAY_KEY_WRITE() antlr.TerminalNode {
	return s.GetToken(StmtParserDELAY_KEY_WRITE, 0)
}

func (s *KeywordsCanBeIdContext) DES_KEY_FILE() antlr.TerminalNode {
	return s.GetToken(StmtParserDES_KEY_FILE, 0)
}

func (s *KeywordsCanBeIdContext) DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(StmtParserDIAGNOSTICS, 0)
}

func (s *KeywordsCanBeIdContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(StmtParserDIRECTORY, 0)
}

func (s *KeywordsCanBeIdContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserDISABLE, 0)
}

func (s *KeywordsCanBeIdContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(StmtParserDISCARD, 0)
}

func (s *KeywordsCanBeIdContext) DISK() antlr.TerminalNode {
	return s.GetToken(StmtParserDISK, 0)
}

func (s *KeywordsCanBeIdContext) DO() antlr.TerminalNode {
	return s.GetToken(StmtParserDO, 0)
}

func (s *KeywordsCanBeIdContext) DUMPFILE() antlr.TerminalNode {
	return s.GetToken(StmtParserDUMPFILE, 0)
}

func (s *KeywordsCanBeIdContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(StmtParserDUPLICATE, 0)
}

func (s *KeywordsCanBeIdContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(StmtParserDYNAMIC, 0)
}

func (s *KeywordsCanBeIdContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserENABLE, 0)
}

func (s *KeywordsCanBeIdContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(StmtParserENCRYPTION, 0)
}

func (s *KeywordsCanBeIdContext) ENCRYPTION_KEY_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserENCRYPTION_KEY_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) END() antlr.TerminalNode {
	return s.GetToken(StmtParserEND, 0)
}

func (s *KeywordsCanBeIdContext) ENDS() antlr.TerminalNode {
	return s.GetToken(StmtParserENDS, 0)
}

func (s *KeywordsCanBeIdContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(StmtParserENGINE, 0)
}

func (s *KeywordsCanBeIdContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserENGINE_ATTRIBUTE, 0)
}

func (s *KeywordsCanBeIdContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(StmtParserENGINES, 0)
}

func (s *KeywordsCanBeIdContext) ERROR() antlr.TerminalNode {
	return s.GetToken(StmtParserERROR, 0)
}

func (s *KeywordsCanBeIdContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(StmtParserERRORS, 0)
}

func (s *KeywordsCanBeIdContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(StmtParserESCAPE, 0)
}

func (s *KeywordsCanBeIdContext) EUR() antlr.TerminalNode {
	return s.GetToken(StmtParserEUR, 0)
}

func (s *KeywordsCanBeIdContext) EVEN() antlr.TerminalNode {
	return s.GetToken(StmtParserEVEN, 0)
}

func (s *KeywordsCanBeIdContext) EVENT() antlr.TerminalNode {
	return s.GetToken(StmtParserEVENT, 0)
}

func (s *KeywordsCanBeIdContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(StmtParserEVENTS, 0)
}

func (s *KeywordsCanBeIdContext) EVERY() antlr.TerminalNode {
	return s.GetToken(StmtParserEVERY, 0)
}

func (s *KeywordsCanBeIdContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(StmtParserEXCEPT, 0)
}

func (s *KeywordsCanBeIdContext) EXCHANGE() antlr.TerminalNode {
	return s.GetToken(StmtParserEXCHANGE, 0)
}

func (s *KeywordsCanBeIdContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(StmtParserEXCLUSIVE, 0)
}

func (s *KeywordsCanBeIdContext) EXPIRE() antlr.TerminalNode {
	return s.GetToken(StmtParserEXPIRE, 0)
}

func (s *KeywordsCanBeIdContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(StmtParserEXPORT, 0)
}

func (s *KeywordsCanBeIdContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(StmtParserEXTENDED, 0)
}

func (s *KeywordsCanBeIdContext) EXTENT_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserEXTENT_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) FAST() antlr.TerminalNode {
	return s.GetToken(StmtParserFAST, 0)
}

func (s *KeywordsCanBeIdContext) FAULTS() antlr.TerminalNode {
	return s.GetToken(StmtParserFAULTS, 0)
}

func (s *KeywordsCanBeIdContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(StmtParserFIELDS, 0)
}

func (s *KeywordsCanBeIdContext) FILE_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserFILE_BLOCK_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) FILTER() antlr.TerminalNode {
	return s.GetToken(StmtParserFILTER, 0)
}

func (s *KeywordsCanBeIdContext) FIREWALL_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserFIREWALL_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) FIREWALL_USER() antlr.TerminalNode {
	return s.GetToken(StmtParserFIREWALL_USER, 0)
}

func (s *KeywordsCanBeIdContext) FIRST() antlr.TerminalNode {
	return s.GetToken(StmtParserFIRST, 0)
}

func (s *KeywordsCanBeIdContext) FIXED() antlr.TerminalNode {
	return s.GetToken(StmtParserFIXED, 0)
}

func (s *KeywordsCanBeIdContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(StmtParserFLUSH, 0)
}

func (s *KeywordsCanBeIdContext) FOLLOWS() antlr.TerminalNode {
	return s.GetToken(StmtParserFOLLOWS, 0)
}

func (s *KeywordsCanBeIdContext) FOUND() antlr.TerminalNode {
	return s.GetToken(StmtParserFOUND, 0)
}

func (s *KeywordsCanBeIdContext) FULL() antlr.TerminalNode {
	return s.GetToken(StmtParserFULL, 0)
}

func (s *KeywordsCanBeIdContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(StmtParserFUNCTION, 0)
}

func (s *KeywordsCanBeIdContext) GENERAL() antlr.TerminalNode {
	return s.GetToken(StmtParserGENERAL, 0)
}

func (s *KeywordsCanBeIdContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StmtParserGLOBAL, 0)
}

func (s *KeywordsCanBeIdContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(StmtParserGRANTS, 0)
}

func (s *KeywordsCanBeIdContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StmtParserGROUP, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(StmtParserGROUP_CONCAT, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_REPLICATION() antlr.TerminalNode {
	return s.GetToken(StmtParserGROUP_REPLICATION, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_REPLICATION_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserGROUP_REPLICATION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(StmtParserHANDLER, 0)
}

func (s *KeywordsCanBeIdContext) HASH() antlr.TerminalNode {
	return s.GetToken(StmtParserHASH, 0)
}

func (s *KeywordsCanBeIdContext) HELP() antlr.TerminalNode {
	return s.GetToken(StmtParserHELP, 0)
}

func (s *KeywordsCanBeIdContext) HOST() antlr.TerminalNode {
	return s.GetToken(StmtParserHOST, 0)
}

func (s *KeywordsCanBeIdContext) HOSTS() antlr.TerminalNode {
	return s.GetToken(StmtParserHOSTS, 0)
}

func (s *KeywordsCanBeIdContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(StmtParserIDENTIFIED, 0)
}

func (s *KeywordsCanBeIdContext) IGNORED() antlr.TerminalNode {
	return s.GetToken(StmtParserIGNORED, 0)
}

func (s *KeywordsCanBeIdContext) IGNORE_SERVER_IDS() antlr.TerminalNode {
	return s.GetToken(StmtParserIGNORE_SERVER_IDS, 0)
}

func (s *KeywordsCanBeIdContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(StmtParserIMPORT, 0)
}

func (s *KeywordsCanBeIdContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(StmtParserINDEXES, 0)
}

func (s *KeywordsCanBeIdContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserINITIAL_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(StmtParserINNODB_REDO_LOG_ARCHIVE, 0)
}

func (s *KeywordsCanBeIdContext) INPLACE() antlr.TerminalNode {
	return s.GetToken(StmtParserINPLACE, 0)
}

func (s *KeywordsCanBeIdContext) INSERT_METHOD() antlr.TerminalNode {
	return s.GetToken(StmtParserINSERT_METHOD, 0)
}

func (s *KeywordsCanBeIdContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(StmtParserINSTALL, 0)
}

func (s *KeywordsCanBeIdContext) INSTANCE() antlr.TerminalNode {
	return s.GetToken(StmtParserINSTANCE, 0)
}

func (s *KeywordsCanBeIdContext) INSTANT() antlr.TerminalNode {
	return s.GetToken(StmtParserINSTANT, 0)
}

func (s *KeywordsCanBeIdContext) INTERNAL() antlr.TerminalNode {
	return s.GetToken(StmtParserINTERNAL, 0)
}

func (s *KeywordsCanBeIdContext) INVOKE() antlr.TerminalNode {
	return s.GetToken(StmtParserINVOKE, 0)
}

func (s *KeywordsCanBeIdContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(StmtParserINVOKER, 0)
}

func (s *KeywordsCanBeIdContext) IO() antlr.TerminalNode {
	return s.GetToken(StmtParserIO, 0)
}

func (s *KeywordsCanBeIdContext) IO_THREAD() antlr.TerminalNode {
	return s.GetToken(StmtParserIO_THREAD, 0)
}

func (s *KeywordsCanBeIdContext) IPC() antlr.TerminalNode {
	return s.GetToken(StmtParserIPC, 0)
}

func (s *KeywordsCanBeIdContext) ISO() antlr.TerminalNode {
	return s.GetToken(StmtParserISO, 0)
}

func (s *KeywordsCanBeIdContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(StmtParserISOLATION, 0)
}

func (s *KeywordsCanBeIdContext) ISSUER() antlr.TerminalNode {
	return s.GetToken(StmtParserISSUER, 0)
}

func (s *KeywordsCanBeIdContext) JIS() antlr.TerminalNode {
	return s.GetToken(StmtParserJIS, 0)
}

func (s *KeywordsCanBeIdContext) JSON() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON, 0)
}

func (s *KeywordsCanBeIdContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserKEY_BLOCK_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(StmtParserLAMBDA, 0)
}

func (s *KeywordsCanBeIdContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(StmtParserLANGUAGE, 0)
}

func (s *KeywordsCanBeIdContext) LAST() antlr.TerminalNode {
	return s.GetToken(StmtParserLAST, 0)
}

func (s *KeywordsCanBeIdContext) LEAVES() antlr.TerminalNode {
	return s.GetToken(StmtParserLEAVES, 0)
}

func (s *KeywordsCanBeIdContext) LESS() antlr.TerminalNode {
	return s.GetToken(StmtParserLESS, 0)
}

func (s *KeywordsCanBeIdContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(StmtParserLEVEL, 0)
}

func (s *KeywordsCanBeIdContext) LIST() antlr.TerminalNode {
	return s.GetToken(StmtParserLIST, 0)
}

func (s *KeywordsCanBeIdContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(StmtParserLOCAL, 0)
}

func (s *KeywordsCanBeIdContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(StmtParserLOGFILE, 0)
}

func (s *KeywordsCanBeIdContext) LOGS() antlr.TerminalNode {
	return s.GetToken(StmtParserLOGS, 0)
}

func (s *KeywordsCanBeIdContext) MASTER() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_AUTO_POSITION() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_AUTO_POSITION, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_CONNECT_RETRY() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_CONNECT_RETRY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_DELAY() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_DELAY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_HEARTBEAT_PERIOD() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_HEARTBEAT_PERIOD, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_HOST() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_HOST, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_LOG_FILE, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_LOG_POS() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_LOG_POS, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_PASSWORD() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_PASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_PORT() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_PORT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_RETRY_COUNT() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_RETRY_COUNT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_SSL, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CA() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_SSL_CA, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CAPATH() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_SSL_CAPATH, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CERT() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_SSL_CERT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CIPHER() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_SSL_CIPHER, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CRL() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_SSL_CRL, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CRLPATH() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_SSL_CRLPATH, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_SSL_KEY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_TLS_VERSION() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_TLS_VERSION, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_USER() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_USER, 0)
}

func (s *KeywordsCanBeIdContext) MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(StmtParserMAX_CONNECTIONS_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX_QUERIES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(StmtParserMAX_QUERIES_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX() antlr.TerminalNode {
	return s.GetToken(StmtParserMAX, 0)
}

func (s *KeywordsCanBeIdContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(StmtParserMAX_ROWS, 0)
}

func (s *KeywordsCanBeIdContext) MAX_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserMAX_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) MAX_UPDATES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(StmtParserMAX_UPDATES_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX_USER_CONNECTIONS() antlr.TerminalNode {
	return s.GetToken(StmtParserMAX_USER_CONNECTIONS, 0)
}

func (s *KeywordsCanBeIdContext) MEDIUM() antlr.TerminalNode {
	return s.GetToken(StmtParserMEDIUM, 0)
}

func (s *KeywordsCanBeIdContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(StmtParserMEMBER, 0)
}

func (s *KeywordsCanBeIdContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(StmtParserMEMORY, 0)
}

func (s *KeywordsCanBeIdContext) MERGE() antlr.TerminalNode {
	return s.GetToken(StmtParserMERGE, 0)
}

func (s *KeywordsCanBeIdContext) MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserMESSAGE_TEXT, 0)
}

func (s *KeywordsCanBeIdContext) MID() antlr.TerminalNode {
	return s.GetToken(StmtParserMID, 0)
}

func (s *KeywordsCanBeIdContext) MIGRATE() antlr.TerminalNode {
	return s.GetToken(StmtParserMIGRATE, 0)
}

func (s *KeywordsCanBeIdContext) MIN() antlr.TerminalNode {
	return s.GetToken(StmtParserMIN, 0)
}

func (s *KeywordsCanBeIdContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(StmtParserMIN_ROWS, 0)
}

func (s *KeywordsCanBeIdContext) MODE() antlr.TerminalNode {
	return s.GetToken(StmtParserMODE, 0)
}

func (s *KeywordsCanBeIdContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StmtParserMODIFY, 0)
}

func (s *KeywordsCanBeIdContext) MUTEX() antlr.TerminalNode {
	return s.GetToken(StmtParserMUTEX, 0)
}

func (s *KeywordsCanBeIdContext) MYSQL() antlr.TerminalNode {
	return s.GetToken(StmtParserMYSQL, 0)
}

func (s *KeywordsCanBeIdContext) MYSQL_ERRNO() antlr.TerminalNode {
	return s.GetToken(StmtParserMYSQL_ERRNO, 0)
}

func (s *KeywordsCanBeIdContext) NAME() antlr.TerminalNode {
	return s.GetToken(StmtParserNAME, 0)
}

func (s *KeywordsCanBeIdContext) NAMES() antlr.TerminalNode {
	return s.GetToken(StmtParserNAMES, 0)
}

func (s *KeywordsCanBeIdContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(StmtParserNCHAR, 0)
}

func (s *KeywordsCanBeIdContext) NDB_STORED_USER() antlr.TerminalNode {
	return s.GetToken(StmtParserNDB_STORED_USER, 0)
}

func (s *KeywordsCanBeIdContext) NEVER() antlr.TerminalNode {
	return s.GetToken(StmtParserNEVER, 0)
}

func (s *KeywordsCanBeIdContext) NEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserNEXT, 0)
}

func (s *KeywordsCanBeIdContext) NO() antlr.TerminalNode {
	return s.GetToken(StmtParserNO, 0)
}

func (s *KeywordsCanBeIdContext) NOCOPY() antlr.TerminalNode {
	return s.GetToken(StmtParserNOCOPY, 0)
}

func (s *KeywordsCanBeIdContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(StmtParserNODEGROUP, 0)
}

func (s *KeywordsCanBeIdContext) NONE() antlr.TerminalNode {
	return s.GetToken(StmtParserNONE, 0)
}

func (s *KeywordsCanBeIdContext) NOWAIT() antlr.TerminalNode {
	return s.GetToken(StmtParserNOWAIT, 0)
}

func (s *KeywordsCanBeIdContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(StmtParserNUMBER, 0)
}

func (s *KeywordsCanBeIdContext) ODBC() antlr.TerminalNode {
	return s.GetToken(StmtParserODBC, 0)
}

func (s *KeywordsCanBeIdContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(StmtParserOFFLINE, 0)
}

func (s *KeywordsCanBeIdContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(StmtParserOFFSET, 0)
}

func (s *KeywordsCanBeIdContext) OF() antlr.TerminalNode {
	return s.GetToken(StmtParserOF, 0)
}

func (s *KeywordsCanBeIdContext) OJ() antlr.TerminalNode {
	return s.GetToken(StmtParserOJ, 0)
}

func (s *KeywordsCanBeIdContext) OLD_PASSWORD() antlr.TerminalNode {
	return s.GetToken(StmtParserOLD_PASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) ONE() antlr.TerminalNode {
	return s.GetToken(StmtParserONE, 0)
}

func (s *KeywordsCanBeIdContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(StmtParserONLINE, 0)
}

func (s *KeywordsCanBeIdContext) ONLY() antlr.TerminalNode {
	return s.GetToken(StmtParserONLY, 0)
}

func (s *KeywordsCanBeIdContext) OPEN() antlr.TerminalNode {
	return s.GetToken(StmtParserOPEN, 0)
}

func (s *KeywordsCanBeIdContext) OPTIMIZER_COSTS() antlr.TerminalNode {
	return s.GetToken(StmtParserOPTIMIZER_COSTS, 0)
}

func (s *KeywordsCanBeIdContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(StmtParserOPTIONAL, 0)
}

func (s *KeywordsCanBeIdContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(StmtParserOPTIONS, 0)
}

func (s *KeywordsCanBeIdContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StmtParserORDER, 0)
}

func (s *KeywordsCanBeIdContext) OWNER() antlr.TerminalNode {
	return s.GetToken(StmtParserOWNER, 0)
}

func (s *KeywordsCanBeIdContext) PACK_KEYS() antlr.TerminalNode {
	return s.GetToken(StmtParserPACK_KEYS, 0)
}

func (s *KeywordsCanBeIdContext) PAGE() antlr.TerminalNode {
	return s.GetToken(StmtParserPAGE, 0)
}

func (s *KeywordsCanBeIdContext) PARSER() antlr.TerminalNode {
	return s.GetToken(StmtParserPARSER, 0)
}

func (s *KeywordsCanBeIdContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTIAL, 0)
}

func (s *KeywordsCanBeIdContext) PARTITIONING() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTITIONING, 0)
}

func (s *KeywordsCanBeIdContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(StmtParserPARTITIONS, 0)
}

func (s *KeywordsCanBeIdContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(StmtParserPASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) PASSWORDLESS_USER_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserPASSWORDLESS_USER_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserPERSIST_RO_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) PHASE() antlr.TerminalNode {
	return s.GetToken(StmtParserPHASE, 0)
}

func (s *KeywordsCanBeIdContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(StmtParserPLUGINS, 0)
}

func (s *KeywordsCanBeIdContext) PLUGIN_DIR() antlr.TerminalNode {
	return s.GetToken(StmtParserPLUGIN_DIR, 0)
}

func (s *KeywordsCanBeIdContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(StmtParserPLUGIN, 0)
}

func (s *KeywordsCanBeIdContext) PORT() antlr.TerminalNode {
	return s.GetToken(StmtParserPORT, 0)
}

func (s *KeywordsCanBeIdContext) PRECEDES() antlr.TerminalNode {
	return s.GetToken(StmtParserPRECEDES, 0)
}

func (s *KeywordsCanBeIdContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(StmtParserPREPARE, 0)
}

func (s *KeywordsCanBeIdContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(StmtParserPRESERVE, 0)
}

func (s *KeywordsCanBeIdContext) PREV() antlr.TerminalNode {
	return s.GetToken(StmtParserPREV, 0)
}

func (s *KeywordsCanBeIdContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(StmtParserPRIMARY, 0)
}

func (s *KeywordsCanBeIdContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(StmtParserPROCESSLIST, 0)
}

func (s *KeywordsCanBeIdContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(StmtParserPROFILE, 0)
}

func (s *KeywordsCanBeIdContext) PROFILES() antlr.TerminalNode {
	return s.GetToken(StmtParserPROFILES, 0)
}

func (s *KeywordsCanBeIdContext) PROXY() antlr.TerminalNode {
	return s.GetToken(StmtParserPROXY, 0)
}

func (s *KeywordsCanBeIdContext) QUERY() antlr.TerminalNode {
	return s.GetToken(StmtParserQUERY, 0)
}

func (s *KeywordsCanBeIdContext) QUICK() antlr.TerminalNode {
	return s.GetToken(StmtParserQUICK, 0)
}

func (s *KeywordsCanBeIdContext) REBUILD() antlr.TerminalNode {
	return s.GetToken(StmtParserREBUILD, 0)
}

func (s *KeywordsCanBeIdContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(StmtParserRECOVER, 0)
}

func (s *KeywordsCanBeIdContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(StmtParserRECURSIVE, 0)
}

func (s *KeywordsCanBeIdContext) REDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserREDO_BUFFER_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) REDUNDANT() antlr.TerminalNode {
	return s.GetToken(StmtParserREDUNDANT, 0)
}

func (s *KeywordsCanBeIdContext) RELAY() antlr.TerminalNode {
	return s.GetToken(StmtParserRELAY, 0)
}

func (s *KeywordsCanBeIdContext) RELAYLOG() antlr.TerminalNode {
	return s.GetToken(StmtParserRELAYLOG, 0)
}

func (s *KeywordsCanBeIdContext) RELAY_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(StmtParserRELAY_LOG_FILE, 0)
}

func (s *KeywordsCanBeIdContext) RELAY_LOG_POS() antlr.TerminalNode {
	return s.GetToken(StmtParserRELAY_LOG_POS, 0)
}

func (s *KeywordsCanBeIdContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(StmtParserREMOVE, 0)
}

func (s *KeywordsCanBeIdContext) REORGANIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserREORGANIZE, 0)
}

func (s *KeywordsCanBeIdContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(StmtParserREPAIR, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_DO_DB() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATE_DO_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATE_DO_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_IGNORE_DB() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATE_IGNORE_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATE_IGNORE_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_REWRITE_DB() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATE_REWRITE_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_WILD_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATE_WILD_DO_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_WILD_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATE_WILD_IGNORE_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATION, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION_APPLIER() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATION_APPLIER, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION_SLAVE_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATION_SLAVE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) RESET() antlr.TerminalNode {
	return s.GetToken(StmtParserRESET, 0)
}

func (s *KeywordsCanBeIdContext) RESOURCE_GROUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserRESOURCE_GROUP_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) RESOURCE_GROUP_USER() antlr.TerminalNode {
	return s.GetToken(StmtParserRESOURCE_GROUP_USER, 0)
}

func (s *KeywordsCanBeIdContext) RESUME() antlr.TerminalNode {
	return s.GetToken(StmtParserRESUME, 0)
}

func (s *KeywordsCanBeIdContext) RETURNED_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(StmtParserRETURNED_SQLSTATE, 0)
}

func (s *KeywordsCanBeIdContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(StmtParserRETURNS, 0)
}

func (s *KeywordsCanBeIdContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StmtParserROLE, 0)
}

func (s *KeywordsCanBeIdContext) ROLE_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserROLE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(StmtParserROLLBACK, 0)
}

func (s *KeywordsCanBeIdContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(StmtParserROLLUP, 0)
}

func (s *KeywordsCanBeIdContext) ROTATE() antlr.TerminalNode {
	return s.GetToken(StmtParserROTATE, 0)
}

func (s *KeywordsCanBeIdContext) ROW() antlr.TerminalNode {
	return s.GetToken(StmtParserROW, 0)
}

func (s *KeywordsCanBeIdContext) ROWS() antlr.TerminalNode {
	return s.GetToken(StmtParserROWS, 0)
}

func (s *KeywordsCanBeIdContext) ROW_FORMAT() antlr.TerminalNode {
	return s.GetToken(StmtParserROW_FORMAT, 0)
}

func (s *KeywordsCanBeIdContext) RTREE() antlr.TerminalNode {
	return s.GetToken(StmtParserRTREE, 0)
}

func (s *KeywordsCanBeIdContext) S3() antlr.TerminalNode {
	return s.GetToken(StmtParserS3, 0)
}

func (s *KeywordsCanBeIdContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserSAVEPOINT, 0)
}

func (s *KeywordsCanBeIdContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(StmtParserSCHEDULE, 0)
}

func (s *KeywordsCanBeIdContext) SCHEMA_NAME() antlr.TerminalNode {
	return s.GetToken(StmtParserSCHEMA_NAME, 0)
}

func (s *KeywordsCanBeIdContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StmtParserSECURITY, 0)
}

func (s *KeywordsCanBeIdContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *KeywordsCanBeIdContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSERIAL, 0)
}

func (s *KeywordsCanBeIdContext) SERVER() antlr.TerminalNode {
	return s.GetToken(StmtParserSERVER, 0)
}

func (s *KeywordsCanBeIdContext) SESSION() antlr.TerminalNode {
	return s.GetToken(StmtParserSESSION, 0)
}

func (s *KeywordsCanBeIdContext) SESSION_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserSESSION_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) SET_USER_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserSET_USER_ID, 0)
}

func (s *KeywordsCanBeIdContext) SHARE() antlr.TerminalNode {
	return s.GetToken(StmtParserSHARE, 0)
}

func (s *KeywordsCanBeIdContext) SHARED() antlr.TerminalNode {
	return s.GetToken(StmtParserSHARED, 0)
}

func (s *KeywordsCanBeIdContext) SHOW_ROUTINE() antlr.TerminalNode {
	return s.GetToken(StmtParserSHOW_ROUTINE, 0)
}

func (s *KeywordsCanBeIdContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(StmtParserSIGNED, 0)
}

func (s *KeywordsCanBeIdContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(StmtParserSIMPLE, 0)
}

func (s *KeywordsCanBeIdContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(StmtParserSLAVE, 0)
}

func (s *KeywordsCanBeIdContext) SLOW() antlr.TerminalNode {
	return s.GetToken(StmtParserSLOW, 0)
}

func (s *KeywordsCanBeIdContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(StmtParserSNAPSHOT, 0)
}

func (s *KeywordsCanBeIdContext) SOCKET() antlr.TerminalNode {
	return s.GetToken(StmtParserSOCKET, 0)
}

func (s *KeywordsCanBeIdContext) SOME() antlr.TerminalNode {
	return s.GetToken(StmtParserSOME, 0)
}

func (s *KeywordsCanBeIdContext) SONAME() antlr.TerminalNode {
	return s.GetToken(StmtParserSONAME, 0)
}

func (s *KeywordsCanBeIdContext) SOUNDS() antlr.TerminalNode {
	return s.GetToken(StmtParserSOUNDS, 0)
}

func (s *KeywordsCanBeIdContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(StmtParserSOURCE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(StmtParserSQL_AFTER_GTIDS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_AFTER_MTS_GAPS() antlr.TerminalNode {
	return s.GetToken(StmtParserSQL_AFTER_MTS_GAPS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_BEFORE_GTIDS() antlr.TerminalNode {
	return s.GetToken(StmtParserSQL_BEFORE_GTIDS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_BUFFER_RESULT() antlr.TerminalNode {
	return s.GetToken(StmtParserSQL_BUFFER_RESULT, 0)
}

func (s *KeywordsCanBeIdContext) SQL_CACHE() antlr.TerminalNode {
	return s.GetToken(StmtParserSQL_CACHE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_NO_CACHE() antlr.TerminalNode {
	return s.GetToken(StmtParserSQL_NO_CACHE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_THREAD() antlr.TerminalNode {
	return s.GetToken(StmtParserSQL_THREAD, 0)
}

func (s *KeywordsCanBeIdContext) STACKED() antlr.TerminalNode {
	return s.GetToken(StmtParserSTACKED, 0)
}

func (s *KeywordsCanBeIdContext) START() antlr.TerminalNode {
	return s.GetToken(StmtParserSTART, 0)
}

func (s *KeywordsCanBeIdContext) STARTS() antlr.TerminalNode {
	return s.GetToken(StmtParserSTARTS, 0)
}

func (s *KeywordsCanBeIdContext) STATS_AUTO_RECALC() antlr.TerminalNode {
	return s.GetToken(StmtParserSTATS_AUTO_RECALC, 0)
}

func (s *KeywordsCanBeIdContext) STATS_PERSISTENT() antlr.TerminalNode {
	return s.GetToken(StmtParserSTATS_PERSISTENT, 0)
}

func (s *KeywordsCanBeIdContext) STATS_SAMPLE_PAGES() antlr.TerminalNode {
	return s.GetToken(StmtParserSTATS_SAMPLE_PAGES, 0)
}

func (s *KeywordsCanBeIdContext) STATUS() antlr.TerminalNode {
	return s.GetToken(StmtParserSTATUS, 0)
}

func (s *KeywordsCanBeIdContext) STD() antlr.TerminalNode {
	return s.GetToken(StmtParserSTD, 0)
}

func (s *KeywordsCanBeIdContext) STDDEV() antlr.TerminalNode {
	return s.GetToken(StmtParserSTDDEV, 0)
}

func (s *KeywordsCanBeIdContext) STDDEV_POP() antlr.TerminalNode {
	return s.GetToken(StmtParserSTDDEV_POP, 0)
}

func (s *KeywordsCanBeIdContext) STDDEV_SAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserSTDDEV_SAMP, 0)
}

func (s *KeywordsCanBeIdContext) STOP() antlr.TerminalNode {
	return s.GetToken(StmtParserSTOP, 0)
}

func (s *KeywordsCanBeIdContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StmtParserSTORAGE, 0)
}

func (s *KeywordsCanBeIdContext) STRING() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRING, 0)
}

func (s *KeywordsCanBeIdContext) SUBCLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBCLASS_ORIGIN, 0)
}

func (s *KeywordsCanBeIdContext) SUBJECT() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBJECT, 0)
}

func (s *KeywordsCanBeIdContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBPARTITION, 0)
}

func (s *KeywordsCanBeIdContext) SUBPARTITIONS() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBPARTITIONS, 0)
}

func (s *KeywordsCanBeIdContext) SUM() antlr.TerminalNode {
	return s.GetToken(StmtParserSUM, 0)
}

func (s *KeywordsCanBeIdContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(StmtParserSUSPEND, 0)
}

func (s *KeywordsCanBeIdContext) SWAPS() antlr.TerminalNode {
	return s.GetToken(StmtParserSWAPS, 0)
}

func (s *KeywordsCanBeIdContext) SWITCHES() antlr.TerminalNode {
	return s.GetToken(StmtParserSWITCHES, 0)
}

func (s *KeywordsCanBeIdContext) SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserSYSTEM_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_NAME() antlr.TerminalNode {
	return s.GetToken(StmtParserTABLE_NAME, 0)
}

func (s *KeywordsCanBeIdContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(StmtParserTABLESPACE, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserTABLE_ENCRYPTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_TYPE() antlr.TerminalNode {
	return s.GetToken(StmtParserTABLE_TYPE, 0)
}

func (s *KeywordsCanBeIdContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StmtParserTEMPORARY, 0)
}

func (s *KeywordsCanBeIdContext) TEMPTABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserTEMPTABLE, 0)
}

func (s *KeywordsCanBeIdContext) THAN() antlr.TerminalNode {
	return s.GetToken(StmtParserTHAN, 0)
}

func (s *KeywordsCanBeIdContext) TRADITIONAL() antlr.TerminalNode {
	return s.GetToken(StmtParserTRADITIONAL, 0)
}

func (s *KeywordsCanBeIdContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(StmtParserTRANSACTION, 0)
}

func (s *KeywordsCanBeIdContext) TRANSACTIONAL() antlr.TerminalNode {
	return s.GetToken(StmtParserTRANSACTIONAL, 0)
}

func (s *KeywordsCanBeIdContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(StmtParserTRIGGERS, 0)
}

func (s *KeywordsCanBeIdContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(StmtParserTRUNCATE, 0)
}

func (s *KeywordsCanBeIdContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(StmtParserUNDEFINED, 0)
}

func (s *KeywordsCanBeIdContext) UNDOFILE() antlr.TerminalNode {
	return s.GetToken(StmtParserUNDOFILE, 0)
}

func (s *KeywordsCanBeIdContext) UNDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserUNDO_BUFFER_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(StmtParserUNINSTALL, 0)
}

func (s *KeywordsCanBeIdContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(StmtParserUNKNOWN, 0)
}

func (s *KeywordsCanBeIdContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(StmtParserUNTIL, 0)
}

func (s *KeywordsCanBeIdContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(StmtParserUPGRADE, 0)
}

func (s *KeywordsCanBeIdContext) USA() antlr.TerminalNode {
	return s.GetToken(StmtParserUSA, 0)
}

func (s *KeywordsCanBeIdContext) USER() antlr.TerminalNode {
	return s.GetToken(StmtParserUSER, 0)
}

func (s *KeywordsCanBeIdContext) USE_FRM() antlr.TerminalNode {
	return s.GetToken(StmtParserUSE_FRM, 0)
}

func (s *KeywordsCanBeIdContext) USER_RESOURCES() antlr.TerminalNode {
	return s.GetToken(StmtParserUSER_RESOURCES, 0)
}

func (s *KeywordsCanBeIdContext) VALIDATION() antlr.TerminalNode {
	return s.GetToken(StmtParserVALIDATION, 0)
}

func (s *KeywordsCanBeIdContext) VALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserVALUE, 0)
}

func (s *KeywordsCanBeIdContext) VAR_POP() antlr.TerminalNode {
	return s.GetToken(StmtParserVAR_POP, 0)
}

func (s *KeywordsCanBeIdContext) VAR_SAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserVAR_SAMP, 0)
}

func (s *KeywordsCanBeIdContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(StmtParserVARIABLES, 0)
}

func (s *KeywordsCanBeIdContext) VARIANCE() antlr.TerminalNode {
	return s.GetToken(StmtParserVARIANCE, 0)
}

func (s *KeywordsCanBeIdContext) VERSION_TOKEN_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserVERSION_TOKEN_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StmtParserVIEW, 0)
}

func (s *KeywordsCanBeIdContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(StmtParserVIRTUAL, 0)
}

func (s *KeywordsCanBeIdContext) WAIT() antlr.TerminalNode {
	return s.GetToken(StmtParserWAIT, 0)
}

func (s *KeywordsCanBeIdContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(StmtParserWARNINGS, 0)
}

func (s *KeywordsCanBeIdContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(StmtParserWITHOUT, 0)
}

func (s *KeywordsCanBeIdContext) WORK() antlr.TerminalNode {
	return s.GetToken(StmtParserWORK, 0)
}

func (s *KeywordsCanBeIdContext) WRAPPER() antlr.TerminalNode {
	return s.GetToken(StmtParserWRAPPER, 0)
}

func (s *KeywordsCanBeIdContext) X509() antlr.TerminalNode {
	return s.GetToken(StmtParserX509, 0)
}

func (s *KeywordsCanBeIdContext) XA() antlr.TerminalNode {
	return s.GetToken(StmtParserXA, 0)
}

func (s *KeywordsCanBeIdContext) XA_RECOVER_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserXA_RECOVER_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) XML() antlr.TerminalNode {
	return s.GetToken(StmtParserXML, 0)
}

func (s *KeywordsCanBeIdContext) VIA() antlr.TerminalNode {
	return s.GetToken(StmtParserVIA, 0)
}

func (s *KeywordsCanBeIdContext) LASTVAL() antlr.TerminalNode {
	return s.GetToken(StmtParserLASTVAL, 0)
}

func (s *KeywordsCanBeIdContext) NEXTVAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNEXTVAL, 0)
}

func (s *KeywordsCanBeIdContext) SETVAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSETVAL, 0)
}

func (s *KeywordsCanBeIdContext) PREVIOUS() antlr.TerminalNode {
	return s.GetToken(StmtParserPREVIOUS, 0)
}

func (s *KeywordsCanBeIdContext) PERSISTENT() antlr.TerminalNode {
	return s.GetToken(StmtParserPERSISTENT, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION_MASTER_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICATION_MASTER_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(StmtParserREPLICA, 0)
}

func (s *KeywordsCanBeIdContext) READ_ONLY_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserREAD_ONLY_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) FEDERATED_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserFEDERATED_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_MONITOR() antlr.TerminalNode {
	return s.GetToken(StmtParserBINLOG_MONITOR, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_REPLAY() antlr.TerminalNode {
	return s.GetToken(StmtParserBINLOG_REPLAY, 0)
}

func (s *KeywordsCanBeIdContext) SKIP_() antlr.TerminalNode {
	return s.GetToken(StmtParserSKIP_, 0)
}

func (s *KeywordsCanBeIdContext) LOCKED() antlr.TerminalNode {
	return s.GetToken(StmtParserLOCKED, 0)
}

func (s *KeywordsCanBeIdContext) CYCLE() antlr.TerminalNode {
	return s.GetToken(StmtParserCYCLE, 0)
}

func (s *KeywordsCanBeIdContext) INCREMENT() antlr.TerminalNode {
	return s.GetToken(StmtParserINCREMENT, 0)
}

func (s *KeywordsCanBeIdContext) MINVALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserMINVALUE, 0)
}

func (s *KeywordsCanBeIdContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserMAXVALUE, 0)
}

func (s *KeywordsCanBeIdContext) NOCACHE() antlr.TerminalNode {
	return s.GetToken(StmtParserNOCACHE, 0)
}

func (s *KeywordsCanBeIdContext) NOCYCLE() antlr.TerminalNode {
	return s.GetToken(StmtParserNOCYCLE, 0)
}

func (s *KeywordsCanBeIdContext) NOMINVALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserNOMINVALUE, 0)
}

func (s *KeywordsCanBeIdContext) NOMAXVALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserNOMAXVALUE, 0)
}

func (s *KeywordsCanBeIdContext) RESTART() antlr.TerminalNode {
	return s.GetToken(StmtParserRESTART, 0)
}

func (s *KeywordsCanBeIdContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(StmtParserSEQUENCE, 0)
}

func (s *KeywordsCanBeIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordsCanBeIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordsCanBeIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterKeywordsCanBeId(s)
	}
}

func (s *KeywordsCanBeIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitKeywordsCanBeId(s)
	}
}

func (p *StmtParser) KeywordsCanBeId() (localctx IKeywordsCanBeIdContext) {
	this := p
	_ = this

	localctx = NewKeywordsCanBeIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, StmtParserRULE_keywordsCanBeId)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1567)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-17)) & ^0x3f) == 0 && ((int64(1)<<(_la-17))&585468501859368961) != 0 || (int64((_la-100)) & ^0x3f) == 0 && ((int64(1)<<(_la-100))&-9214364837531737919) != 0 || (int64((_la-233)) & ^0x3f) == 0 && ((int64(1)<<(_la-233))&-9002150297346244607) != 0 || (int64((_la-297)) & ^0x3f) == 0 && ((int64(1)<<(_la-297))&-67108737) != 0 || (int64((_la-361)) & ^0x3f) == 0 && ((int64(1)<<(_la-361))&-1152921504606846977) != 0 || (int64((_la-425)) & ^0x3f) == 0 && ((int64(1)<<(_la-425))&-2097153) != 0 || (int64((_la-489)) & ^0x3f) == 0 && ((int64(1)<<(_la-489))&-18014398509481985) != 0 || (int64((_la-553)) & ^0x3f) == 0 && ((int64(1)<<(_la-553))&-16777217) != 0 || (int64((_la-617)) & ^0x3f) == 0 && ((int64(1)<<(_la-617))&35460899254829047) != 0 || (int64((_la-690)) & ^0x3f) == 0 && ((int64(1)<<(_la-690))&68450968063) != 0 || _la == StmtParserMEMORY || _la == StmtParserCATALOG_NAME || _la == StmtParserENGINE_ATTRIBUTE || _la == StmtParserSECONDARY_ENGINE_ATTRIBUTE || _la == StmtParserSCHEMA_NAME || (int64((_la-1086)) & ^0x3f) == 0 && ((int64(1)<<(_la-1086))&4095) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFunctionNameBaseContext is an interface to support dynamic dispatch.
type IFunctionNameBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionNameBaseContext differentiates from other interfaces.
	IsFunctionNameBaseContext()
}

type FunctionNameBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameBaseContext() *FunctionNameBaseContext {
	var p = new(FunctionNameBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = StmtParserRULE_functionNameBase
	return p
}

func (*FunctionNameBaseContext) IsFunctionNameBaseContext() {}

func NewFunctionNameBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameBaseContext {
	var p = new(FunctionNameBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = StmtParserRULE_functionNameBase

	return p
}

func (s *FunctionNameBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameBaseContext) ABS() antlr.TerminalNode {
	return s.GetToken(StmtParserABS, 0)
}

func (s *FunctionNameBaseContext) ACOS() antlr.TerminalNode {
	return s.GetToken(StmtParserACOS, 0)
}

func (s *FunctionNameBaseContext) ADDDATE() antlr.TerminalNode {
	return s.GetToken(StmtParserADDDATE, 0)
}

func (s *FunctionNameBaseContext) ADDTIME() antlr.TerminalNode {
	return s.GetToken(StmtParserADDTIME, 0)
}

func (s *FunctionNameBaseContext) AES_DECRYPT() antlr.TerminalNode {
	return s.GetToken(StmtParserAES_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) AES_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(StmtParserAES_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) AREA() antlr.TerminalNode {
	return s.GetToken(StmtParserAREA, 0)
}

func (s *FunctionNameBaseContext) ASBINARY() antlr.TerminalNode {
	return s.GetToken(StmtParserASBINARY, 0)
}

func (s *FunctionNameBaseContext) ASIN() antlr.TerminalNode {
	return s.GetToken(StmtParserASIN, 0)
}

func (s *FunctionNameBaseContext) ASTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserASTEXT, 0)
}

func (s *FunctionNameBaseContext) ASWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserASWKB, 0)
}

func (s *FunctionNameBaseContext) ASWKT() antlr.TerminalNode {
	return s.GetToken(StmtParserASWKT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_DECRYPT() antlr.TerminalNode {
	return s.GetToken(StmtParserASYMMETRIC_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_DERIVE() antlr.TerminalNode {
	return s.GetToken(StmtParserASYMMETRIC_DERIVE, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(StmtParserASYMMETRIC_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_SIGN() antlr.TerminalNode {
	return s.GetToken(StmtParserASYMMETRIC_SIGN, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_VERIFY() antlr.TerminalNode {
	return s.GetToken(StmtParserASYMMETRIC_VERIFY, 0)
}

func (s *FunctionNameBaseContext) ATAN() antlr.TerminalNode {
	return s.GetToken(StmtParserATAN, 0)
}

func (s *FunctionNameBaseContext) ATAN2() antlr.TerminalNode {
	return s.GetToken(StmtParserATAN2, 0)
}

func (s *FunctionNameBaseContext) BENCHMARK() antlr.TerminalNode {
	return s.GetToken(StmtParserBENCHMARK, 0)
}

func (s *FunctionNameBaseContext) BIN() antlr.TerminalNode {
	return s.GetToken(StmtParserBIN, 0)
}

func (s *FunctionNameBaseContext) BIT_COUNT() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_COUNT, 0)
}

func (s *FunctionNameBaseContext) BIT_LENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserBIT_LENGTH, 0)
}

func (s *FunctionNameBaseContext) BUFFER() antlr.TerminalNode {
	return s.GetToken(StmtParserBUFFER, 0)
}

func (s *FunctionNameBaseContext) CEIL() antlr.TerminalNode {
	return s.GetToken(StmtParserCEIL, 0)
}

func (s *FunctionNameBaseContext) CEILING() antlr.TerminalNode {
	return s.GetToken(StmtParserCEILING, 0)
}

func (s *FunctionNameBaseContext) CENTROID() antlr.TerminalNode {
	return s.GetToken(StmtParserCENTROID, 0)
}

func (s *FunctionNameBaseContext) CHARACTER_LENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserCHARACTER_LENGTH, 0)
}

func (s *FunctionNameBaseContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(StmtParserCHARSET, 0)
}

func (s *FunctionNameBaseContext) CHAR_LENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserCHAR_LENGTH, 0)
}

func (s *FunctionNameBaseContext) COERCIBILITY() antlr.TerminalNode {
	return s.GetToken(StmtParserCOERCIBILITY, 0)
}

func (s *FunctionNameBaseContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(StmtParserCOLLATION, 0)
}

func (s *FunctionNameBaseContext) COMPRESS() antlr.TerminalNode {
	return s.GetToken(StmtParserCOMPRESS, 0)
}

func (s *FunctionNameBaseContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(StmtParserCONCAT, 0)
}

func (s *FunctionNameBaseContext) CONCAT_WS() antlr.TerminalNode {
	return s.GetToken(StmtParserCONCAT_WS, 0)
}

func (s *FunctionNameBaseContext) CONNECTION_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserCONNECTION_ID, 0)
}

func (s *FunctionNameBaseContext) CONV() antlr.TerminalNode {
	return s.GetToken(StmtParserCONV, 0)
}

func (s *FunctionNameBaseContext) CONVERT_TZ() antlr.TerminalNode {
	return s.GetToken(StmtParserCONVERT_TZ, 0)
}

func (s *FunctionNameBaseContext) COS() antlr.TerminalNode {
	return s.GetToken(StmtParserCOS, 0)
}

func (s *FunctionNameBaseContext) COT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOT, 0)
}

func (s *FunctionNameBaseContext) COUNT() antlr.TerminalNode {
	return s.GetToken(StmtParserCOUNT, 0)
}

func (s *FunctionNameBaseContext) CRC32() antlr.TerminalNode {
	return s.GetToken(StmtParserCRC32, 0)
}

func (s *FunctionNameBaseContext) CREATE_ASYMMETRIC_PRIV_KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserCREATE_ASYMMETRIC_PRIV_KEY, 0)
}

func (s *FunctionNameBaseContext) CREATE_ASYMMETRIC_PUB_KEY() antlr.TerminalNode {
	return s.GetToken(StmtParserCREATE_ASYMMETRIC_PUB_KEY, 0)
}

func (s *FunctionNameBaseContext) CREATE_DH_PARAMETERS() antlr.TerminalNode {
	return s.GetToken(StmtParserCREATE_DH_PARAMETERS, 0)
}

func (s *FunctionNameBaseContext) CREATE_DIGEST() antlr.TerminalNode {
	return s.GetToken(StmtParserCREATE_DIGEST, 0)
}

func (s *FunctionNameBaseContext) CROSSES() antlr.TerminalNode {
	return s.GetToken(StmtParserCROSSES, 0)
}

func (s *FunctionNameBaseContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(StmtParserCUME_DIST, 0)
}

func (s *FunctionNameBaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StmtParserDATABASE, 0)
}

func (s *FunctionNameBaseContext) DATE() antlr.TerminalNode {
	return s.GetToken(StmtParserDATE, 0)
}

func (s *FunctionNameBaseContext) DATEDIFF() antlr.TerminalNode {
	return s.GetToken(StmtParserDATEDIFF, 0)
}

func (s *FunctionNameBaseContext) DATE_FORMAT() antlr.TerminalNode {
	return s.GetToken(StmtParserDATE_FORMAT, 0)
}

func (s *FunctionNameBaseContext) DAY() antlr.TerminalNode {
	return s.GetToken(StmtParserDAY, 0)
}

func (s *FunctionNameBaseContext) DAYNAME() antlr.TerminalNode {
	return s.GetToken(StmtParserDAYNAME, 0)
}

func (s *FunctionNameBaseContext) DAYOFMONTH() antlr.TerminalNode {
	return s.GetToken(StmtParserDAYOFMONTH, 0)
}

func (s *FunctionNameBaseContext) DAYOFWEEK() antlr.TerminalNode {
	return s.GetToken(StmtParserDAYOFWEEK, 0)
}

func (s *FunctionNameBaseContext) DAYOFYEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserDAYOFYEAR, 0)
}

func (s *FunctionNameBaseContext) DECODE() antlr.TerminalNode {
	return s.GetToken(StmtParserDECODE, 0)
}

func (s *FunctionNameBaseContext) DEGREES() antlr.TerminalNode {
	return s.GetToken(StmtParserDEGREES, 0)
}

func (s *FunctionNameBaseContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(StmtParserDENSE_RANK, 0)
}

func (s *FunctionNameBaseContext) DES_DECRYPT() antlr.TerminalNode {
	return s.GetToken(StmtParserDES_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) DES_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(StmtParserDES_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) DIMENSION() antlr.TerminalNode {
	return s.GetToken(StmtParserDIMENSION, 0)
}

func (s *FunctionNameBaseContext) DISJOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserDISJOINT, 0)
}

func (s *FunctionNameBaseContext) ELT() antlr.TerminalNode {
	return s.GetToken(StmtParserELT, 0)
}

func (s *FunctionNameBaseContext) ENCODE() antlr.TerminalNode {
	return s.GetToken(StmtParserENCODE, 0)
}

func (s *FunctionNameBaseContext) ENCRYPT() antlr.TerminalNode {
	return s.GetToken(StmtParserENCRYPT, 0)
}

func (s *FunctionNameBaseContext) ENDPOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserENDPOINT, 0)
}

func (s *FunctionNameBaseContext) ENVELOPE() antlr.TerminalNode {
	return s.GetToken(StmtParserENVELOPE, 0)
}

func (s *FunctionNameBaseContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(StmtParserEQUALS, 0)
}

func (s *FunctionNameBaseContext) EXP() antlr.TerminalNode {
	return s.GetToken(StmtParserEXP, 0)
}

func (s *FunctionNameBaseContext) EXPORT_SET() antlr.TerminalNode {
	return s.GetToken(StmtParserEXPORT_SET, 0)
}

func (s *FunctionNameBaseContext) EXTERIORRING() antlr.TerminalNode {
	return s.GetToken(StmtParserEXTERIORRING, 0)
}

func (s *FunctionNameBaseContext) EXTRACTVALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserEXTRACTVALUE, 0)
}

func (s *FunctionNameBaseContext) FIELD() antlr.TerminalNode {
	return s.GetToken(StmtParserFIELD, 0)
}

func (s *FunctionNameBaseContext) FIND_IN_SET() antlr.TerminalNode {
	return s.GetToken(StmtParserFIND_IN_SET, 0)
}

func (s *FunctionNameBaseContext) FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserFIRST_VALUE, 0)
}

func (s *FunctionNameBaseContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(StmtParserFLOOR, 0)
}

func (s *FunctionNameBaseContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(StmtParserFORMAT, 0)
}

func (s *FunctionNameBaseContext) FOUND_ROWS() antlr.TerminalNode {
	return s.GetToken(StmtParserFOUND_ROWS, 0)
}

func (s *FunctionNameBaseContext) FROM_BASE64() antlr.TerminalNode {
	return s.GetToken(StmtParserFROM_BASE64, 0)
}

func (s *FunctionNameBaseContext) FROM_DAYS() antlr.TerminalNode {
	return s.GetToken(StmtParserFROM_DAYS, 0)
}

func (s *FunctionNameBaseContext) FROM_UNIXTIME() antlr.TerminalNode {
	return s.GetToken(StmtParserFROM_UNIXTIME, 0)
}

func (s *FunctionNameBaseContext) GEOMCOLLFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMCOLLFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMCOLLFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMCOLLFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTION() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMETRYCOLLECTION, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMETRYCOLLECTIONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMETRYCOLLECTIONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMETRYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMETRYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYN() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMETRYN, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYTYPE() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMETRYTYPE, 0)
}

func (s *FunctionNameBaseContext) GEOMFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserGEOMFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GET_FORMAT() antlr.TerminalNode {
	return s.GetToken(StmtParserGET_FORMAT, 0)
}

func (s *FunctionNameBaseContext) GET_LOCK() antlr.TerminalNode {
	return s.GetToken(StmtParserGET_LOCK, 0)
}

func (s *FunctionNameBaseContext) GLENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserGLENGTH, 0)
}

func (s *FunctionNameBaseContext) GREATEST() antlr.TerminalNode {
	return s.GetToken(StmtParserGREATEST, 0)
}

func (s *FunctionNameBaseContext) GTID_SUBSET() antlr.TerminalNode {
	return s.GetToken(StmtParserGTID_SUBSET, 0)
}

func (s *FunctionNameBaseContext) GTID_SUBTRACT() antlr.TerminalNode {
	return s.GetToken(StmtParserGTID_SUBTRACT, 0)
}

func (s *FunctionNameBaseContext) HEX() antlr.TerminalNode {
	return s.GetToken(StmtParserHEX, 0)
}

func (s *FunctionNameBaseContext) HOUR() antlr.TerminalNode {
	return s.GetToken(StmtParserHOUR, 0)
}

func (s *FunctionNameBaseContext) IFNULL() antlr.TerminalNode {
	return s.GetToken(StmtParserIFNULL, 0)
}

func (s *FunctionNameBaseContext) INET6_ATON() antlr.TerminalNode {
	return s.GetToken(StmtParserINET6_ATON, 0)
}

func (s *FunctionNameBaseContext) INET6_NTOA() antlr.TerminalNode {
	return s.GetToken(StmtParserINET6_NTOA, 0)
}

func (s *FunctionNameBaseContext) INET_ATON() antlr.TerminalNode {
	return s.GetToken(StmtParserINET_ATON, 0)
}

func (s *FunctionNameBaseContext) INET_NTOA() antlr.TerminalNode {
	return s.GetToken(StmtParserINET_NTOA, 0)
}

func (s *FunctionNameBaseContext) INSTR() antlr.TerminalNode {
	return s.GetToken(StmtParserINSTR, 0)
}

func (s *FunctionNameBaseContext) INTERIORRINGN() antlr.TerminalNode {
	return s.GetToken(StmtParserINTERIORRINGN, 0)
}

func (s *FunctionNameBaseContext) INTERSECTS() antlr.TerminalNode {
	return s.GetToken(StmtParserINTERSECTS, 0)
}

func (s *FunctionNameBaseContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(StmtParserINVISIBLE, 0)
}

func (s *FunctionNameBaseContext) ISCLOSED() antlr.TerminalNode {
	return s.GetToken(StmtParserISCLOSED, 0)
}

func (s *FunctionNameBaseContext) ISEMPTY() antlr.TerminalNode {
	return s.GetToken(StmtParserISEMPTY, 0)
}

func (s *FunctionNameBaseContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(StmtParserISNULL, 0)
}

func (s *FunctionNameBaseContext) ISSIMPLE() antlr.TerminalNode {
	return s.GetToken(StmtParserISSIMPLE, 0)
}

func (s *FunctionNameBaseContext) IS_FREE_LOCK() antlr.TerminalNode {
	return s.GetToken(StmtParserIS_FREE_LOCK, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4() antlr.TerminalNode {
	return s.GetToken(StmtParserIS_IPV4, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4_COMPAT() antlr.TerminalNode {
	return s.GetToken(StmtParserIS_IPV4_COMPAT, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4_MAPPED() antlr.TerminalNode {
	return s.GetToken(StmtParserIS_IPV4_MAPPED, 0)
}

func (s *FunctionNameBaseContext) IS_IPV6() antlr.TerminalNode {
	return s.GetToken(StmtParserIS_IPV6, 0)
}

func (s *FunctionNameBaseContext) IS_USED_LOCK() antlr.TerminalNode {
	return s.GetToken(StmtParserIS_USED_LOCK, 0)
}

func (s *FunctionNameBaseContext) LAG() antlr.TerminalNode {
	return s.GetToken(StmtParserLAG, 0)
}

func (s *FunctionNameBaseContext) LAST_INSERT_ID() antlr.TerminalNode {
	return s.GetToken(StmtParserLAST_INSERT_ID, 0)
}

func (s *FunctionNameBaseContext) LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserLAST_VALUE, 0)
}

func (s *FunctionNameBaseContext) LCASE() antlr.TerminalNode {
	return s.GetToken(StmtParserLCASE, 0)
}

func (s *FunctionNameBaseContext) LEAD() antlr.TerminalNode {
	return s.GetToken(StmtParserLEAD, 0)
}

func (s *FunctionNameBaseContext) LEAST() antlr.TerminalNode {
	return s.GetToken(StmtParserLEAST, 0)
}

func (s *FunctionNameBaseContext) LEFT() antlr.TerminalNode {
	return s.GetToken(StmtParserLEFT, 0)
}

func (s *FunctionNameBaseContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserLENGTH, 0)
}

func (s *FunctionNameBaseContext) LINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserLINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) LINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserLINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) LINESTRING() antlr.TerminalNode {
	return s.GetToken(StmtParserLINESTRING, 0)
}

func (s *FunctionNameBaseContext) LINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserLINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) LINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserLINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) LN() antlr.TerminalNode {
	return s.GetToken(StmtParserLN, 0)
}

func (s *FunctionNameBaseContext) LOAD_FILE() antlr.TerminalNode {
	return s.GetToken(StmtParserLOAD_FILE, 0)
}

func (s *FunctionNameBaseContext) LOCATE() antlr.TerminalNode {
	return s.GetToken(StmtParserLOCATE, 0)
}

func (s *FunctionNameBaseContext) LOG() antlr.TerminalNode {
	return s.GetToken(StmtParserLOG, 0)
}

func (s *FunctionNameBaseContext) LOG10() antlr.TerminalNode {
	return s.GetToken(StmtParserLOG10, 0)
}

func (s *FunctionNameBaseContext) LOG2() antlr.TerminalNode {
	return s.GetToken(StmtParserLOG2, 0)
}

func (s *FunctionNameBaseContext) LOWER() antlr.TerminalNode {
	return s.GetToken(StmtParserLOWER, 0)
}

func (s *FunctionNameBaseContext) LPAD() antlr.TerminalNode {
	return s.GetToken(StmtParserLPAD, 0)
}

func (s *FunctionNameBaseContext) LTRIM() antlr.TerminalNode {
	return s.GetToken(StmtParserLTRIM, 0)
}

func (s *FunctionNameBaseContext) MAKEDATE() antlr.TerminalNode {
	return s.GetToken(StmtParserMAKEDATE, 0)
}

func (s *FunctionNameBaseContext) MAKETIME() antlr.TerminalNode {
	return s.GetToken(StmtParserMAKETIME, 0)
}

func (s *FunctionNameBaseContext) MAKE_SET() antlr.TerminalNode {
	return s.GetToken(StmtParserMAKE_SET, 0)
}

func (s *FunctionNameBaseContext) MASTER_POS_WAIT() antlr.TerminalNode {
	return s.GetToken(StmtParserMASTER_POS_WAIT, 0)
}

func (s *FunctionNameBaseContext) MBRCONTAINS() antlr.TerminalNode {
	return s.GetToken(StmtParserMBRCONTAINS, 0)
}

func (s *FunctionNameBaseContext) MBRDISJOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserMBRDISJOINT, 0)
}

func (s *FunctionNameBaseContext) MBREQUAL() antlr.TerminalNode {
	return s.GetToken(StmtParserMBREQUAL, 0)
}

func (s *FunctionNameBaseContext) MBRINTERSECTS() antlr.TerminalNode {
	return s.GetToken(StmtParserMBRINTERSECTS, 0)
}

func (s *FunctionNameBaseContext) MBROVERLAPS() antlr.TerminalNode {
	return s.GetToken(StmtParserMBROVERLAPS, 0)
}

func (s *FunctionNameBaseContext) MBRTOUCHES() antlr.TerminalNode {
	return s.GetToken(StmtParserMBRTOUCHES, 0)
}

func (s *FunctionNameBaseContext) MBRWITHIN() antlr.TerminalNode {
	return s.GetToken(StmtParserMBRWITHIN, 0)
}

func (s *FunctionNameBaseContext) MD5() antlr.TerminalNode {
	return s.GetToken(StmtParserMD5, 0)
}

func (s *FunctionNameBaseContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserMICROSECOND, 0)
}

func (s *FunctionNameBaseContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(StmtParserMINUTE, 0)
}

func (s *FunctionNameBaseContext) MLINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserMLINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MLINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserMLINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MOD() antlr.TerminalNode {
	return s.GetToken(StmtParserMOD, 0)
}

func (s *FunctionNameBaseContext) MONTH() antlr.TerminalNode {
	return s.GetToken(StmtParserMONTH, 0)
}

func (s *FunctionNameBaseContext) MONTHNAME() antlr.TerminalNode {
	return s.GetToken(StmtParserMONTHNAME, 0)
}

func (s *FunctionNameBaseContext) MPOINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserMPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MPOINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserMPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MPOLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserMPOLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MPOLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserMPOLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRING() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTILINESTRING, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTILINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTILINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTIPOINT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTIPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTIPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGON() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTIPOLYGON, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTIPOLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserMULTIPOLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) NAME_CONST() antlr.TerminalNode {
	return s.GetToken(StmtParserNAME_CONST, 0)
}

func (s *FunctionNameBaseContext) NTH_VALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserNTH_VALUE, 0)
}

func (s *FunctionNameBaseContext) NTILE() antlr.TerminalNode {
	return s.GetToken(StmtParserNTILE, 0)
}

func (s *FunctionNameBaseContext) NULLIF() antlr.TerminalNode {
	return s.GetToken(StmtParserNULLIF, 0)
}

func (s *FunctionNameBaseContext) NUMGEOMETRIES() antlr.TerminalNode {
	return s.GetToken(StmtParserNUMGEOMETRIES, 0)
}

func (s *FunctionNameBaseContext) NUMINTERIORRINGS() antlr.TerminalNode {
	return s.GetToken(StmtParserNUMINTERIORRINGS, 0)
}

func (s *FunctionNameBaseContext) NUMPOINTS() antlr.TerminalNode {
	return s.GetToken(StmtParserNUMPOINTS, 0)
}

func (s *FunctionNameBaseContext) OCT() antlr.TerminalNode {
	return s.GetToken(StmtParserOCT, 0)
}

func (s *FunctionNameBaseContext) OCTET_LENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserOCTET_LENGTH, 0)
}

func (s *FunctionNameBaseContext) ORD() antlr.TerminalNode {
	return s.GetToken(StmtParserORD, 0)
}

func (s *FunctionNameBaseContext) OVERLAPS() antlr.TerminalNode {
	return s.GetToken(StmtParserOVERLAPS, 0)
}

func (s *FunctionNameBaseContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(StmtParserPERCENT_RANK, 0)
}

func (s *FunctionNameBaseContext) PERIOD_ADD() antlr.TerminalNode {
	return s.GetToken(StmtParserPERIOD_ADD, 0)
}

func (s *FunctionNameBaseContext) PERIOD_DIFF() antlr.TerminalNode {
	return s.GetToken(StmtParserPERIOD_DIFF, 0)
}

func (s *FunctionNameBaseContext) PI() antlr.TerminalNode {
	return s.GetToken(StmtParserPI, 0)
}

func (s *FunctionNameBaseContext) POINT() antlr.TerminalNode {
	return s.GetToken(StmtParserPOINT, 0)
}

func (s *FunctionNameBaseContext) POINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POINTN() antlr.TerminalNode {
	return s.GetToken(StmtParserPOINTN, 0)
}

func (s *FunctionNameBaseContext) POLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserPOLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserPOLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POLYGON() antlr.TerminalNode {
	return s.GetToken(StmtParserPOLYGON, 0)
}

func (s *FunctionNameBaseContext) POLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserPOLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserPOLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POSITION() antlr.TerminalNode {
	return s.GetToken(StmtParserPOSITION, 0)
}

func (s *FunctionNameBaseContext) POW() antlr.TerminalNode {
	return s.GetToken(StmtParserPOW, 0)
}

func (s *FunctionNameBaseContext) POWER() antlr.TerminalNode {
	return s.GetToken(StmtParserPOWER, 0)
}

func (s *FunctionNameBaseContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(StmtParserQUARTER, 0)
}

func (s *FunctionNameBaseContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(StmtParserQUOTE, 0)
}

func (s *FunctionNameBaseContext) RADIANS() antlr.TerminalNode {
	return s.GetToken(StmtParserRADIANS, 0)
}

func (s *FunctionNameBaseContext) RAND() antlr.TerminalNode {
	return s.GetToken(StmtParserRAND, 0)
}

func (s *FunctionNameBaseContext) RANK() antlr.TerminalNode {
	return s.GetToken(StmtParserRANK, 0)
}

func (s *FunctionNameBaseContext) RANDOM_BYTES() antlr.TerminalNode {
	return s.GetToken(StmtParserRANDOM_BYTES, 0)
}

func (s *FunctionNameBaseContext) RELEASE_LOCK() antlr.TerminalNode {
	return s.GetToken(StmtParserRELEASE_LOCK, 0)
}

func (s *FunctionNameBaseContext) REVERSE() antlr.TerminalNode {
	return s.GetToken(StmtParserREVERSE, 0)
}

func (s *FunctionNameBaseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(StmtParserRIGHT, 0)
}

func (s *FunctionNameBaseContext) ROUND() antlr.TerminalNode {
	return s.GetToken(StmtParserROUND, 0)
}

func (s *FunctionNameBaseContext) ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(StmtParserROW_COUNT, 0)
}

func (s *FunctionNameBaseContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(StmtParserROW_NUMBER, 0)
}

func (s *FunctionNameBaseContext) RPAD() antlr.TerminalNode {
	return s.GetToken(StmtParserRPAD, 0)
}

func (s *FunctionNameBaseContext) RTRIM() antlr.TerminalNode {
	return s.GetToken(StmtParserRTRIM, 0)
}

func (s *FunctionNameBaseContext) SECOND() antlr.TerminalNode {
	return s.GetToken(StmtParserSECOND, 0)
}

func (s *FunctionNameBaseContext) SEC_TO_TIME() antlr.TerminalNode {
	return s.GetToken(StmtParserSEC_TO_TIME, 0)
}

func (s *FunctionNameBaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(StmtParserSCHEMA, 0)
}

func (s *FunctionNameBaseContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(StmtParserSESSION_USER, 0)
}

func (s *FunctionNameBaseContext) SESSION_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(StmtParserSESSION_VARIABLES_ADMIN, 0)
}

func (s *FunctionNameBaseContext) SHA() antlr.TerminalNode {
	return s.GetToken(StmtParserSHA, 0)
}

func (s *FunctionNameBaseContext) SHA1() antlr.TerminalNode {
	return s.GetToken(StmtParserSHA1, 0)
}

func (s *FunctionNameBaseContext) SHA2() antlr.TerminalNode {
	return s.GetToken(StmtParserSHA2, 0)
}

func (s *FunctionNameBaseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(StmtParserSIGN, 0)
}

func (s *FunctionNameBaseContext) SIN() antlr.TerminalNode {
	return s.GetToken(StmtParserSIN, 0)
}

func (s *FunctionNameBaseContext) SLEEP() antlr.TerminalNode {
	return s.GetToken(StmtParserSLEEP, 0)
}

func (s *FunctionNameBaseContext) SOUNDEX() antlr.TerminalNode {
	return s.GetToken(StmtParserSOUNDEX, 0)
}

func (s *FunctionNameBaseContext) SQL_THREAD_WAIT_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(StmtParserSQL_THREAD_WAIT_AFTER_GTIDS, 0)
}

func (s *FunctionNameBaseContext) SQRT() antlr.TerminalNode {
	return s.GetToken(StmtParserSQRT, 0)
}

func (s *FunctionNameBaseContext) SRID() antlr.TerminalNode {
	return s.GetToken(StmtParserSRID, 0)
}

func (s *FunctionNameBaseContext) STARTPOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserSTARTPOINT, 0)
}

func (s *FunctionNameBaseContext) STRCMP() antlr.TerminalNode {
	return s.GetToken(StmtParserSTRCMP, 0)
}

func (s *FunctionNameBaseContext) STR_TO_DATE() antlr.TerminalNode {
	return s.GetToken(StmtParserSTR_TO_DATE, 0)
}

func (s *FunctionNameBaseContext) ST_AREA() antlr.TerminalNode {
	return s.GetToken(StmtParserST_AREA, 0)
}

func (s *FunctionNameBaseContext) ST_ASBINARY() antlr.TerminalNode {
	return s.GetToken(StmtParserST_ASBINARY, 0)
}

func (s *FunctionNameBaseContext) ST_ASTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_ASTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_ASWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_ASWKB, 0)
}

func (s *FunctionNameBaseContext) ST_ASWKT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_ASWKT, 0)
}

func (s *FunctionNameBaseContext) ST_BUFFER() antlr.TerminalNode {
	return s.GetToken(StmtParserST_BUFFER, 0)
}

func (s *FunctionNameBaseContext) ST_CENTROID() antlr.TerminalNode {
	return s.GetToken(StmtParserST_CENTROID, 0)
}

func (s *FunctionNameBaseContext) ST_CONTAINS() antlr.TerminalNode {
	return s.GetToken(StmtParserST_CONTAINS, 0)
}

func (s *FunctionNameBaseContext) ST_CROSSES() antlr.TerminalNode {
	return s.GetToken(StmtParserST_CROSSES, 0)
}

func (s *FunctionNameBaseContext) ST_DIFFERENCE() antlr.TerminalNode {
	return s.GetToken(StmtParserST_DIFFERENCE, 0)
}

func (s *FunctionNameBaseContext) ST_DIMENSION() antlr.TerminalNode {
	return s.GetToken(StmtParserST_DIMENSION, 0)
}

func (s *FunctionNameBaseContext) ST_DISJOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_DISJOINT, 0)
}

func (s *FunctionNameBaseContext) ST_DISTANCE() antlr.TerminalNode {
	return s.GetToken(StmtParserST_DISTANCE, 0)
}

func (s *FunctionNameBaseContext) ST_ENDPOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_ENDPOINT, 0)
}

func (s *FunctionNameBaseContext) ST_ENVELOPE() antlr.TerminalNode {
	return s.GetToken(StmtParserST_ENVELOPE, 0)
}

func (s *FunctionNameBaseContext) ST_EQUALS() antlr.TerminalNode {
	return s.GetToken(StmtParserST_EQUALS, 0)
}

func (s *FunctionNameBaseContext) ST_EXTERIORRING() antlr.TerminalNode {
	return s.GetToken(StmtParserST_EXTERIORRING, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMCOLLFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMTXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMCOLLFROMTXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMCOLLFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMETRYCOLLECTIONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMETRYCOLLECTIONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMETRYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMETRYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYN() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMETRYN, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYTYPE() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMETRYTYPE, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_GEOMFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_INTERIORRINGN() antlr.TerminalNode {
	return s.GetToken(StmtParserST_INTERIORRINGN, 0)
}

func (s *FunctionNameBaseContext) ST_INTERSECTION() antlr.TerminalNode {
	return s.GetToken(StmtParserST_INTERSECTION, 0)
}

func (s *FunctionNameBaseContext) ST_INTERSECTS() antlr.TerminalNode {
	return s.GetToken(StmtParserST_INTERSECTS, 0)
}

func (s *FunctionNameBaseContext) ST_ISCLOSED() antlr.TerminalNode {
	return s.GetToken(StmtParserST_ISCLOSED, 0)
}

func (s *FunctionNameBaseContext) ST_ISEMPTY() antlr.TerminalNode {
	return s.GetToken(StmtParserST_ISEMPTY, 0)
}

func (s *FunctionNameBaseContext) ST_ISSIMPLE() antlr.TerminalNode {
	return s.GetToken(StmtParserST_ISSIMPLE, 0)
}

func (s *FunctionNameBaseContext) ST_LINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_LINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_LINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_LINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_LINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_LINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_LINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_LINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_NUMGEOMETRIES() antlr.TerminalNode {
	return s.GetToken(StmtParserST_NUMGEOMETRIES, 0)
}

func (s *FunctionNameBaseContext) ST_NUMINTERIORRING() antlr.TerminalNode {
	return s.GetToken(StmtParserST_NUMINTERIORRING, 0)
}

func (s *FunctionNameBaseContext) ST_NUMINTERIORRINGS() antlr.TerminalNode {
	return s.GetToken(StmtParserST_NUMINTERIORRINGS, 0)
}

func (s *FunctionNameBaseContext) ST_NUMPOINTS() antlr.TerminalNode {
	return s.GetToken(StmtParserST_NUMPOINTS, 0)
}

func (s *FunctionNameBaseContext) ST_OVERLAPS() antlr.TerminalNode {
	return s.GetToken(StmtParserST_OVERLAPS, 0)
}

func (s *FunctionNameBaseContext) ST_POINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_POINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_POINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_POINTN() antlr.TerminalNode {
	return s.GetToken(StmtParserST_POINTN, 0)
}

func (s *FunctionNameBaseContext) ST_POLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_POLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_POLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_POLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_POLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(StmtParserST_POLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_SRID() antlr.TerminalNode {
	return s.GetToken(StmtParserST_SRID, 0)
}

func (s *FunctionNameBaseContext) ST_STARTPOINT() antlr.TerminalNode {
	return s.GetToken(StmtParserST_STARTPOINT, 0)
}

func (s *FunctionNameBaseContext) ST_SYMDIFFERENCE() antlr.TerminalNode {
	return s.GetToken(StmtParserST_SYMDIFFERENCE, 0)
}

func (s *FunctionNameBaseContext) ST_TOUCHES() antlr.TerminalNode {
	return s.GetToken(StmtParserST_TOUCHES, 0)
}

func (s *FunctionNameBaseContext) ST_UNION() antlr.TerminalNode {
	return s.GetToken(StmtParserST_UNION, 0)
}

func (s *FunctionNameBaseContext) ST_WITHIN() antlr.TerminalNode {
	return s.GetToken(StmtParserST_WITHIN, 0)
}

func (s *FunctionNameBaseContext) ST_X() antlr.TerminalNode {
	return s.GetToken(StmtParserST_X, 0)
}

func (s *FunctionNameBaseContext) ST_Y() antlr.TerminalNode {
	return s.GetToken(StmtParserST_Y, 0)
}

func (s *FunctionNameBaseContext) SUBDATE() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBDATE, 0)
}

func (s *FunctionNameBaseContext) SUBSTRING_INDEX() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBSTRING_INDEX, 0)
}

func (s *FunctionNameBaseContext) SUBTIME() antlr.TerminalNode {
	return s.GetToken(StmtParserSUBTIME, 0)
}

func (s *FunctionNameBaseContext) SYSTEM_USER() antlr.TerminalNode {
	return s.GetToken(StmtParserSYSTEM_USER, 0)
}

func (s *FunctionNameBaseContext) TAN() antlr.TerminalNode {
	return s.GetToken(StmtParserTAN, 0)
}

func (s *FunctionNameBaseContext) TIME() antlr.TerminalNode {
	return s.GetToken(StmtParserTIME, 0)
}

func (s *FunctionNameBaseContext) TIMEDIFF() antlr.TerminalNode {
	return s.GetToken(StmtParserTIMEDIFF, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserTIMESTAMP, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(StmtParserTIMESTAMPADD, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(StmtParserTIMESTAMPDIFF, 0)
}

func (s *FunctionNameBaseContext) TIME_FORMAT() antlr.TerminalNode {
	return s.GetToken(StmtParserTIME_FORMAT, 0)
}

func (s *FunctionNameBaseContext) TIME_TO_SEC() antlr.TerminalNode {
	return s.GetToken(StmtParserTIME_TO_SEC, 0)
}

func (s *FunctionNameBaseContext) TOUCHES() antlr.TerminalNode {
	return s.GetToken(StmtParserTOUCHES, 0)
}

func (s *FunctionNameBaseContext) TO_BASE64() antlr.TerminalNode {
	return s.GetToken(StmtParserTO_BASE64, 0)
}

func (s *FunctionNameBaseContext) TO_DAYS() antlr.TerminalNode {
	return s.GetToken(StmtParserTO_DAYS, 0)
}

func (s *FunctionNameBaseContext) TO_SECONDS() antlr.TerminalNode {
	return s.GetToken(StmtParserTO_SECONDS, 0)
}

func (s *FunctionNameBaseContext) UCASE() antlr.TerminalNode {
	return s.GetToken(StmtParserUCASE, 0)
}

func (s *FunctionNameBaseContext) UNCOMPRESS() antlr.TerminalNode {
	return s.GetToken(StmtParserUNCOMPRESS, 0)
}

func (s *FunctionNameBaseContext) UNCOMPRESSED_LENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserUNCOMPRESSED_LENGTH, 0)
}

func (s *FunctionNameBaseContext) UNHEX() antlr.TerminalNode {
	return s.GetToken(StmtParserUNHEX, 0)
}

func (s *FunctionNameBaseContext) UNIX_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StmtParserUNIX_TIMESTAMP, 0)
}

func (s *FunctionNameBaseContext) UPDATEXML() antlr.TerminalNode {
	return s.GetToken(StmtParserUPDATEXML, 0)
}

func (s *FunctionNameBaseContext) UPPER() antlr.TerminalNode {
	return s.GetToken(StmtParserUPPER, 0)
}

func (s *FunctionNameBaseContext) UUID() antlr.TerminalNode {
	return s.GetToken(StmtParserUUID, 0)
}

func (s *FunctionNameBaseContext) UUID_SHORT() antlr.TerminalNode {
	return s.GetToken(StmtParserUUID_SHORT, 0)
}

func (s *FunctionNameBaseContext) VALIDATE_PASSWORD_STRENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserVALIDATE_PASSWORD_STRENGTH, 0)
}

func (s *FunctionNameBaseContext) VERSION() antlr.TerminalNode {
	return s.GetToken(StmtParserVERSION, 0)
}

func (s *FunctionNameBaseContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(StmtParserVISIBLE, 0)
}

func (s *FunctionNameBaseContext) WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(StmtParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, 0)
}

func (s *FunctionNameBaseContext) WEEK() antlr.TerminalNode {
	return s.GetToken(StmtParserWEEK, 0)
}

func (s *FunctionNameBaseContext) WEEKDAY() antlr.TerminalNode {
	return s.GetToken(StmtParserWEEKDAY, 0)
}

func (s *FunctionNameBaseContext) WEEKOFYEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserWEEKOFYEAR, 0)
}

func (s *FunctionNameBaseContext) WEIGHT_STRING() antlr.TerminalNode {
	return s.GetToken(StmtParserWEIGHT_STRING, 0)
}

func (s *FunctionNameBaseContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(StmtParserWITHIN, 0)
}

func (s *FunctionNameBaseContext) YEAR() antlr.TerminalNode {
	return s.GetToken(StmtParserYEAR, 0)
}

func (s *FunctionNameBaseContext) YEARWEEK() antlr.TerminalNode {
	return s.GetToken(StmtParserYEARWEEK, 0)
}

func (s *FunctionNameBaseContext) Y_FUNCTION() antlr.TerminalNode {
	return s.GetToken(StmtParserY_FUNCTION, 0)
}

func (s *FunctionNameBaseContext) X_FUNCTION() antlr.TerminalNode {
	return s.GetToken(StmtParserX_FUNCTION, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAY() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_ARRAY, 0)
}

func (s *FunctionNameBaseContext) JSON_OBJECT() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_OBJECT, 0)
}

func (s *FunctionNameBaseContext) JSON_QUOTE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_QUOTE, 0)
}

func (s *FunctionNameBaseContext) JSON_CONTAINS() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_CONTAINS, 0)
}

func (s *FunctionNameBaseContext) JSON_CONTAINS_PATH() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_CONTAINS_PATH, 0)
}

func (s *FunctionNameBaseContext) JSON_EXTRACT() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_EXTRACT, 0)
}

func (s *FunctionNameBaseContext) JSON_KEYS() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_KEYS, 0)
}

func (s *FunctionNameBaseContext) JSON_OVERLAPS() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_OVERLAPS, 0)
}

func (s *FunctionNameBaseContext) JSON_SEARCH() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_SEARCH, 0)
}

func (s *FunctionNameBaseContext) JSON_VALUE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_VALUE, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAY_APPEND() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_ARRAY_APPEND, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAY_INSERT() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_ARRAY_INSERT, 0)
}

func (s *FunctionNameBaseContext) JSON_INSERT() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_INSERT, 0)
}

func (s *FunctionNameBaseContext) JSON_MERGE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_MERGE, 0)
}

func (s *FunctionNameBaseContext) JSON_MERGE_PATCH() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_MERGE_PATCH, 0)
}

func (s *FunctionNameBaseContext) JSON_MERGE_PRESERVE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_MERGE_PRESERVE, 0)
}

func (s *FunctionNameBaseContext) JSON_REMOVE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_REMOVE, 0)
}

func (s *FunctionNameBaseContext) JSON_REPLACE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_REPLACE, 0)
}

func (s *FunctionNameBaseContext) JSON_SET() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_SET, 0)
}

func (s *FunctionNameBaseContext) JSON_UNQUOTE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_UNQUOTE, 0)
}

func (s *FunctionNameBaseContext) JSON_DEPTH() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_DEPTH, 0)
}

func (s *FunctionNameBaseContext) JSON_LENGTH() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_LENGTH, 0)
}

func (s *FunctionNameBaseContext) JSON_TYPE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_TYPE, 0)
}

func (s *FunctionNameBaseContext) JSON_VALID() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_VALID, 0)
}

func (s *FunctionNameBaseContext) JSON_TABLE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_TABLE, 0)
}

func (s *FunctionNameBaseContext) JSON_SCHEMA_VALID() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_SCHEMA_VALID, 0)
}

func (s *FunctionNameBaseContext) JSON_SCHEMA_VALIDATION_REPORT() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_SCHEMA_VALIDATION_REPORT, 0)
}

func (s *FunctionNameBaseContext) JSON_PRETTY() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_PRETTY, 0)
}

func (s *FunctionNameBaseContext) JSON_STORAGE_FREE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_STORAGE_FREE, 0)
}

func (s *FunctionNameBaseContext) JSON_STORAGE_SIZE() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_STORAGE_SIZE, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAYAGG() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_ARRAYAGG, 0)
}

func (s *FunctionNameBaseContext) JSON_OBJECTAGG() antlr.TerminalNode {
	return s.GetToken(StmtParserJSON_OBJECTAGG, 0)
}

func (s *FunctionNameBaseContext) LASTVAL() antlr.TerminalNode {
	return s.GetToken(StmtParserLASTVAL, 0)
}

func (s *FunctionNameBaseContext) NEXTVAL() antlr.TerminalNode {
	return s.GetToken(StmtParserNEXTVAL, 0)
}

func (s *FunctionNameBaseContext) SETVAL() antlr.TerminalNode {
	return s.GetToken(StmtParserSETVAL, 0)
}

func (s *FunctionNameBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.EnterFunctionNameBase(s)
	}
}

func (s *FunctionNameBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StmtParserListener); ok {
		listenerT.ExitFunctionNameBase(s)
	}
}

func (p *StmtParser) FunctionNameBase() (localctx IFunctionNameBaseContext) {
	this := p
	_ = this

	localctx = NewFunctionNameBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, StmtParserRULE_functionNameBase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1569)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StmtParserDATABASE || (int64((_la-93)) & ^0x3f) == 0 && ((int64(1)<<(_la-93))&11258999068426241) != 0 || (int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&-17179869161) != 0 || (int64((_la-275)) & ^0x3f) == 0 && ((int64(1)<<(_la-275))&1099513674691) != 0 || _la == StmtParserINVISIBLE || (int64((_la-656)) & ^0x3f) == 0 && ((int64(1)<<(_la-656))&-9223372036838064127) != 0 || (int64((_la-783)) & ^0x3f) == 0 && ((int64(1)<<(_la-783))&-8589934599) != 0 || (int64((_la-847)) & ^0x3f) == 0 && ((int64(1)<<(_la-847))&-257) != 0 || (int64((_la-911)) & ^0x3f) == 0 && ((int64(1)<<(_la-911))&-1) != 0 || (int64((_la-975)) & ^0x3f) == 0 && ((int64(1)<<(_la-975))&-529) != 0 || (int64((_la-1039)) & ^0x3f) == 0 && ((int64(1)<<(_la-1039))&2111062325329919) != 0 || _la == StmtParserMOD) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *StmtParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 57:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 58:
		var t *PredicateContext = nil
		if localctx != nil {
			t = localctx.(*PredicateContext)
		}
		return p.Predicate_Sempred(t, predIndex)

	case 59:
		var t *ExpressionAtomContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionAtomContext)
		}
		return p.ExpressionAtom_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *StmtParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *StmtParser) Predicate_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *StmtParser) ExpressionAtom_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 10)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
